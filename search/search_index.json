{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Index","text":"<p>Develop server-side web services and API's from the ground up using Clojure following a simple and data-centric design and applying functional programming concepts.</p> <p>Use a REPL Workflow approach to provide instant feedback on the code behaviour as it is written, validating design decisions as they are made.</p> <p></p>"},{"location":"#tools","title":"Tools","text":"<p>Clojure CLI is used to configure and run projects, enhance with aliases from Practicalli Clojure CLI Config.</p> <p>Larger projects use Integrant &amp; Integrant REPL to manage components and state, using a reloaded REPL workflow to manage changes in addtion to evaluating functions in the REPL.</p> <p>Persistence is provides via Postgresql (and eventually JUXT Crux)</p> <p>tools.build will be used to create Clojure artefacts for deployment, with GitHub actions and Docker used for Continuous Integration and orchestrating systems.</p> <p>make is a general build tool used to support project development and support automation of wokflow tasks.</p> Heroku deployment to be archived <p>Heroku Cloud service deployment approach is being archived as the service no longer provides a developer environment (November 2022)</p> Older content using Leiningen <p>Older content uses Leiningen for project configuration.  This content can be converted to a Clojure CLI project by creating a <code>deps.edn</code> file containing the relevant dependencies.  Add a <code>build.clj</code> configuration to build deployable assets.</p>"},{"location":"#library-composition-approach","title":"Library Composition approach","text":"<p>The Clojure community provides a diverse set of libraries, each focused on a specific need. Libraries are assembled to rapidly develop a tailored solution, avoiding bloat and the unnecessary complexity that comes with large frameworks. Libraries are relatively simple to replace with alternatives or used as inspiration for your own custom functions.</p> <p>Templates can be used to create example projects with common libraries, with code to show showing how libraries can be wired together. provide examples of libraries working together.</p> Avoiding large frameworks <p>Frameworks are design decisions others have made and generalised to solve a range of problem, so there is no guarantee on how many of those decisions are relevant for the current project.</p> <p>Frameworks tend to include many features not relevant to the current problem, which can be challenging to remove or replace. Frameworks can be over relied upon, taking away an opportunity to think about the most relevant solution.</p> <p>Clojure does not focus on the classic framework approach like Rails or Spring, for this reason.</p>"},{"location":"#sponsor-my-work","title":"Sponsor my work","text":"<p>The majority of my work is now focused on the Practicalli series of books and videos and an advisory role with several communities</p> <p>Thank you to Cognitect, Nubank and a wide range of other sponsors from the Clojure community for your continued support</p>"},{"location":"#creative-commons-license","title":"Creative commons license","text":"This work is licensed under a Creative Commons Attribution 4.0 ShareAlike License (including images &amp; stylesheets)."},{"location":"adding-more-route/using-cond-function/","title":"Using cond function","text":"<p>Change the if function to <code>cond</code> and define additional routes you want to match on.  We will show you a <code>/goodbye</code> route, feel free to add your own.</p> <p>Edit the <code>src/webdev/core.clj</code> file and update the <code>greet</code> function as follows</p> <pre><code>(defn greet\n\"A function to process all requests for the web server.  The default route / returns one message, /goodbye route another. for all other routes an error message is returned\"\n[request]\n(cond\n(= \"/\" (:uri request))\n{:status 200\n:body \"Hello, Clojure World.  I now update automatically\"\n:headers {}}\n(= \"/goodbye\" (:uri request))\n{:status 200\n:body \"This is the end, my old friend\"\n:headers {}}\n:else\n{:status 404\n:body \"Sorry, page not found\"\n:headers {}}))\n</code></pre> <p>Writing a big cond statement for all our routes would be really tedious and difficult to manage.  So lets look at Compojure.</p>"},{"location":"app-servers/","title":"Application servers","text":"<p>Application servers provide a common platform services to support server-side running of JVM applications (hence the term application server).</p> <p>These servers are often referred to more generically as web servers as they mostly work over http / https.</p> <p>Clojure uses embedded servers to support REPL Driven Development, so both new function definitions and server restarts can be managed within the context of a running REPL (avoiding the need to restart the REPL).</p> <p></p>"},{"location":"app-servers/#application-components","title":"Application components","text":"<ul> <li>Routing</li> <li>Requests</li> <li>Responses</li> <li>Middleware</li> </ul>"},{"location":"app-servers/#practicalli-defacto-library-choices","title":"Practicalli defacto library choices","text":"<p>Practicalli defacto choices for building web services:</p> Library Purpose ring/ring Provides Jetty and Ring - managing requests and responses in Clojure using hash-maps metosin/reitit Routing of request and responses, support for ring handlers and middleware (and interceptors)"},{"location":"app-servers/#example-projects","title":"Example Projects","text":"Project Description Status Monitor Clojure CLI project using Httpkit, Compojure for routing, Hiccup and SVG graphics.  Deployed via CircleCI on Heroku Banking On Clojure Clojure CLI project using httpkit, Ring utilities, Compojure for routing.  relational data store using next.jdbc, HoneySQL, clojure.spec &amp; postgresql.  Generative testing using clojure.spec ToDo app Leiningen project using Ring (Jetty), Compojure for routing and Hiccup for HTML generation"},{"location":"app-servers/app-server-logging/","title":"Application Server Logging","text":"<ul> <li>What to log in which environments</li> <li>Logging levels</li> <li>Logging as object rather than text</li> <li>mulog</li> </ul>"},{"location":"app-servers/app-server-logging/#simplistic-logging","title":"Simplistic logging","text":"<p><code>println</code> function sends information to the standard out and so is a very simple mechanism to create logs from specific parts of the application. This should be used sparingly and is no substitute for a specific logging framework.</p> <p><code>println</code> can be useful in the REPL the standard out message as well as the evaluation result (<code>nil</code>) are shown.  <code>println</code> can provide additional feedback for non-terminating processes that run in the REPL, such as an application server.</p> <p></p>"},{"location":"app-servers/app-server-logging/#logging-to-elastic-search-kibana","title":"Logging to Elastic Search / Kibana","text":"<p>Log messages as objects, rather than text strings, provides greater sophistication by search tools as the messages have a structure.</p> <ul> <li>Elastisch - Clojure client for Elasticsearch and GitHub repository</li> <li>Elasticsearch and Clojure: Getting Started - the practical academic</li> <li>Spandex - Elasticsearch new low level rest-client wrapper</li> </ul>"},{"location":"app-servers/app-server-logging/#problematic-practices","title":"Problematic Practices","text":"<p>Logging to the REPL - sending lots of logs to the REPL makes the REPL much harder to use directly</p> <p>Logging strings - logs entries are typically objects and far more searchable and discoverable that strings, so send objects to the logging service</p>"},{"location":"app-servers/atom-based-restart/","title":"Atom based restart","text":"<p>A Clojure atom is used to hold a reference to a running server instance.</p> <p>An atom is a mutable container that holds any type of value.  The value in the atom is immutable.  The atom is mutable, but only with specific functions, avoiding locking issues often arising with mutable values.</p> <ul> <li><code>swap!</code> the current value in the atom using a function to create a new value</li> <li><code>reset!</code> the current value in the atom with a specific value</li> <li><code>deref</code> or <code>@</code> returns the value contained within the atom</li> </ul>"},{"location":"app-servers/atom-based-restart/#reference-to-server-process","title":"Reference to server process","text":"<p>A reference to the server process will be held in a Clojure atom, a mutable container.  An atom is used as a value for the server reference will be swapped into the atom on server start.  The atom is set to nil when the server stops.  Using an atom allows for this value to change.</p> <p>Define a Clojure atom with the initial value of <code>nil</code>.</p> <p><code>defonce</code> is used instead of <code>def</code> to prevent the reference to the app-server being lost if the expression is re-evaluated.  A restart of the REPL process is required before evaluation the expression has an effect.</p> <pre><code>(defonce app-server-instance (atom nil))\n</code></pre>"},{"location":"app-servers/atom-based-restart/#-main-function","title":"-main function","text":"<p>The <code>-main</code> function determines an HTTP port value, from either an argument, an operating system <code>$PORT</code> environment variable or using the default 8888 value.</p> <p><code>-main</code> calls  <code>app-server-start</code> which starts the app server and resets the value of the atom with a reference to that instance.</p> <p><code>(.stop @app-server-instance)</code> uses the instance reference to stop the server.  <code>app-server-stop</code> function check to see if a running instance exists and if so, stops the server.</p> <p>HTTP Kit timeout</p> <p>HTTP Kit can be sent a timeout value to gracefully shut down the server.  The <code>app-server-stop</code> function sends a <code>:timeout 100</code> value to the running app server instance.</p> <p>The REPL is still running, so the server can be started by calling <code>(-main)</code> or <code>(app-server-start 8888)</code>.</p> <p><code>app-server-restart</code> is a convenience function that stops and starts the application server, meaning the developer only needs to evaluate <code>(app-server-restart)</code></p> jettyhttpkit <pre><code>(ns practicalli.example-webapp\n(:gen-class)\n(:require [ring.adapter.jetty :as jetty]\n[compojure.core :refer [defroutes GET]]))\n;; Routing\n(defroutes app\n(GET \"/\" [] {:status 200 :body \"App Server Running\"}))\n;; System\n;; Reference to server instance\n(defonce app-server-instance (atom nil))\n(defn app-server-start\n\"Start Jetty Application server, adding instance to global state\"\n[port]\n(reset! app-server-instance\n(jetty/run-jetty #'app {:port port :join? false})))\n(defn app-server-stop\n\"Check for a running app-server instance, shutdown if present\"\n[]\n(when @app-server-instance\n(.stop @app-server-instance))\n(reset! app-server-instance nil))\n(defn app-server-restart\n\"Stop and then start the application server, loading in the new code\"\n[]\n(app-server-stop)\n(app-server-start (Integer. (or (System/getenv \"PORT\") 8888))))\n(defn -main\n\"Determine an HTTP port number and start application server on that port.\n  A value for port can be passed as the first argument to the command to start the application via the CLI\"\n[&amp; [port]]\n(let [port (Integer. (or port\n(System/getenv \"PORT\")\n8888))]\n(app-server-start port)))\n;; REPL driven development\n(comment\n(app-server-restart)\n(-main)\n)\n</code></pre> <pre><code>(ns practicalli.example-webapp\n(:gen-class)\n(:require [org.httpkit.server :as app-server]\n[compojure.core :refer [defroutes GET]]))\n;; Routing\n(defroutes app\n(GET \"/\" [] {:status 200 :body \"App Server Running\"}))\n;; System\n(defonce app-server-instance (atom nil))\n(defn app-server-stop\n\"Gracefully shutdown the server, waiting 100ms\"\n[]\n(when-not (nil? @app-server-instance)\n(@app-server-instance :timeout 100)\n(reset! app-server-instance nil)\n(println \"INFO: Application server shutting down...\")))\n(defn app-server-start\n\"Start the application server and run the application\"\n[port]\n(println \"INFO: Starting server on port: \" port)\n(reset! app-server-instance\n(app-server/run-server #'app {:port (Integer/parseInt port)})))\n(defn app-server-restart\n\"Convenience function to stop and start the application server\"\n[]\n(app-server-stop)\n(-main))\n(defn -main\n\"Start the application server on a specific port\"\n[&amp; [port]]\n(let [port (Integer. (or port (System/getenv \"PORT\") 8888))]\n(app-server-start port)))\n;; REPL driven development\n(comment\n;; Re/Start application server\n(app-server-restart)\n;; Shutdown server\n(app-server-stop)\n)\n</code></pre> <p>Http-kit server documentation contains details of asynchronous websockets and HTTP streaming configurations.</p>"},{"location":"app-servers/clojure-project/","title":"New Clojure Project","text":"<p>Create a new Clojure project using Clojure CLI</p> deps-newclj-new <p>Create a new project using the <code>:project/create</code> alias from Practicalli Clojure CLI Config and the <code>app</code> template using deps-new <pre><code>clojure -T:project/create :template app :name practicalli/web-service\n</code></pre></p> <p>Create a new project using the <code>:project/new</code> alias from Practicalli Clojure CLI Config and the app template using clj-new <pre><code>clojure -T:project/new :template app :name practicalli/web-service\n</code></pre></p>"},{"location":"app-servers/clojure-project/#add-web-server-library","title":"Add web server library","text":"<p>Add either Ring (Jetty) or Httpkit library as a project dependency to run an embedded server that listens to HTTP requests and passes those requests to the Clojure service.</p> JettyHTTP Kit <p>Add a ring library that includes an embedded Jetty server.</p> <p>The <code>ring/ring</code> library includes all ring libraries including the embedded Jetty server</p> <p>Edit the project <code>deps.edn</code> file and add the <code>ring/ring {:mvn/version \"1.9.5\"}</code> dependency to the top-level <code>:deps</code> key, which defines the libraries used to make the project.</p> <pre><code>{:paths [\"src\" \"resources\"]\n:deps {org.clojure/clojure {:mvn/version \"1.11.3\"}\nring/ring           {:mvn/version \"1.9.6\"}}}\n</code></pre> <p>Or add the <code>ring/ring-core</code> and <code>ring/ring-jetty-adapter</code> libraries, saving a few millisecond when starting the project. <pre><code>{:paths [\"src\" \"resources\"]\n:deps {org.clojure/clojure     {:mvn/version \"1.11.3\"}\nring/ring-core          {:mvn/version \"1.9.6\"}\nring/ring-jetty-adapter {:mvn/version \"1.9.6\"}}}\n</code></pre></p> <p>Add the HTTP Kit Server library which includes the client and server namespaces, although only the Server namespace will be used.</p> <p>Edit the project <code>deps.edn</code> file and add the <code>http-kit/http-kit {:mvn/version \"2.3.0\"}</code> dependency to the top-level <code>:deps</code> key, which defines the libraries used to make the project.</p> <pre><code>{:paths [\"src\" \"resources\"]\n:deps {org.clojure/clojure {:mvn/version \"1.11.3\"}\nhttp-kit/http-kit   {:mvn/version \"2.3.0\"}}}\n</code></pre>"},{"location":"app-servers/clojure-project/#ring-library","title":"Ring library","text":"<p>Ring is a Clojure web applications library inspired by Python's WSGI and Ruby's Rack. By abstracting the details of HTTP into a simple, unified API, Ring allows web applications to be constructed of modular components that can be shared among a variety of applications, web servers, and web frameworks.</p> <p>Ring interface specification</p> <p>Ring is composed of several libraries which can be included specifically, rather than requiring all of them with ring/ring</p> <ul> <li><code>ring/ring-core</code> - essential functions for handling parameters, cookies and more</li> <li><code>ring/ring-devel</code> - functions for developing and debugging Ring applications</li> <li><code>ring/ring-servlet</code> - construct Java servlets from Ring handlers</li> <li><code>ring/ring-jetty-adapter</code> - a Ring adapter that uses the Jetty webserver</li> </ul> <p>Ring documentation Ring API docs</p>"},{"location":"app-servers/create-server/","title":"Create a server","text":"<p>To create  a web (http) server using a common library, e.g. Jetty or Http-kit</p> <ol> <li>Require a library that provides the web server</li> <li>Create a function to start a server, taking a port number as an option</li> </ol>"},{"location":"app-servers/create-server/#require-web-server-library","title":"Require Web Server Library","text":"jettyhttpkit <p>Add the web server library to the namespace using a <code>:reqiure</code> directive.</p> <pre><code>(ns practicalli.web-server\n(:gen-class)\n(:require [ring.adapter.jetty :as http-server]))\n</code></pre> <p>Add the web server library to the namespace using a <code>:reqiure</code> directive.</p> <pre><code>(ns practicalli.web-server\n(:gen-class)\n(:require [org.httpkit.server :as http-server]))\n</code></pre>"},{"location":"app-servers/create-server/#code-a-basic-web-server","title":"Code a basic web server","text":"jettyhttpkit <p>Define a function called <code>server-start</code> that takes a value for the port number which the server will listen too.</p> <p>Call the <code>run-jetty</code> function from <code>ring.adapter.jetty</code> to start the Jetty Server.  <code>run-jetty</code> takes several arguments</p> <ul> <li>the main request handler, initially just a function (usually a router function to handle many different types of requests)</li> <li>a hash-map of options, e.g. <code>{:port 8080 :join? false}</code>.  Options are listed in the <code>run-jetty</code> function definition.</li> </ul> <p>The <code>:port</code> key is associated with an integer value that represents the port number.</p> <p>The <code>:join</code> key is associated with a boolean value, <code>true</code> if the the REPL process should attached to the Jetty thread (blocking input until server stops), <code>false</code> to continue in a separate thread.</p> <pre><code>  (defn server-start\n[port]\n(http-server/run-jetty #'app {:port port :join? false}))\n</code></pre> <p>Define a function called <code>server-start</code> that takes a value for the port number which the server will listen too.</p> <p>Call the <code>run-server</code> function from <code>org.httpkit.server</code> to start the Http-kit server.  <code>run-jetty</code> takes several arguments</p> <ul> <li>the main request handler, initially just a function (usually a router function to handle many different types of requests)</li> <li>a hash-map of options, e.g. <code>{:port 8080 :join? false}</code>.  Options are listed in the <code>run-server</code> function definition.</li> </ul> <p>The <code>:port</code> key is associated with an integer value that represents the port number.</p> <pre><code>(defn server-start\n\"Start the application server and run the application\"\n[port]\n(app-server/run-server #'app {:port port}))\n</code></pre> <p>Http-kit server documentation contains details of asynchronous websockets and HTTP streaming configurations.</p>"},{"location":"app-servers/create-server/#request-handler-function","title":"Request handler function","text":"<p>The server passes all HTTP requests, converted to a request hash-map by ring, to the <code>app</code> function.  The <code>app</code> function returns a ring response hash-map which is sent back to the client (browser) as an Http response.</p> <p>Define a function that takes a request hash-map as an argument and returns a basic response hash-map.</p> <pre><code>(defn app [request]\n{:status  200\n:headers {:content-type \"text/html\"}\n:body    \"&lt;h1&gt;Clojure Web Server Alive&lt;/h1&gt;\"})\n</code></pre> <p><code>:status</code> http status code as an integer - 200 means okay</p> <p><code>:header</code> response headers such as content type, a hash-map with optional values (the value can be an empty hash-map <code>{}</code>)</p> <p><code>:body</code> a string containing the body of the response, such as text, HTML or JSON.</p>"},{"location":"app-servers/debugging/","title":"Debugging application servers","text":""},{"location":"app-servers/debugging/#debugging-handlers","title":"Debugging handlers","text":"<p>As handler functions are simply Clojure functions that take a request hash-map, those functions can be called from unit tests or the REPL to test they are working correctly.</p>"},{"location":"app-servers/debugging/#ring-mock","title":"Ring mock","text":"<p>Generate mock requests and responses (?) for testing handler functions</p>"},{"location":"app-servers/debugging/#problematic-practices-to-avoid","title":"Problematic Practices to avoid","text":"<p>Using <code>(def name ,,,)</code> expressions for debugging is very bad, especially if those expressions are left in production code.</p> <p><code>(println ,,,)</code> statements seem convenient however have very limited value.  Using the REPL and REPL based debugging tools provide very useful output</p>"},{"location":"app-servers/http-kit-server-options/","title":"Http-kit Server Options","text":"<p>Available options are defined in the doc-string of org.httpkit.server/run-server</p> Options Description <code>:ip</code> Which ip (if has many ips) to bind <code>:port</code> Which port listen incomming request <code>:thread</code> Http worker thread count <code>:queue-size</code> Max job queued before reject to project self <code>:max-body</code> Max http body: 8m <code>:max-ws</code> Max websocket message size <code>:max-line</code> Max http inital line length <code>:proxy-protocol</code> Proxy protocol e/o #{:disable :enable :optional} <code>:worker-name-prefix</code> Worker thread name prefix <code>:worker-pool</code> ExecutorService to use for request-handling (:thread, :worker-name-prefix, :queue-size are ignored if set) <code>:error-logger</code> Arity-2 fn (args: string text, exception) to log errors <code>:warn-logger</code> Arity-2 fn (args: string text, exception) to log warnings <code>:event-logger</code> Arity-1 fn (arg: string event name) <code>:event-names</code> map of HTTP-Kit event names to respective loggable event names <code>:server-header</code> The \"Server\" header. If missing, defaults to \"http-kit\", disabled if nil. <code>:legacy-return-value?</code> true  (default) returns a (fn stop-server [&amp; {:keys [timeout] :or {timeout 100}}]) ; false (recommended) Returns the HttpServer which can be used with <code>server-port</code>, ; <code>server-status</code>, <code>server-stop!</code>, etc. <p>See Httpkit migration documentation to see the minor difference between Http-kit server and other ring compliant servers like Jetty.</p>"},{"location":"app-servers/java-system-properties/","title":"Java System properties","text":"<p>System properties can be set on the Java command line using the <code>-Dpropertyname=value</code> syntax. They can also be added at Clojure runtime using <code>(System/getProperties)</code> will return a Properties object with the system properties for the current REPL.</p> <p>Properties are often defined in a <code>*.properties</code> file to configure the environment in containerized deployment processes.  For example, the version of Java used in Heroku containers is set by adding <code>java.runtime.version=11</code> property to a <code>system.properties</code> file.</p>"},{"location":"app-servers/java-system-properties/#commonly-used-properties","title":"Commonly used properties","text":"Java Runtime Description java.home JRE home directory java.library.path JRE library search path for search native libraries (usually taken from PATH environment variable) java.class.path JRE classpath e.g., '.' (dot \u2013 used for current working directory). java.ext.dirs JRE extension library path(s) java.version JDK version java.runtime.version JRE version File system Description file.separator symbol for file directory separator ('/' for Unix or '\\' for windows) path.separator symbol for separating path entries in PATH or CLASSPATH. (':' for Unix or ';' for windows) line.separator symbol for end-of-line / new line (\"\\n\" for Unix or \"\\r\\n\" for windows) or /Mac OS X. User system Description user.name the user\u2019s name. user.home the user\u2019s home directory. user.dir the user\u2019s current working directory Operating System Description os.name operating System name os.version operating System version os.arch operating System architecture"},{"location":"app-servers/java-system-properties/#examining-the-system-properties","title":"Examining the system properties","text":"<p>Evaluating  <code>(System/getProperties)</code> on an Ubuntu Linux operating system running Java 11 and Spacemacs with CIDER returned the following properties.</p> <pre><code>  \"sun.desktop\" = \"gnome\"\n  \"awt.toolkit\" = \"sun.awt.X11.XToolkit\"\n  \"java.specification.version\" = \"11\"\n  \"sun.cpu.isalist\" = \"\"\n  \"sun.jnu.encoding\" = \"UTF-8\"\n  \"java.class.path\" = \"src:resources:/home/practicalli/.m2/repository/org/clojure/clojure/1.10.1/clojure-1.10.1.jar:/home/practicalli/.m2/repository/joda-time/joda-time/2...\n  \"java.vm.vendor\" = \"Ubuntu\"\n  \"sun.arch.data.model\" = \"64\"\n  \"sun.font.fontmanager\" = \"sun.awt.X11FontManager\"\n  \"java.vendor.url\" = \"https://ubuntu.com/\"\n  \"user.timezone\" = \"Europe/London\"\n  \"os.name\" = \"Linux\"\n  \"java.vm.specification.version\" = \"11\"\n  \"sun.java.launcher\" = \"SUN_STANDARD\"\n  \"user.country\" = \"US\"\n  \"sun.boot.library.path\" = \"/usr/lib/jvm/java-11-openjdk-amd64/lib\"\n  \"sun.java.command\" = \"clojure.main -m nrepl.cmdline --middleware [\\\"refactor-nrepl.middleware/wrap-refactor\\\", \\\"cider.nrepl/cider-middleware\\\"]\"\n  \"jdk.debug\" = \"release\"\n  \"sun.cpu.endian\" = \"little\"\n  \"user.home\" = \"/home/practicalli\"\n  \"user.language\" = \"en\"\n  \"java.specification.vendor\" = \"Oracle Corporation\"\n  \"clojure.libfile\" = \".cpcache/4064833315.libs\"\n  \"java.version.date\" = \"2020-04-14\"\n  \"java.home\" = \"/usr/lib/jvm/java-11-openjdk-amd64\"\n  \"file.separator\" = \"/\"\n  \"java.vm.compressedOopsMode\" = \"Zero based\"\n  \"line.separator\" = \"\\n\"\n  \"java.specification.name\" = \"Java Platform API Specification\"\n  \"java.vm.specification.vendor\" = \"Oracle Corporation\"\n  \"java.awt.graphicsenv\" = \"sun.awt.X11GraphicsEnvironment\"\n  \"sun.management.compiler\" = \"HotSpot 64-Bit Tiered Compilers\"\n  \"java.runtime.version\" = \"11.0.7+10-post-Ubuntu-3ubuntu1\"\n  \"user.name\" = \"practicalli\"\n  \"path.separator\" = \":\"\n  \"os.version\" = \"5.4.0-40-generic\"\n  \"java.runtime.name\" = \"OpenJDK Runtime Environment\"\n  \"file.encoding\" = \"UTF-8\"\n  \"java.vm.name\" = \"OpenJDK 64-Bit Server VM\"\n  \"java.vendor.url.bug\" = \"https://bugs.launchpad.net/ubuntu/+source/openjdk-lts\"\n  \"java.io.tmpdir\" = \"/tmp\"\n  \"java.version\" = \"11.0.7\"\n  \"user.dir\" = \"/home/practicalli/projects/clojure/database-access/banking-on-clojure-webapp\"\n  \"os.arch\" = \"amd64\"\n  \"java.vm.specification.name\" = \"Java Virtual Machine Specification\"\n  \"java.awt.printerjob\" = \"sun.print.PSPrinterJob\"\n  \"sun.os.patch.level\" = \"unknown\"\n  \"java.library.path\" = \"/usr/java/packages/lib:/usr/lib/x86_64-linux-gnu/jni:/lib/x86_64-linux-gnu:/usr/lib/x86_64-linux-gnu:/usr/lib/jni:/lib:/usr/lib\"\n  \"java.vendor\" = \"Ubuntu\"\n  \"java.vm.info\" = \"mixed mode, sharing\"\n  \"java.vm.version\" = \"11.0.7+10-post-Ubuntu-3ubuntu1\"\n  \"sun.io.unicode.encoding\" = \"UnicodeLittle\"\n  \"apple.awt.UIElement\" = \"true\"\n  \"java.class.version\" = \"55.0\"\n</code></pre>"},{"location":"app-servers/jetty-server-options/","title":"Jetty Server Options","text":"<p>Option keys available to pass to the <code>run-jetty</code> function from <code>ring.adaptor.jetty</code></p> Option Description <code>:configurator</code> a function called with the Jetty Server instance <code>:async?</code> if true, treat the handler as asynchronous <code>:async-timeout</code> async context timeout in ms (defaults to 0, no timeout) <code>:async-timeout-handler</code> an async handler to handle an async context timeout <code>:port</code> the port to listen on (defaults to 80) <code>:host</code> the hostname to listen on <code>:join?</code> blocks the thread until server ends (defaults to true) <code>:daemon?</code> use daemon threads (defaults to false) <code>:http?</code> listen on :port for HTTP traffic (defaults to true) <code>:ssl?</code> allow connections over HTTPS <code>:ssl-port</code> the SSL port to listen on (defaults to 443, implies :ssl? is true) <code>:ssl-context</code> an optional SSLContext to use for SSL connections <code>:exclude-ciphers</code> when :ssl? is true, additionally exclude these cipher suites <code>:exclude-protocols</code> when :ssl? is true, additionally exclude these protocols <code>:replace-exclude-ciphers?</code> when true, :exclude-ciphers will replace rather than add to the cipher exclusion list (defaults to false) <code>:replace-exclude-protocols?</code> when true, :exclude-protocols will replace rather than add to the protocols exclusion list (defaults to false) <code>:keystore</code> the keystore to use for SSL connections <code>:keystore-type</code> the keystore type (default jks) <code>:key-password</code> the password to the keystore <code>:keystore-scan-interval</code> if not nil, the interval in seconds to scan for an updated keystore <code>:thread-pool</code> custom thread pool instance for Jetty to use <code>:truststore</code> a truststore to use for SSL connections <code>:trust-password</code> the password to the truststore <code>:max-threads</code> the maximum number of threads to use (default 50) <code>:min-threads</code> the minimum number of threads to use (default 8) <code>:max-queued-requests</code> the maximum number of requests to be queued <code>:thread-idle-timeout</code> Set the maximum thread idle time. Threads that are idle for longer than this period may be stopped (default 60000) <code>:max-idle-time</code> the maximum idle time in milliseconds for a connection (default 200000) <code>:client-auth</code> SSL client certificate authenticate, may be set to :need,:want or :none (defaults to :none) <code>:send-date-header?</code> add a date header to the response (default true) <code>:output-buffer-size</code> the response body buffer size (default 32768) <code>:request-header-size</code> the maximum size of a request header (default 8192) <code>:response-header-size</code> the maximum size of a response header (default 8192) <code>:send-server-version?</code> add Server header to HTTP response (default true)"},{"location":"app-servers/middleware/","title":"Middleware","text":"<p>Apply common transformations to request and or response hash-maps, such as security tokens, cookie management, session and access management, presentation templates, etc.</p> <p>Middleware is implemented by Clojure functions that receive a handler as an argument and return a handler as a result.</p>"},{"location":"app-servers/middleware/#middleware-in-ring","title":"Middleware in Ring","text":"<p>Middleware can wrap handlers or other middleware, affecting their behavior.</p> <p>For example the <code>wrap-reload</code> middleware enables live reloading by detecting file changes and reloading affected functions into their namespace, before the request is passed to the relevant handler function</p> <p>Middleware provided by Ring includes:</p> <p>In <code>ring/ring-core</code>:</p> <ul> <li>wrap-cookies (ring.middleware.cookies)</li> <li>wrap-file (ring.middleware.file)</li> <li>wrap-file-info (ring.middleware.file-info)</li> <li>wrap-flash (ring.middleware.flash)</li> <li>wrap-keyword-params (ring.middleware.keyword-params)</li> <li>wrap-multipart-params (ring.middleware.multipart-params</li> <li>wrap-nested-params (ring.middleware.nested-params</li> <li>wrap-params (ring.middleware.params)</li> <li>wrap-session (ring.middleware.session)</li> </ul> <p>In <code>ring/ring-devel</code>:</p> <ul> <li>wrap-lint (ring.middleware.lint)</li> <li>wrap-reload (ring.middleware.reload)</li> <li>wrap-stacktrace (ring.middleware.stacktrace)</li> </ul>"},{"location":"app-servers/overview/","title":"Overview of Application servers","text":"<p>Application servers  for Clojure run an embedded JVM application, such as Jetty or http-kit server.</p> <p>App servers are started within the Clojure REPL process, as an embedded server. This approach means that during development a server can be restarted to load in new code and immediately update the running application, without having to restart the REPL.</p> <p></p> Embedded servers in Clojure <p>Clojure takes a more distributed approach to deployment, starting an embedded application server within the application itself.  This approach is more conducive to the container and cloud compute infrastructure.  Scaling is achieved by running multiple instances of the application, each on its own embedded application server.</p> <p>In Java was common to have a single application server with all applications deployed as Jar or War archives.  This fitted with the classic architecture of deploying on a single resource rich physical hardware server.  Clojure applications can also be deployed in this classic approach if required.</p>"},{"location":"app-servers/overview/#which-application-server-to-use","title":"Which Application Server to use","text":"<p>The most commonly used application servers are in the table below, with Jetty being the most common as it is wrapped by the ring library.</p> <p>Jetty is the the defacto server in Practicalli guides, with occasional examples using other libraries.</p> Application Server Description Eclipse Jetty The original embedded Java application server most commonly used for Clojure web apps Http-kit High performance Clojure/Java application server Apache Tomcat Classic Java application server, very common in JVM environments Netty Java NIO asynchronous event-driven network application framework Aleph HTTP Clojure (Netty) Ring-compliant server with support for returning Manifold for asynchronous programming"},{"location":"app-servers/overview/#eclipse-jetty","title":"Eclipse Jetty","text":"<p>Jetty is the most commonly used application server on the Java Virtual machine.</p> <p>Eclipse Jetty provides a Web server and javax.servlet container, plus support for HTTP/2, WebSocket, OSGi, JMX, JNDI, JAAS and many other integrations. These components are open source and available for commercial use and distribution.</p> <p>Eclipse Jetty is used in a wide variety of projects and products, both in development and production. Jetty can be easily embedded in devices, tools, frameworks, application servers, and clusters. See the Jetty Powered page for more uses of Jetty.</p> <p>The current recommended version for use is Jetty 9</p>"},{"location":"app-servers/overview/#http-kit","title":"Http-kit","text":"<p>HTTP Kit is a minimalist, efficient, Ring-compatible HTTP client/server for Clojure.</p> <p>HTTP Kit uses a event-driven architecture to support highly concurrent a/synchronous web applications. Feature a unified API for WebSocket and HTTP long polling/streaming</p> <p>The underlying server is implemented in Java with a Clojure wrapper.</p>"},{"location":"app-servers/overview/#apache-tomcat","title":"Apache Tomcat","text":"<p>Apache Tomcat is an open source implementation of the Java Servlet, JavaServer Pages, Java Expression Language and Java WebSocket technologies. The Java Servlet, JavaServer Pages, Java Expression Language and Java WebSocket specifications are developed under the Java Community Process.</p> <p>Apache Tomcat software powers numerous large-scale, mission-critical web applications across a diverse range of industries and organizations, example are listed on the PoweredBy page.</p> <p>Apache Tomcat, Tomcat, Apache, the Apache feather, and the Apache Tomcat project logo are trademarks of the Apache Software Foundation.</p> <p>Apache Tomcat 9.0 is the current stable version with active development now on version 10.</p> <p>Tomcat can be run in embedded mode, so it is not necessary to build a WAR file and deploy it in a standalone Tomcat server.</p> <ul> <li>Create a Java Web Application Using Embedded Tomcat - Heroku</li> </ul> <p></p> <p>Netty is an asynchronous event-driven network application framework for rapid development of maintainable high performance protocol servers &amp; clients.</p> <p>Netty is a NIO client server framework which enables quick and easy development of network applications such as protocol servers and clients. It greatly simplifies and streamlines network programming such as TCP and UDP socket server.</p> <p></p>"},{"location":"app-servers/overview/#aleph-and-manifold","title":"Aleph and Manifold","text":"<p>Manifold provides streams focused libraries, such as Aleph HTTP for web applications and TCP/UDP for more general networking.</p> <p> </p>"},{"location":"app-servers/route-requests/","title":"Route Requests","text":"<p>Https servers accept many different types of requests, defined as a combination of</p> <ul> <li>Https protocol - GET, POST, etc.</li> <li>Path of resource - page, api endpoint, etc.</li> </ul>"},{"location":"app-servers/route-requests/#defining-routes","title":"Defining routes","text":"<p>Reitit is a data driven approach to defining routes and support ring Ring request, response and middleware.</p> <p>Compojure provides the defroutes macro and a simple DSL for defining routes.</p> reititcompojure <p>Add reitit as a dependency</p> deps.edn<pre><code>{:paths\n[\"src\" \"resources\"]\n:deps\n{org.clojure/clojure {:mvn/version \"1.10.1\"}\nhttp-kit/http-kit   {:mvn/version \"2.3.0\"}\nring/ring-core      {:mvn/version \"1.8.1\"}\nmetosin/reitit      {:mvn/version \"0.5.18\"}}}\n</code></pre> <p>Restart the REPL (unless Reitit was added using hotload)</p> <p>Add reitit namespace to web-server namespace</p> <pre><code>(ns practicalli.web-server\n(:gen-class)\n(:require [ring.adapter.jetty :as http-server]\n[reitit.core :as routing]))\n</code></pre> <p>Define example routes</p> <pre><code>(def routes\n[[\"/\"\n{:handler (constantly {:status 200\n:headers {:content-type \"text/html\"}\n:body \"&lt;h1&gt;Welcome to Practicalli Clojure Web Server\"})}\n[\"status\"\n{:handler (constantly {:status 200\n:headers {:content-type \"application/json\"}\n:body {:alive true}})}]]])\n</code></pre> <p>Define example routes using the reitit ring-handler</p> <pre><code>(defroutes app\n\"Initial routes for web server\"\n[]\n(reitit-ring/ring-handler\n(reitit-ring/router       ;; routes defined as a vector of vectors\n[\n[\"/\"\n]\n]\n;; Middleware, coersion &amp; content negotiation\n;; Default hanlder passed to ring-handler\n(ring/routes\n;; Respond to any other route - returns blank page\n;; TODO: create custom handler for routes not recognised\n(ring/create-default-handler))\n)))\n</code></pre> <p>Add Compojure as a dependency</p> <pre><code>{:paths\n[\"src\" \"resources\"]\n:deps\n{org.clojure/clojure {:mvn/version \"1.10.1\"}\nhttp-kit/http-kit   {:mvn/version \"2.3.0\"}\nring/ring-core      {:mvn/version \"1.8.1\"}\nring/ring-devel     {:mvn/version \"1.8.1\"}\ncompojure/compojure {:mvn/version \"1.6.1\"}}}\n</code></pre> <p>Add Compojure namespace to web-server namespace</p> <pre><code>(ns practicalli.web-server\n(:gen-class)\n(:require [ring.adapter.jetty :as http-server]\n[compojure.core  :refer [defroutes GET]]\n[compojure.route :refer [not-found]\n[ring.middleware.reload :refer [wrap-reload]]]))\n</code></pre> <p>Restart the REPL (unless Compojure was added using hotload)</p> <p>Define routes using compojure</p> <pre><code>(defroutes app\n(GET \"/\"         [] handler/welcome-page)\n(GET \"/accounts\" [] handler/accounts-overview-page)\n(GET \"/account\"  [] handler/account-history)\n(GET \"/transfer\" [] handler/money-transfer)\n(GET \"/payment\"  [] handler/money-payment)\n(GET \"/register\" [] handler/register-customer) )\n</code></pre>"},{"location":"app-servers/routing-libraries/","title":"Routing libraries","text":""},{"location":"app-servers/routing-libraries/#application-logic","title":"Application Logic","text":"<ul> <li>Routing</li> <li>Requests</li> <li>Responses</li> <li>handlers</li> <li>middleware</li> <li>Serving static content</li> </ul>"},{"location":"app-servers/routing-libraries/#ring","title":"Ring","text":"<p>Ring is the defacto library for server-side web applications.  Even if not using the Ring library, the contents that Ring established are used by other libraries.</p>"},{"location":"app-servers/routing-libraries/#compojure","title":"Compojure","text":"<p>Compojure is a library that works with Ring to manage   Compojure also has convenience functions that make ring responses easier to generate.</p> <p>In this section we will update our project to use Compojure.</p>"},{"location":"app-servers/routing-libraries/#bidi-bi-directional-uri-dispatch","title":"Bidi - Bi-directional URI dispatch","text":"<p>https://github.com/juxt/bidi Clojure and ClojureScript</p> <p>bidi is written to do 'one thing well' (URI dispatch and formation) and is intended for use with Ring middleware, HTTP servers (including Jetty, http-kit and aleph) and is fully compatible with Liberator.</p>"},{"location":"app-servers/routing-libraries/#yada-resources-as-data","title":"yada - resources as data","text":"<p>yada is a web library for Clojure, designed to support the creation of production services via HTTP.</p> <p>It has the following features:</p> <ul> <li>Standards-based, comprehensive HTTP coverage (content negotiation, conditional requests, etc.)</li> <li>Parameter validation and coercion, automatic Swagger support</li> <li>Rich extensibility (methods, mime-types, security and more)</li> <li>Asynchronous, efficient interceptor-chain design built on manifold</li> <li>Excellent performance, suitable for heavy production workloads</li> </ul> <p>yada is a sibling library to bidi - whereas bidi is based on routes as data, yada is based on resources as data.</p>"},{"location":"app-servers/routing-libraries/#reitit","title":"Reitit","text":"<p>A data approach to routing</p>"},{"location":"app-servers/routing/","title":"Routing","text":"<p>Compojure Bidi Reitit</p>"},{"location":"app-servers/routing/#injecting-resources-using-routing","title":"Injecting resources using routing","text":"<pre><code>(defroutes\nGET /accounts/account [] (partial db/connection request))\n</code></pre> <p>And then have a handler that takes both a request and resource arguments. This makes the handler pure in respect that it does not require any external data to do its job (yes the connection is external, but the reference to the connection is provided as an argument to the side effect is abstracted away).</p> <p>Middleware could also be used to wrap all the routes, however, if some routes do not use the database then this approach adds redundancy and makes the abstraction feel too high a level in the application design.  This approach also makes it harder to test the handlers as normal Clojure functions, as its not possible to simply call that function with an argument.</p>"},{"location":"app-servers/routing/#resources","title":"Resources","text":"<ul> <li> <p>How to manage database connections in Clojure - ClojureVerse</p> </li> <li> <p>https://devcenter.heroku.com/articles/database-connection-pooling-with-clojure</p> </li> <li>https://stackoverflow.com/questions/19776462/passing-state-as-parameter-to-a-ring-handler</li> </ul>"},{"location":"app-servers/simple-restart/","title":"Simple restart approach","text":"<p>Use a <code>def</code> expression to create a named reference to the running server, providing a simple way to stop the application server.</p> jettyhttpkit <p>The app-server starts when the application starts, as the <code>app-server-start</code> is called from <code>-main</code> once the port value has been taken from either an argument to <code>-main</code>, an operating system <code>$PORT</code> environment variable or the default 8080.</p> <p><code>(def app-server-instance (-main 8080))</code> is placed within a <code>(comment )</code> expression.  This provides a manual way for the developer to start the application server.</p> <p>The <code>app-server-instance</code> is a symbol pointing to the server instance.  This instance can be used to shut down the server.</p> <p>When the developer evaluates <code>(.stop app-server-instance)</code>, the instance is used to shut down the running application server.</p> <p>The REPL itself is still running, so the application can be started again quickly by evaluating <code>(def app-server-instance (-main 8888))</code>.</p> <pre><code>(ns practicalli.example-webapp\n(:gen-class)\n(:require [ring.adapter.jetty :as jetty]\n[compojure.core :refer [defroutes GET]]))\n;; Routing\n(defroutes app\n(GET \"/\" [] {:status 200 :body \"App Server Running\"}))\n;; System\n(defn app-server-start\n[port]\n(jetty/run-jetty #'app {:port port :join? false}))\n(defn -main [&amp; [port]]\n(let [port (Integer. (or port\n(System/getenv \"PORT\")\n8888))]\n(app-server-start port)))\n;; REPL driven development\n(comment\n(def app-server-instance (-main 8888))\n(.stop app-server-instance)\n)\n</code></pre> <p>The <code>-main</code> function identifies a value for a port and calls <code>app-server-start</code> function which starts the http-kit server.</p> <p><code>(def app-server-instance (-main 8888))</code> is placed within a <code>(comment )</code> expression.  This provides a manual way for the developer to start the application server.</p> <p>The <code>app-server-instance</code> reference can be used to stop the app-server by calling it with the arguments <code>:timeout 100</code> and gracefully shutting down the server, <code>(app-server-instance :timeout 100)</code>.</p> <pre><code>(ns practicalli.example-webapp\n(:gen-class)\n(:require [org.httpkit.server :as app-server]\n[compojure.core :refer [defroutes GET]]))\n;; Routing\n(defroutes app\n(GET \"/\" [] {:status 200 :body \"App Server Running\"}))\n;; System\n(defn app-server-start\n\"Start the application server and run the application\"\n[port]\n(println \"INFO: Starting server on port: \" port)\n(app-server/run-server #'app {:port port}))\n(defn -main\n\"Start the application server on a specific port\"\n[&amp; [port]]\n(let [port (Integer. (or port (System/getenv \"PORT\") 8888))]\n(app-server-start port)))\n;; REPL driven development\n(comment\n(def app-server-instance (-main 8888))\n(app-server-instance :timeout 100)\n)\n</code></pre> <p>Http-kit server documentation contains details of asynchronous websockets and HTTP streaming configurations.</p>"},{"location":"app-servers/start-server/","title":"Start a server","text":"<p>The very basics of starting an Http server with Jetty or Httpkit.</p> <p>Projects containing application servers are typically started from the command line, especially when deployed.</p> <p>During development an application server is typically managed via the REPL, either calling a  or via a component lifecycle service (mount, integrant, component)</p>"},{"location":"app-servers/start-server/#the-main-function","title":"The -main function","text":"<p>The <code>-main</code> function is used to capture optional arguments to set configuration such as port and ip address.  These values can either be passed as function arguments, operating system environment variables or default values.</p> <p>Define a <code>-main</code> function that optionally takes an argument that will be used as a port number to listen for requests.</p> <p>A value is bound to the local name <code>port</code> using either the argument to the <code>-main</code> function, an operating system environment variable or the default port number.</p> <pre><code>(defn -main\n\"Start the application server on a specific port\"\n[&amp; [port]]\n(let [port (Integer. (or port\n(System/getenv \"PORT\")\n8080))]\n(server-start port)))\n</code></pre> <p>The <code>app-server-start</code> function starts a specific application server, eg. Jetty, http-kit-server.</p>"},{"location":"app-servers/start-server/#listen-on-port","title":"Listen on Port","text":"<p>Application servers listen on a specific port for messages over HTTP/S which is set when starting the application server.  Public facing application will receive requests over port 80, although for security reasons a firewall or proxy is placed in front of the application server which redirects traffic to an internal port number for the application server.</p> <p>Cloud application platforms (Heroku, Google, AWS) provide a port number each time a new cloud environment (eg. container) is provisioned, so an application server should read in this dynamically assigned port number from the provided operating system environment variable.</p>"},{"location":"app-servers/start-server/#integer-type-port-number","title":"Integer type port number","text":"<p><code>(Integer. port-number)</code> will cast either a string or number to a JVM integer type.  <code>(Integer/parseInt port-number)</code> is also commonly used and has the same result.</p> <p>These functions are used to ensure an Integer type value is passed to the application server.  As Clojure uses Java application servers (Java app servers have decades of development) then the correct type must be passed to avoid error.</p>"},{"location":"app-servers/start-server/#get-environment-variables","title":"Get environment variables","text":"<p>A common way to get environment variables from the operating system is to use the Java method, <code>System/getenv</code>.</p> <pre><code>(System/getenv \"PORT\") returns the value of the `PORT` environment variable.  If the variable is not set, then nil is returned (TODO: check what is actually returned)\n</code></pre> <p></p> <p><code>System/getProperty</code> method will get specific values from Java <code>.properties</code> files, usually from a <code>system.properties</code> file in the root of the project.  <code>System/getProperties</code> will get all properties found in <code>.properties</code> files in the project. Settings typically found in the <code>system.properties</code> files include version of Java</p> <pre><code>java.runtime.version=11\n</code></pre> <p>The Java Tutorials: Properties</p> <p><code>(System/getenv)</code> returns a hash-map of all current environment variables.  Wrap in a <code>def</code> name to make a useful REPL tool to inspect the current environment variables available.</p> <pre><code>(comment\n;; Get all environment variables\n;; use a data inspector to view environment-variables name\n(def environment-variables\n(System/getenv))\n)\n</code></pre> <p>Use tools such as the clojure inspector or data inspector tools in Clojure aware editors (e.g. CIDER inspector)</p>"},{"location":"app-servers/start-server/#environ-library-for-environment-variables","title":"Environ library for environment variables","text":"<p>Use environment variables as Clojure keywords.</p> <p>weavejester/environ library will source environment settings from Leiningen and Boot configurations, the Operating System and Java system property files.  The library works for Clojure and ClojureScript projects.</p> <p>Include environ/environ.core library as a dependency in the Clojure project configuration</p> <p>Require the library in the web-service namespace <code>ns</code> form</p> <pre><code>(require '[environ.core :refer [env]])\n</code></pre> <p>Then call the <code>env</code> function with a property name to return the value associated with that property.</p> <pre><code>(env :port)\n</code></pre>"},{"location":"app-servers/static-content/","title":"Static Content","text":"<p>Avoid serving large or complex static content</p> <p>The most efficient and secure way of serving static content from a Clojure (or any other app) is to not server content directly.  Using a static web server such as nginx or apache httpd provides a separation of concerns.</p> <p>Nginx and Apache Httpd provide many features for serving static content and managing mime types, etc which would have little value to implement inside a Clojure web application.</p> <p>Nginx and Apache Httpd can be configured as a reverse proxy, only redirecting specific request to the Clojure application</p>"},{"location":"assets/images/social/","title":"Social Cards","text":"<p>Social Cards are visual previews of the website that are included when sending links via social media platforms.</p> <p>Material for MkDocs is configured to generate beautiful social cards automatically, using the colors, fonts and logos defined in <code>mkdocs.yml</code></p> <p>Generated images are stored in this directory.</p>"},{"location":"clojure-databases/","title":"Clojure Databases","text":"Database Description Juxt Crux Bi-temporal schema-less high performance CQRS style database Onyx Cognitect Datomic (commercial product)"},{"location":"clojure-databases/crux/","title":"Crux - bi-temporal schema-less document database","text":"<p>Crux is a general purpose database with graph-oriented bi-temporal indexes. Datalog, SQL &amp; EQL queries are supported along with Java, HTTP &amp; Clojure APIs.  The Datalog query interface that can be used to express complex joins and recursive graph traversals.</p>"},{"location":"clojure-databases/crux/#getting-started","title":"Getting Started","text":"<p>Follow the Crux Earth Assignment Tutorial, in either the self-contained Next-Journal environment or as your own Clojure project.</p> <p>{% tabs clojure=\"Clojure CLI tools\", lein=\"Leiningen\" %}</p> <p>{% content \"clojure\" %} Using the Clojure CLI tools and practicalli/clojure-deps-edn configuration, create a new project:</p> <pre><code>clojure -X:project/new :template app :name practicalli/crux-demo\n</code></pre> <p>{% content \"lein\" %} Using the Leiningen build tool, create a new project:</p> <pre><code>lein new app practicalli/crux-demo\n</code></pre> <p>{% endtabs %}</p> <p>Install Crux as a library in a Clojure project or use the pre-built docker image.</p> <p>Note: to have more than one set of tabs in a page, simply create unique id's for the tabs, e.g. practicalli2</p> <p>Experiment with the Crux-labs workshop project, which contains examples of using Crux.</p>"},{"location":"clojure-databases/crux/#resources","title":"Resources","text":"<ul> <li>Library dependency (clojars)</li> <li>Reference Documentation</li> <li>Community discussions (Zulip)</li> <li>GitHub discussions</li> </ul> <p>{% youtube %} https://www.youtube.com/watch?v=JkZfQZGLPTA</p>"},{"location":"clojure-databases/crux/#unbundled-architectural-overview","title":"Unbundled architectural overview","text":"<p>Crux follows an unbundled architectural, decoupled components communicating via an immutable log and document store. <code>crux-rocksdb</code> is the high performance default data store, with a range of storage options available for embedded usage and cloud scaling.</p> <p>Crux embraces the transaction log as the central point of coordination when running as a distributed system. Use of a separate document store enables simple eviction of active and historical data to assist with technical compliance for information privacy regulations.</p> <p>This design makes it feasible and desirable to embed Crux nodes directly within your application processes, which reduces deployment complexity and eliminates round-trip overheads when running complex application queries.</p> <p></p>"},{"location":"full-app/","title":"Building a full database backed app","text":""},{"location":"introduction/contributing/","title":"Contributing to Practicalli Clojure","text":"<p>practicalli/clojure is written in markdown and uses GitBook to generate the website via a GitHub action.</p> <p>By submitting content ideas and corrections you are agreeing they can be used in this workshop under the Creative Commons Attribution ShareAlike 4.0 International license.  Attribution will be detailed via GitHub contributors.</p> <p>All content and interaction with any persons or systems must be done so with respect and within the Practicalli Code of Conduct.</p>"},{"location":"introduction/contributing/#book-status","title":"Book status","text":""},{"location":"introduction/contributing/#submit-and-issue-or-idea","title":"Submit and issue or idea","text":"<p>If something doesnt seem quite right or something is missing from the book, please raise an issue via the GitHub repository explaining in as much detail as you can.</p>"},{"location":"introduction/contributing/#considering-a-pull-request","title":"Considering a Pull request?","text":"<p>Before investing any time in a pull request, please raise an issue explaining the situation.  This can save you and the maintainer time and avoid rejected pull requests.</p> <p>Please keep pull requests small and focused, as they are much quicker to review and easier to accept.  Ideally PR's should be for a specific page or at most a section.</p> <p>A PR with a list of changes across different sections will not be merged, it will be reviewed eventually though.</p>"},{"location":"introduction/contributing/#thank-you-to-everyone-that-has-contributed","title":"Thank you to everyone that has contributed","text":"<p>A huge thank you to Rich Hickey and the team at Cognitect for creating and continually guiding the Clojure language.  Special thank you to Alex Miller who has provided excellent advice on working with Clojure and the CLI tooling.</p> <p>The Clojure community has been highly supportive of everyone using Clojure and I'd like to thank everyone for the feedback and contributions.  I would also like to thank everyone that has joined in with the London Clojurins community, ClojureBridgeLondon, Clojurians Slack community, Clojurians Zulip community and Clojureverse community.</p> <p>Thank you to everyone who sponsors the Practicalli websites and videos and for the Clojurists Together sponsorship, it helps me continue the work at a much faster pace.</p> <p>Special thanks to Bruce Durling for getting me into Cloure in the first place.</p> <p></p>"},{"location":"introduction/overview/","title":"Overview of Clojure Web Services","text":"<p>A Web service receives data, does something with that data and returns data as a result.  This is the essence of how a function works in Clojure.  So its really simple to design web apps with Clojure.</p> <p>Clojure data is managed via immutable data structures. The majority of the Clojure code will be stateless or managing state with immutable data structures, therefore code for services will be less complex and less prone to conflicts.</p> <p>Relevant changes to data is persisted to a data store, e.g. PostgreSQL, Datomic or XTDB</p> <p>So reliable services are very easy to build and simple to scale via parallelism.</p>"},{"location":"introduction/overview/#libraries-over-frameworks","title":"Libraries over frameworks","text":"<p>Clojure takes a modular approach to building services, assembling commonly used libraries from the community.</p> <p>Java Interoperability is simple in Clojure, so its trivial to use Java libraries or any libraries that run on the JVM (Scala, Jython, etc.).</p> <p>Web services in Clojure are typically built from a collection of highly focused libraries.  Each library has a specific focus and enables a modular approach, as you can swap components &amp; libraries easily should there be value in a different approach.</p> <p>Common libraries for web app development include:</p> <ul> <li>Ring - a web application library</li> <li>Compojure - an simple way to define routes for your ring webapp</li> <li>Hiccup or Selmer- to generate HTML from Clojure data structures</li> <li>Pedestal</li> <li>jdbc.next - a modern low-level Clojure wrapper for JDBC access to databases</li> <li>clojure.java.jdbc - simple low level SQL library</li> <li>Korma, YesQL, hugSql - database abstraction layers</li> <li>Prismatic Schema - database schema mapping</li> <li>Migratus - database migrations (and all the things)</li> </ul> <p>Large frameworks constrain the design of a service, forcing development to live inside the constraints of that framework as it can be difficult to break out of the design the framework imposes.</p>"},{"location":"introduction/overview/#project-templates","title":"Project templates","text":"<p>Projects can be created from templates to avoid starting from scratch each time.</p> deps-newclj-new <p>deps-new creates Clojure CLI projects from templates and is very simple to create your own templates <pre><code>clojure -T:project/create :template app :name practicalli/gameboard\n</code></pre></p> <p>clj-new supports a very wide range of templates although has a more involved design when it comes to creating your own templates.  Maintained templates used by clj-new should support both Clojure CLI and Leiningen <pre><code>clojure -T:project/new :template luminus :name practicalli/gameboard\n</code></pre></p> Convert Leiningen project to Clojure CLI <p>Add a <code>deps.edn</code> file that contains a <code>{}</code> hash-map with a <code>:deps</code> key that is associated with a hash-map of library dependencies, the same dependencies from the project.clj configuration file updated to the Clojure CLI format, e.g. <code>{org.clojure/clojure {:mvn/version \"1.11.3\"}}</code></p> <p>There are many great templates to try that provide insight into building webapps in Clojure.</p> <ul> <li>compojure - a common web application approach with ring and compojure</li> <li>compojure-api - quickly build API's with ring, compojure and openapi (swagger) for self-documentation</li> <li>luminus - a flexible template to create server-side and full stack web applications</li> <li>pedestal-service - an opinionated, extensible &amp; scalable framework</li> <li>duct - data-oriented production-grade server-side web applications</li> <li>JUXT Edge - a curated base project to build your own applications and services</li> </ul> <p>You can find a range of project templates by searching for lein-template on Clojars.org.  There is also a guide to writing templates on Leiningen.org</p>"},{"location":"introduction/repl-workflow/","title":"REPL Driven Development","text":"<p>Always be REPL'ing</p> <p>Coding without a REPL feels limiting. The REPL provides fast feedback from code as its crafted, testing assumptions and design choices every step of the journey to a solution  - John Stevenson, Practical.li</p> <p>REPL driven development is the foundation of working with Clojure effectively</p> <p>An effective Clojure workflow begins by running a REPL process.  Clojure expressions are written and evaluated immediately to provide instant feedback as design decisions are coded.</p> <p>The REPL feedback tests the assumptions driving design choices.  Important design choices provide data which can be codified into unit tests, optionally using spec and generative testing.</p> <ul> <li>Read - code is read by the Clojure reader, passing any macros to the macro reader which converts those macros into Clojure code.</li> <li>Evaluate - code is compiled into the host language (e.g. Java bytecode) and executed</li> <li>Print - results of the code are displayed, either in the REPL or as part of the application.</li> <li>Loop - the REPL is a continuous process that evaluates code, either a single expression or the whole application.</li> </ul>"},{"location":"introduction/repl-workflow/#evaluating-source-code","title":"Evaluating source code","text":"<p>A REPL connected editor is the primary tool for evaluating Clojure code from source code files, displaying the results inline.</p> <p>Source code is automatically evaluated in its respective namespace, removing the need to change namespaces in the REPL, (<code>in-ns</code>), or use fully qualified names to call functions.</p> <p> </p> Evaluate Clojure in a Terminal UI REPL <p>Entering expressions at the REPL prompt evaluates the expression immediately, returning the result directly underneath </p>"},{"location":"introduction/repl-workflow/#rich-comment-blocks-living-documentation","title":"Rich Comment blocks - living documentation","text":"<p>The <code>(comment ,,,)</code> function wraps code that is only run directly by the developer using a Clojure aware editor.</p> <p>Expressions in rich comment blocks can represent how to use the functions that make up the namespace API.  For example, starting/restarting the system, updating the database, etc.  Expressions provide examples of calling functions with typical arguments and make a project more accessible and easier to work with.</p> <p></p> <p>Rich comment blocks are very useful for rapidly iterating over different design decisions by including the same function but with different implementations.  Hide clj-kondo linter warnings for redefined vars (<code>def</code>, <code>defn</code>) when using this approach.</p> <pre><code>;; Rich comment block with redefined vars ignored\n#_{:clj-kondo/ignore [:redefined-var]}\n(comment\n(defn value-added-tax []\n;; algorithm design - first try)\n(defn value-added-tax []\n;; algorithm design - first try)\n) ;; End of rich comment block\n</code></pre> <p>The \"Rich\" in the name is an honourary mention to Rich Hickey, the author and benevolent dictator of Clojure design.</p>"},{"location":"introduction/repl-workflow/#design-journal","title":"Design Journal","text":"<p>A journal of design decisions makes the code easier to understand and maintain.  Code examples of design decisions and alternative design discussions are captured, reducing the time spent revisiting those discussions.</p> <p>Journals simplify the developer on-boarding processes as the journey through design decisions are already documented.</p> <p>A Design Journal is usually created in a separate namespace, although it may start as a rich comment at the bottom of a namespace.</p> <p>A journal should cover the following aspects</p> <ul> <li>Relevant expressions use to test assumptions about design options.</li> <li>Examples of design choices not taken and discussions why (saves repeating the same design discussions)</li> <li>Expressions that can be evaluated to explain how a function or parts of a function work</li> </ul> <p>The design journal can be used to create meaningful documentation for the project very easily and should prevent time spent on repeating the same conversations.</p> <p>Example design journal</p> <p>Design journal for TicTacToe game using Reagent, ClojureScript and Scalable Vector Graphics</p>"},{"location":"introduction/repl-workflow/#viewing-data-structures","title":"Viewing data structures","text":"<p>Pretty print shows the structure of results from function calls in a human-friendly form, making it easier for a developer to parse and more likely to notice incorrect results.</p> <p>, e p on the Spacemacs Clojure menu has several commands to Pretty Print data structure results when evaluating code.</p> <p>, d v is the Cider Inspect menu for paging through very large data sets and navigate nested data structures in detail.</p> <p></p> <p>, d is the Cider debug menu which can inspect view intermediate values and data structures during the debugging of Clojure function calls.</p> <p>Cider inspector is an effective way to navigate nested data and page through large data sets.</p> <p>External data browsers can visualise data in many different forms.</p> <p></p>"},{"location":"introduction/repl-workflow/#code-style-and-idiomatic-clojure","title":"Code Style and idiomatic Clojure","text":"<p>Clojure aware editors should automatically apply formatting that follows the Clojure Style guide.</p> <p>Live linting with clj-kondo suggests common idioms and highlights a wide range of syntax errors as code is written, minimizing bugs and therefore speeding up the development process.</p> <p> </p> <p>Clojure Style Guide</p> <p>The Clojure Style guide provides examples of common formatting approaches, although the development team should decide which of these to adopt.  Emacs <code>clojure-mode</code> will automatically format code and so will Clojure LSP (via cljfmt).  These tools are configurable and should be tailored to the teams standard.</p>"},{"location":"introduction/repl-workflow/#test-driven-development-and-repl-driven-development","title":"Test Driven Development and REPL Driven Development","text":"<p>Test Driven Development (TDD) and REPL Driven Development (RDD) complement each other as they both encourage incremental changes and continuous feedback.</p> <p>Test Driven Development fits well with Hammock Time, as good design comes from deep thought</p> <ul> <li>RDD enables rapid design experiments so different approaches can easily and quickly be evaluated .</li> <li>TDD focuses the results of the REPL experiments into design decisions, codified as unit tests.  These tests guide the correctness of specific implementations and provide critical feedback when changes break that design.</li> </ul> <p>Unit tests should support the public API of each namespace in a project to help prevent regressions in the code.  Its far more efficient in terms of thinking time to define unit tests as the design starts to stabilize than as an after thought.</p> <p><code>clojure.test</code> library is part of the Clojure standard library that provides a simple way to start writing unit tests.</p> <p>Clojure spec can also be used for generative testing, providing far greater scope in values used when running unit tests.  Specifications can be defined for values and functions.</p> <p>Clojure has a number of test runners available.  Kaocha is a test runner that will run unit tests and function specification checks.</p> <p>Automate local test runner</p> <p>Use kaocha test runner in watch mode to run tests and specification check automatically (when changes are saved) <pre><code>clojure -X:test/watch\n</code></pre></p>"},{"location":"introduction/repl-workflow/#continuous-integration-and-deployment","title":"Continuous Integration and Deployment","text":"<p>Add a continuous integration service to run tests and builds code on every shared commit.  Spin up testable review deployments when commits pushed to a pull request branch, before pushing commits to the main deployment branch, creating an effective pipeline to gain further feedback.</p> <ul> <li>CircleCI provides a simple to use service that supports Clojure projects.</li> <li>GitHub Workflows and GitHub actions marketplace  to quickly build a tailored continuous integration service, e.g. Setup Clojure GitHub Action.</li> <li>GitLab CI</li> </ul> <p></p>"},{"location":"introduction/repl-workflow/#live-coding-with-data-stuart-halloway","title":"Live Coding with Data - Stuart Halloway","text":"<p>There are few novel features of programming languages, but each combination has different properties. The combination of dynamic, hosted, functional and extended Lisp in Clojure gives developers the tools for making effective programs. The ways in which Clojure's unique combination of features can yield a highly effective development process.</p> <p>Over more than a decade we have developed an effective approach to writing code in Clojure whose power comes from composing many of its key features. As different as Clojure programs are from e.g. Java programs, so to can and should be the development experience. You are not in Kansas anymore!</p> <p>This talk presents a demonstration of the leverage you can get when writing programs in Clojure, with examples, based on my experiences as a core developer of Clojure and Datomic.</p> <p> </p>"},{"location":"introduction/requirements/","title":"Requirements","text":"<p>Practicalli provides an install guide for Clojure and a wide selection of Clojure aware editors</p> <p>Recommended development tools for this guide are:</p> <ul> <li>Java OpenJDK version 17</li> <li>Clojure CLI and Practicalli Clojure CLI Config</li> <li>A Clojure aware editor</li> </ul> <p>Code examples can be used with any Clojure build tool, although this guide focuses on using Clojure CLI tools. Some examples use Leiningen and will be updated to Clojure CLI, although the Clojure code will be the same.</p>"},{"location":"introduction/requirements/#additional-development-tools","title":"Additional Development tools","text":"<p>To complete all the steps in this guide, especially around deployment tasks, additional development tools and services are required.</p> Development Tools Version Test (command line) Git client latest <code>git --version</code> Docker Desktop latest <code>docker --version</code> Postgres database latest <p>GitHub and GitHub actions will be predominantly used in this guide, although more use of CircleCI and GitLab will also be introduced. CircleCI is a developer focused service for Continuous Integration, developed with Clojure, providing obs that package up common workflows such as deploying to specific Cloud services.</p> Continuous Integration Services GitHub Actions GitLab CI CircleCI Heroku deployment to be deprecated <p>Heroku has been used to simplify deployment directly from source code using existing build packs.  Heroku now requires a commercial license for deployment so this content is to be deprecated.</p>"},{"location":"introduction/requirements/#persistence-alternatives","title":"Persistence Alternatives","text":"<p>Practicalli is considering other persistent storage approaches for this guide and any contributions in this regard is much appreciated</p> <ul> <li>Crux - an open source document database with bitemporal graph queries</li> <li>Datomic - a commercial transactional database with a flexible data model, elastic scaling, and rich queries.</li> <li>Amazon Aurora - MySQL and PostgreSQL compatible cloud native relational database</li> <li>Amazon DynamoDB with Clojure Faraday library - for persisting JSON like data structures</li> </ul>"},{"location":"introduction/requirements/#leiningen-approach-to-be-archived","title":"Leiningen approach (to be archived)","text":"<p>Install Leiningen for the Leiningen Todo App project and test the Leiningen install by running the command <code>lein version</code> in a terminal application.</p>"},{"location":"introduction/writing-tips/","title":"Writing tips for MkDocs","text":"<p>Making the docs more engaging using the mkdocs-material theme reference guide</p> Configuring Colors <p>Material for MkDocs - Changing the colors lists the primary and accent colors available.</p> <p>HSL Color Picker for codes to modify the theme style, overriding colors in <code>docs/assets/stylesheets/extra.css</code></p>"},{"location":"introduction/writing-tips/#hypertext-links","title":"Hypertext links","text":"<p>Links open in the same browser window/tab by default.</p> <p>Add <code>{target=_blank}</code> to the end of a link to configure opening in a new tab</p> <pre><code>[link text](url){target=_blank}\n</code></pre>"},{"location":"introduction/writing-tips/#buttons","title":"Buttons","text":"<p>Convert any link into a button by adding <code>{ .md-button }</code> class names to end of the markdown for a link, which uses <code>.md-button-primary</code> by default.  Include <code>target=_blank</code> for buttons with links to external sites.</p> <pre><code>[link text](http://practical.li/blog){ .md-button target=_blank }\n</code></pre> <p>Or specify a different class</p> <pre><code>[link text](http://practical.li/blog){ .md-button .md-button-primary }\n</code></pre> <p>Add an icon to the button </p> <p> Practicalli Issues  Practicalli Blog</p> <pre><code>[:fontawesome-brands-github: Practicalli Issues](http://practical.li/blog){ .md-button .md-button-primary }\n[:octicons-heart-fill-24: Practicalli Blog](http://practical.li/blog){ .md-button .md-button-primary }\n</code></pre>"},{"location":"introduction/writing-tips/#youtube-video","title":"YouTube video","text":"<p>Use an iframe element to include a YouTube video, wrapping in a paragraph tag with center alignment to place the video in a centered horizontal position</p> <pre><code>&lt;p style=\"text-align:center\"&gt;\n&lt;iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/rQ802kSaip4\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen&gt;&lt;/iframe&gt;\n&lt;/p&gt;\n</code></pre> <p>mkdocs material does not have direct support for adding a YouTube video via markdown.</p>"},{"location":"introduction/writing-tips/#admonitions","title":"Admonitions","text":"<p>Supported admonition types</p> <p>Note</p> <p>Use <code>!!!</code> followed by <code>NOTE</code></p> <p>Adding a title</p> <p>Use <code>!!!</code> followed by <code>NOTE</code> and a <code>\"title in double quotes\"</code></p> <p>Shh, no title bar just the text... Use <code>!!!</code> followed by <code>NOTE</code> and a <code>\"\"</code> empty double quotes</p> <p>Abstract</p> <p>Use <code>!!!</code> followed by <code>ABSTRACT</code></p> <p>Info</p> <p>Use <code>!!!</code> followed by <code>INFO</code></p> <p>Tip</p> <p>Use <code>!!!</code> followed by <code>TIP</code></p> <p>Success</p> <p>Use <code>!!!</code> followed by <code>SUCCESS</code></p> <p>Question</p> <p>Use <code>!!!</code> followed by <code>QUESTION</code></p> <p>Warning</p> <p>Use <code>!!!</code> followed by <code>WARNING</code></p> <p>Failure</p> <p>Use <code>!!!</code> followed by <code>FAILURE</code></p> <p>Danger</p> <p>Use <code>!!!</code> followed by <code>DANGER</code></p> <p>Bug</p> <p>Use <code>!!!</code> followed by <code>BUG</code></p> <p>Example</p> <p>Use <code>!!!</code> followed by <code>EXAMPLE</code></p> <p>Quote</p> <p>Use <code>!!!</code> followed by <code>QUOTE</code></p>"},{"location":"introduction/writing-tips/#collapsing-admonitions","title":"Collapsing admonitions","text":"Note <p>Collapse those admonitions using <code>???</code> instead of <code>!!!</code></p> Replace with a title <p>Use <code>???</code> followed by <code>NOTE</code> and a <code>\"title in double quotes\"</code></p> Expanded by default <p>Use <code>???+</code>, note the <code>+</code> character,  followed by <code>NOTE</code> and a <code>\"title in double quotes\"</code></p>"},{"location":"introduction/writing-tips/#inline-blocks","title":"Inline blocks","text":"<p>Inline blocks of text to make a very specific callout within text</p> <p>Info</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.</p> <p>Adding something to then end of text is probably my favourite</p> <p>Info</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.</p>"},{"location":"introduction/writing-tips/#code-blocks","title":"Code blocks","text":"<p>Code blocks include a copy icon automatically</p> <p>Syntax highlighting in code blocks</p> <pre><code>(defn my-function  ; Write a simple function\n\"With a lovely doc-string\"\n[arguments]\n(map inc [1 2 3]))\n</code></pre> <p>Give the code block a title using <code>title=\"\"</code> after the backtics and language name</p> src/practicalli/gameboard.clj<pre><code>(defn my-function\n\"With a lovely doc-string\"\n[arguments]\n(map inc [1 2 3]))\n</code></pre> <p>We all like line numbers, especially when you can set the starting line</p> src/practicalli/gameboard.clj<pre><code>(defn my-function\n\"With a lovely doc-string\"\n[arguments]\n(map inc [1 2 3]))\n</code></pre> <p>Add <code>linenums=42</code> to start line numbers from 42 onward</p> <pre><code>clojure linenums=\"42\" title=\"src/practicalli/gameboard.clj\"\n</code></pre>"},{"location":"introduction/writing-tips/#annotations","title":"Annotations","text":"<p>Add an annotation using <code># (1)</code> where 1 is the number of the annotation</p> <pre><code>ls -la $HOME/Downloads  # (1)\n</code></pre> <ol> <li> I'm a code annotation! I can contain <code>code</code>, formatted text, images, ... basically anything that can be written in Markdown.</li> </ol> <p>Code blocks with annotation, add <code>!</code> after the annotation number to suppress the <code>#</code> character</p> <p><pre><code>(defn helper-function\n\"Doc-string with description of function purpose\" ; (1)!\n[data]\n(merge {:fish 1} data)\n)\n</code></pre> 1.  Always include a doc-string in every function to describe the purpose of that function, identifying why it was added and what its value is.</p> <p>GitHub action example with multiple annotations</p> <pre><code>name: ci # (1)!\non:\npush:\nbranches:\n- master # (2)!\n- main\npermissions:\ncontents: write\njobs:\ndeploy:\nruns-on: ubuntu-latest\nsteps:\n- uses: actions/checkout@v3\n- uses: actions/setup-python@v4\nwith:\npython-version: 3.x\n- run: pip install mkdocs-material # (3)!\n- run: mkdocs gh-deploy --force\n</code></pre> <ol> <li> <p>You can change the name to your liking.</p> </li> <li> <p>At some point, GitHub renamed <code>master</code> to <code>main</code>. If your default branch     is named <code>master</code>, you can safely remove <code>main</code>, vice versa.</p> </li> <li> <p>This is the place to install further [MkDocs plugins] or Markdown     extensions with <code>pip</code> to be used during the build:</p> <pre><code>pip install \\\nmkdocs-material \\\nmkdocs-awesome-pages-plugin \\\n...\n</code></pre> </li> </ol>"},{"location":"introduction/writing-tips/#highlight-lines-in-code-blocks","title":"Highlight lines in code blocks","text":"<p><code>hl_lines=\"2\"</code> where 2 is the line number to highlight</p> <pre><code>(defn my-function\n\"With a lovely doc-string\"\n[arguments]\n(map inc [1 2 3]))\n</code></pre>"},{"location":"introduction/writing-tips/#content-tabs","title":"Content tabs","text":"<p>Create in page tabs that can also be</p> <p>Setting up a project</p> Clojure CLILeiningen <pre><code>clojure -T:project/new :template app :name practicalli/gameboard\n</code></pre> <pre><code>lein new app practicalli/gameboard\n</code></pre> <p>Or nest the content tabs in an admonition</p> <p>Run a terminal REPL</p> Clojure CLILeiningen <pre><code>clojure -T:repl/rebel\n</code></pre> <pre><code>lein repl\n</code></pre>"},{"location":"introduction/writing-tips/#diagrams","title":"Diagrams","text":"<p>Neat flow diagrams</p> <pre><code>graph LR\n  A[Start] --&gt; B{Error?};\n  B --&gt;|Yes| C[Hmm...];\n  C --&gt; D[Debug];\n  D --&gt; B;\n  B ----&gt;|No| E[Yay!];</code></pre> <p>UML Sequence Diagrams</p> <pre><code>sequenceDiagram\n  Alice-&gt;&gt;John: Hello John, how are you?\n  loop Healthcheck\n      John-&gt;&gt;John: Fight against hypochondria\n  end\n  Note right of John: Rational thoughts!\n  John--&gt;&gt;Alice: Great!\n  John-&gt;&gt;Bob: How about you?\n  Bob--&gt;&gt;John: Jolly good!</code></pre> <p>state transition diagrams</p> <pre><code>stateDiagram-v2\n  state fork_state &lt;&lt;fork&gt;&gt;\n    [*] --&gt; fork_state\n    fork_state --&gt; State2\n    fork_state --&gt; State3\n\n    state join_state &lt;&lt;join&gt;&gt;\n    State2 --&gt; join_state\n    State3 --&gt; join_state\n    join_state --&gt; State4\n    State4 --&gt; [*]</code></pre> <p>Class diagrams - but dont need them.</p> <p>Entity relationship diagrams are handy though</p> <pre><code>erDiagram\n  CUSTOMER ||--o{ ORDER : places\n  ORDER ||--|{ LINE-ITEM : contains\n  CUSTOMER }|..|{ DELIVERY-ADDRESS : uses</code></pre>"},{"location":"introduction/writing-tips/#other-diagram-types","title":"Other diagram types","text":"<p>Besides the diagram types listed above, [Mermaid.js] provides support for pie charts, gantt charts, user journeys, git graphs and requirement diagrams, all of which are not officially supported by Material for MkDocs. Those diagrams should still work as advertised by [Mermaid.js], but we don't consider them a good choice, mostly as they don't work well on mobile.</p>"},{"location":"introduction/writing-tips/#keyboard-keys","title":"Keyboard keys","text":"<p>Represent key bindings with Keyboard keys. Each number and alphabet character has their own key.</p> <ul> <li>1 <code>++1++</code> for numbers</li> <li>l <code>++\"l\"++</code> for lowercase character</li> <li>U <code>++u++</code> for uppercase character or <code>++\"U\"++</code> for consistency </li> </ul> <p>Punctionation keys use their name * Space <code>++spc++</code>  * , <code>++comma++</code>  * Left</p> <p>For key sequences, place a space between each keyboard character  * Space g s <code>++spc++ ++\"g\"++ ++\"s\"++</code></p> <p>For key combinations, use join they key identifies with a <code>+</code> * Meta+X <code>++meta+x++</code> * Ctrl+Alt+Del <code>++ctrl+alt+del++</code></p> <p>Keyboard keys reference</p>"},{"location":"introduction/writing-tips/#grids","title":"Grids","text":"<p>Useful for putting button links on the main page as quick links into the key parts of the book</p> <ul> <li> HTML for content and structure</li> <li> JavaScript for interactivity</li> <li> CSS for text running out of boxes</li> <li> Internet Explorer ... huh?</li> </ul> <p>Sponsor only feature</p>"},{"location":"introduction/writing-tips/#images","title":"Images","text":"<p>Markdown images can be appended with material tags to set the size of the image, whether to appear on light or dark theme and support lazy image loading in browsers</p> SizeLazy LoadingAlignTheme SpecificAll Image Attributes <p><code>{style=\"height:150px;width:150px\"}</code> specifies the image size  <pre><code>![Kitty Logo](https://raw.githubusercontent.com/practicalli/graphic-design/live/icons/kitty-light.png#only-dark){style=\"height:150px;width:150px\"}\n</code></pre></p> <p></p> <p><code>{loading=lazy}</code> specifies an image should lazily load in the browser  <pre><code>![Kitty Logo](https://raw.githubusercontent.com/practicalli/graphic-design/live/icons/kitty-light.png){loading=lazy}\n</code></pre></p> <p><code>{aligh=left}</code> or <code>{aligh=right}</code> specifies the page alignment of an image. <pre><code>![Kitty Logo](https://raw.githubusercontent.com/practicalli/graphic-design/live/icons/kitty-light.png#only-dark){align=right}\n![Kitty Logo](https://raw.githubusercontent.com/practicalli/graphic-design/live/icons/kitty-dark.png#only-light){align=right}\n</code></pre></p> <p>  Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.</p> <p><code>![Kitty Logo](image/kitty-light.png#only-dark)</code> or <code>![Kitty Logo](image/kitty-light.png#only-light)</code>  specifies the theme the image should be shown, allowing different versions of images to be shown based on the theme. <pre><code>![Kitty Logo](https://raw.githubusercontent.com/practicalli/graphic-design/live/icons/kitty-light.png#only-dark){style=\"height:150px;width:150px\"}\n![Kitty Logo](https://raw.githubusercontent.com/practicalli/graphic-design/live/icons/kitty-dark.png#only-light){style=\"height:150px;width:150px\"}\n</code></pre> Use the theme toggle in the top nav bar to see the icon change between light and dark.  </p> <p>Requires the color pallet toggle</p> <p>Alight right, lazy load and set image to 150x150</p> <pre><code>![Kitty Logo](https://raw.githubusercontent.com/practicalli/graphic-design/live/icons/kitty-light.png#only-dark){align=right loading=lazy style=\"height:64px;width:64px\"}\n![Kitty Logo](https://raw.githubusercontent.com/practicalli/graphic-design/live/icons/kitty-dark.png#only-light){align=right loading=lazy style=\"height:64px;width:64px\"}\n</code></pre> <p>  Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.</p>"},{"location":"introduction/writing-tips/#lists","title":"Lists","text":"<p>Task lists</p> <ul> <li> Lorem ipsum dolor sit amet, consectetur adipiscing elit</li> <li> Vestibulum convallis sit amet nisi a tincidunt<ul> <li> In hac habitasse platea dictumst</li> <li> In scelerisque nibh non dolor mollis congue sed et metus</li> <li> Praesent sed risus massa</li> </ul> </li> <li> Aenean pretium efficitur erat, donec pharetra, ligula non scelerisque</li> </ul>"},{"location":"introduction/writing-tips/#tooltips","title":"Tooltips","text":"<p>The humble tool tip</p> <p>Hover me</p> <p>with references</p> <p>Hover me</p> <p>Icon tool tip with a title</p> <p></p>"},{"location":"introduction/writing-tips/#abreviations","title":"Abreviations","text":"<p>The HTML specification is maintained by the W3C.</p> <p>[HTML]: Hyper Text Markup Language [W3C]: World Wide Web Consortium</p>"},{"location":"introduction/writing-tips/#magic-links","title":"Magic links","text":"<p>MagicLink can auto-link HTML, FTP, and email links. It can auto-convert repository links (GitHub, GitLab, and Bitbucket) and display them in a more concise, shorthand format.</p> <p>Email Practicalli</p> <p>Practicalli Neovim</p>"},{"location":"libraries/reitit/","title":"Reitit - fast data driven routing for Clojure and ClojureScript","text":""},{"location":"libraries/reitit/constructing-routes/","title":"Reitit: Constructing routes","text":"<p>Create a simple Clojure project</p> <pre><code>clojure -T:project/new :template app :name practicalli/reitit-routing\n</code></pre> <p>Require reitit</p> <pre><code>(require '[reitit.core :as reitit])\n</code></pre> <p>Define several simple routes using reitit router</p> <p>Routes are defined as a collection (vector) of vectors, with each vector defining the path of the route and an optional name.</p> <p><code>reitit.core/router</code> creates a router from the collection of vectors and an optional hash-map of routes configuration options (e.g middleware)</p> <pre><code>(def router\n(reitit/router\n[[\"/api/ping\" ::ping]\n[\"/api/game-scoreboard/:score-id\" ::game-score]]))\n</code></pre> <p>names are used to provide a unique way of referring to a route throughout the whole project, as they are a namespace qualified keyword</p> <p>Selects implementation based on route details. The following options are available:</p> Key description <code>:path</code> Base-path for routes <code>:routes</code> Initial resolved routes (default []) <code>:data</code> Initial route data (default {}) <code>:spec</code> clojure.spec definition for a route data, see reitit.spec on how to use this <code>:syntax</code> Path-parameter syntax as keyword or set of keywords (default #{:bracket :colon}) <code>:expand</code> Function of arg opts =&gt; data to expand route arg to route data (default reitit.core/expand) <code>:coerce</code> Function of route opts =&gt; route to coerce resolved route, can throw or return nil <code>:compile</code> Function of route opts =&gt; result to compile a route handler <code>:validate</code> Function of routes opts =&gt; () to validate route (data) via side-effects <code>:conflicts</code> Function of {route #{route}} =&gt; () to handle conflicting routes <code>:exception</code> Function of Exception =&gt; Exception  to handle creation time exceptions (default reitit.exception/exception) <code>:router</code> Function of routes opts =&gt; router to override the actual router implementation <p>Routes can be found by either path or name</p>"},{"location":"micro-framework/","title":"Micro-frameworks","text":"<p>Introducing common micro-frameworks (curated libraries and configuration) as a basis for your own projects.</p> <ul> <li>Luminus</li> <li>Pedestal</li> <li>JUXT Edge</li> </ul>"},{"location":"micro-framework/#todowork-in-progress-sorry","title":"TODO::work in progress, sorry","text":"<p>Pull requests are welcome</p>"},{"location":"micro-framework/edge/","title":"JUXT Edge","text":"<p>JUXT Edge is a foundation for Clojure projects, using leading edge libraries and with upgrade path as the Edge project evolves.</p> <p>Projects are created with Clojure CLI and tools.deps</p>"},{"location":"micro-framework/edge/#todowork-in-progress-sorry","title":"TODO::work in progress, sorry","text":"<p>Pull requests are welcome</p>"},{"location":"micro-framework/luminus/","title":"Luminus","text":"<p>Luminus is a clojure micro-framework based on a set of lightweight libraries.  It ams to provide a robust and configurable template to generate web services and applications.</p> <p>Luminus also supports ClojureScript for browser based and Mobile UI's.</p>"},{"location":"micro-framework/luminus/#todowork-in-progress-sorry","title":"TODO::work in progress, sorry","text":"<p>Pull requests are welcome</p>"},{"location":"micro-framework/luminus/#hintluminus-uses-leiningen","title":"Hint::Luminus uses Leiningen","text":"<p>TODO: review how easy it would be to convert this to a tools.deps project.</p>"},{"location":"micro-framework/pedestal/","title":"Pedestal","text":""},{"location":"micro-framework/pedestal/#todowork-in-progress-sorry","title":"TODO::work in progress, sorry","text":"<p>Pull requests are welcome</p>"},{"location":"project-url-shortner/","title":"Project: URL Shortner as a Service","text":"<p>In this section we will build a webservice to create short url's for web addresses, as with services such as bit.ly.</p> <p></p> <p>The web service will also manage the redirection of your browser from the short url to the real web address.</p> <p>This project will take the simplest approach and is therefore not attempting to build a production ready service.</p>"},{"location":"project-url-shortner/add-alias-to-database/","title":"add alias to database","text":""},{"location":"project-url-shortner/add-static-resources/","title":"Add static resources","text":""},{"location":"project-url-shortner/alias-generator/","title":"Alias generator","text":""},{"location":"project-url-shortner/compojure-template/","title":"Compojure Template","text":""},{"location":"project-url-shortner/compojure-template/#compojure-api","title":"Compojure API","text":"<p>https://weavejester.github.io/compojure/index.html</p>"},{"location":"project-url-shortner/create-database/","title":"create database","text":""},{"location":"project-url-shortner/create-html-form/","title":"Create HTML Form","text":""},{"location":"project-url-shortner/create-project/","title":"Create project","text":"<p>To create a web service we can use two commonly used libraries in Clojure, ring and compojure.</p> <p>Ring provides many low-level functions to manage web requests and responses as well as providing an embedded web server (ie. Jetty).  Most importantly it abstracts away all the complicated details of HTTP communication. So as a developer of the web app you mostly focus on processing a request map and returning a response map.</p> <p>Compojure provides a simple way to define routes for your application, eg what function is called when a browser requests a specific url.</p> <pre><code>lein new compojure shorturl-service\n\ncd shorturl-service\n</code></pre> <p>Open the <code>project.clj</code> file in an editor and take a look at the dependencies added to the project.</p> <pre><code>(defproject shorturl-service \"0.1.0-SNAPSHOT\"\n:description \"FIXME: write description\"\n:url \"http://example.com/FIXME\"\n:min-lein-version \"2.0.0\"\n:dependencies [[org.clojure/clojure \"1.8.0\"]\n[compojure \"1.5.1\"]\n[ring/ring-defaults \"0.2.1\"]]\n:plugins [[lein-ring \"0.9.7\"]]\n:ring {:handler shorturl-service.handler/app}\n:profiles\n{:dev {:dependencies [[javax.servlet/servlet-api \"2.5\"]\n[ring/ring-mock \"0.3.0\"]]}})\n</code></pre> <p>Apart from Clojure itself, the compojure and ring libraries have been added.</p> <p>The <code>:plugins</code> section adds <code>lein-ring</code> which allows us to run the server using the command <code>lein ring server</code></p> <p>The <code>:ring</code> section defines the default function to call when running the project</p> <p>The <code>:profiles</code> section adds libraries useful for development and testing.</p>"},{"location":"project-url-shortner/create-project/#note-create-a-new-project-using-leiningen-and-the-compojure-template-then-go-into-the-project-created","title":"Note:: Create a new project using Leiningen and the compojure template, then go into the project created.","text":""},{"location":"project-url-shortner/delete-alias-from-database/","title":"delete alias from database","text":""},{"location":"project-url-shortner/design-data-structure/","title":"Design data structure","text":"<p>One of the first decisions is how to design the data structure to hold our short url and full url addresses.</p>"},{"location":"project-url-shortner/design-data-structure/#the-simplest-approach","title":"The simplest approach","text":"<p>We could create a really simple data structure with a vector</p> <pre><code>[\"goouk\" \"https://duckduckgo.com/\"]\n</code></pre> <p>In order to hold multiple short url mappings, we could have a vector of vectors</p> <p><pre><code>[[\"duckduckgo\" \"https://duckduckgo.com/\"]\n[\"practicalli\" \"https://practical.li\"]\n[\"slashdot\" \"https://slashdot.com\"]]\n</code></pre> Although the above is nice and simple, it does not provide any context for the data.</p>"},{"location":"project-url-shortner/design-data-structure/#using-a-map-for-context","title":"Using a map for context","text":"<p>The keys in a map can add specific meaning and context to the design of the data structure.</p> <p>Here are two examples, the first with keys as strings the second as keys as keywords.</p> <pre><code>{\"short-url\" \"practicalli\" \"full-url\" \"http://practical.li\"}\n{:short-url \"practicalli\" :full-url \"http://practical.li\"}\n</code></pre> <p>As keys need to be unique, then if we have multiple short url mappings to contain, then we need another data structure for each map.</p> <pre><code>[{:short-url \"practicalli\" :full-url \"http://practical.li\"}\n{:short-url \"slashdot\" :full-url \"https://slashdot.org\"}]\n</code></pre> <p>In the above design we cannot use a single map as all the keys in a map need to be unique</p>"},{"location":"project-url-shortner/design-data-structure/#simplifying-the-map","title":"Simplifying the map","text":"<p>As keys must be unique in a map, we cannot have multiple keys called <code>:short-url</code>, therefore using that design we cant have a single map.</p> <p>We could simplify the map and remove the current keys and use the value for the short-url as the key and the full url as the value.  This means we could just have a single map for all our short-url mappings.</p> <pre><code>{\"practicalli\" \"http://practical.li\"\n\"slashdot\"    \"https://slashdot.org\"\n\"duckduckgo\"  \"https://duckduckgo.com/\"}\n</code></pre> <p>Using Clojure keywords for the keys would also allow us to look up the full url addresses using the feature of maps that make keywords act like functions.  This feature of the keyword in a map is just like calling the <code>get</code> function on the map with a specific key.</p> <pre><code>(def url-map\n{:practicalli \"http://practical.li\"\n:slashdot \"https://slashdot.org\"\n:duck-duck-go \"https://duckduckgo.com/\"})\n(get url-map :practicalli)\n;; =&gt; \"http://practicalli.co.uk\"\n(url-map :practicalli)\n;; =&gt; \"http://practicalli.co.uk\"\n(:practicalli url-map )\n;; =&gt; \"http://practicalli.co.uk\"\n</code></pre>"},{"location":"project-url-shortner/disable-anti-forgery-check/","title":"Disable anti-forgery check","text":"<p>The ring-defaults library provides sensible Ring middleware defaults, especially in terms of security.  The ring-defaults library is included in the</p> <p>Anyone can send a GET request to a ring webapp, however with ring-defaults included then only pages / URLs from the webapp itself are allowed to POST.</p> <p>Ring uses an anti-forgery token that needs to be setup in the project, otherwise you get the dreaded \"Invalid Anti-forgery token\" error message.</p> <p>To keep things simple we are going to turn off the anti-forgery settings provided by Ring-Defaults so we can make our POST without the CSRF protection.</p> <pre><code>(def app\n(wrap-defaults\napp-routes\n(assoc-in site-defaults [:security :anti-forgery] false)))\n</code></pre>"},{"location":"project-url-shortner/disable-anti-forgery-check/#note-edit-the-definition-of-app-in-srcshorturl-servicehandlerclj-and-replace-site-defaults-with-a-function-to-set-anti-forgery-to-false-in-site-defaults","title":"Note:: Edit the definition of <code>app</code> in <code>src/shorturl-service/handler.clj</code> and replace <code>site-defaults</code> with a function to set <code>:anti-forgery</code> to false in <code>site-defaults</code>.","text":""},{"location":"project-url-shortner/disable-anti-forgery-check/#ring-middleware-defaults","title":"Ring middleware defaults","text":"<p>There are a number of ring middleware defaults that define some common middleware functions for your app.</p> <p>For example, here is the <code>site-defaults</code> definition</p> <pre><code>(def site-defaults\n\"A default configuration for a browser-accessible website, based on current\n  best practice.\"\n{:params    {:urlencoded true\n:multipart  true\n:nested     true\n:keywordize true}\n:cookies   true\n:session   {:flash true\n:cookie-attrs {:http-only true}}\n:security  {:anti-forgery   true\n:xss-protection {:enable? true, :mode :block}\n:frame-options  :sameorigin\n:content-type-options :nosniff}\n:static    {:resources \"public\"}\n:responses {:not-modified-responses true\n:absolute-redirects     true\n:content-types          true\n:default-charset        \"utf-8\"}})\n</code></pre>"},{"location":"project-url-shortner/disable-anti-forgery-check/#a-rough-guide-to-security-middleware-from-ring","title":"A rough guide to security middleware from ring","text":"<ul> <li>:anti-forgery - Set to true to add CSRF protection via the ring-anti-forgery library.</li> <li>:content-type-options - Prevents attacks based around media-type confusion. See: wrap-content-type-options.</li> <li>:frame-options - Prevents your site from being placed in frames or iframes. See: wrap-frame-options.</li> <li>:hsts - If true, enable HTTP Strict Transport Security. See: wrap-hsts.</li> <li>:ssl-redirect - If true, redirect all HTTP requests to the equivalent HTTPS URL. A map with an :ssl-port option may be set instead, if the HTTPS server is on a non-standard port. See: wrap-ssl-redirect.</li> <li>:xss-protection - Enable the X-XSS-Protection header that tells supporting browsers to use heuristics to detect XSS attacks. See: wrap-xss-protection.</li> </ul> <p>See more details of ring middleware defaults</p>"},{"location":"project-url-shortner/disable-anti-forgery-check/#adding-other-functions-as-middleware","title":"Adding other functions as middleware","text":"<p>ring just uses function composition for middleware you can simply wrap your own function calls around the call to wrap defaults, so long as those functions deal with request/response maps appropriately.</p> <pre><code>(def app\n(my-additional-middleware\n(wrap-defaults app-routes site-defaults)\narguments to my additional middleware))\n</code></pre> <p>Or use the threading macro</p> <pre><code>(def app\n(-&gt; (wrap-defaults app-routes site-defaults)\n(friend-stuff arg arg)\n(other-middleware arg arg arg))\n</code></pre>"},{"location":"project-url-shortner/get-alias-from-database/","title":"get alias from database","text":""},{"location":"project-url-shortner/html-form/","title":"HTML Form","text":""},{"location":"project-url-shortner/if-let-function/","title":"if-let function","text":""},{"location":"project-url-shortner/named-alias-handler/","title":"Named alias handler","text":""},{"location":"project-url-shortner/persist-aliases/","title":"Persist aliases","text":""},{"location":"project-url-shortner/postgres-setup/","title":"Postgres setup","text":""},{"location":"project-url-shortner/redirect-to-full-url/","title":"Redirect short URL to full web address","text":"<p>Adding a redirect is very easy to do with ring, as the ring library provides a function called <code>redirect</code> that takes a url as an argument</p> <pre><code>(ns shorturl-service.handler\n(:require [compojure.core :refer :all]\n[compojure.route :as route]\n[ring.middleware.defaults :refer [wrap-defaults site-defaults]]\n[ring.handler.dump :refer [handle-dump]]\n[ring.util.response :refer [redirect]]))\n</code></pre>"},{"location":"project-url-shortner/redirect-to-full-url/#note-include-the-ringutilresponseredirect-function-into-the-shorturl-servicehandler-namespace-so-that-we-can-simply-call-the-redirect-function","title":"Note:: Include the <code>ring.util.response/redirect</code> function into the <code>shorturl-service.handler</code> namespace so that we can simply call the <code>redirect</code> function","text":""},{"location":"project-url-shortner/redis-setup/","title":"Redis setup","text":""},{"location":"project-url-shortner/refacor-hiccup-form/","title":"Refactor: Hiccup form","text":""},{"location":"project-url-shortner/return-short-url/","title":"Return short URL","text":""},{"location":"project-url-shortner/return-url-aliases/","title":"Return URL aliases","text":""},{"location":"project-url-shortner/run-project/","title":"Run project","text":"<p>The compojure template provides a working webserver and simple webapp out of the box.</p> <pre><code>lein ring server\n</code></pre> <p>If you have not used Compojure or Ring previously, then it may take a few seconds to download their libraries from the Internet before starting the Jetty web server.</p> <p>You should see a output after the leiningen command showing you that the server has started</p> <pre><code>2016-07-15 13:44:02.242:INFO:oejs.Server:jetty-7.6.13.v20130916\n2016-07-15 13:44:02.313:INFO:oejs.AbstractConnector:Started SelectChannelConnector@0.0.0.0:3000\nStarted server on port 3000\n</code></pre> <p>Your default browser should also open at http://localhost:3000 with a message saying \"Hello World\".  If your browser does not open then check for errors in the terminal where you ran the leiningen command.</p>"},{"location":"project-url-shortner/run-project/#note-run-the-project-to-start-the-server-and-webapp","title":"Note:: Run the project to start the server and webapp","text":""},{"location":"project-url-shortner/test-app-reloading/","title":"Test app reloading","text":"<p>The compojure template added several middleware functions to our project to make the webapp easier to work with.  The <code>wrap-reload</code> middleware picks up changes to our code and will automatically load them into our running webapp.  This provides rapid feedback on your coding.</p> <pre><code>(defroutes app-routes\n(GET \"/\" [] \"Hello reloaded World\")\n(route/not-found \"Not Found\"))\n</code></pre> <p>Now, refresh your browser and see the changes made.</p>"},{"location":"project-url-shortner/test-app-reloading/#note-make-a-simple-change-to-the-app-routes-function-in-srcshorturl-servicehandlerclj-file-eg-change-the-hello-world-string-to-hello-reloaded-world","title":"Note:: Make a simple change to the <code>app-routes</code> function in <code>src/shorturl-service/handler.clj</code> file, eg. change the \"Hello World\" string to \"Hello reloaded World\"","text":""},{"location":"project-url-shortner/test-app-reloading/#hint-you-should-only-need-to-restart-the-server-again-if-you-add-libraries-or-define-code-outside-of-the-scope-of-the-app-or-if-your-code-crashes-the-server-but-i-am-sure-that-wont-happen","title":"Hint:: You should only need to restart the server again if you add libraries or define code outside of the scope of the <code>app</code>.  Or if your code crashes the server, but I am sure that wont happen :)","text":""},{"location":"project-url-shortner/using-ring-redirect/","title":"Using Ring Redirect","text":""},{"location":"project-url-shortner/whats-in-a-request/","title":"What is in a Request","text":"<p>The ring library converts the HTTP request into a clojure map, making it really easy to extract some or all of the values out of the request map.</p>"},{"location":"project-url-shortner/whats-in-a-request/#ring-parameters","title":"ring parameters","text":"<p>The wrap-params middleware function adds support for url-encoded parameters.</p> <p>URL-encoded parameters are the primary way browsers pass values to web applications. These parameters are sent when a user submits a form.</p> <p>When applied to a handler, the parameter middleware adds three new keys to the request map:</p> <ul> <li>:query-params - A map of parameters from the query string</li> <li>:form-params - A map of parameters from submitted form data</li> <li>:params - A merged map of all parameters</li> </ul>"},{"location":"project-url-shortner/whats-in-a-request/#viewing-ring-parameters","title":"viewing ring parameters","text":"<p>You could write a function to simply display all the parameters as the body of the response.  However Ring already provides a function to do this called <code>handle-dump</code></p> <p>To use the <code>handle-dump</code> function, first include the function in the namespace using <code>(:require [ring.handler.dump :refer [handle-dump]])</code></p> <pre><code>(ns shorturl-service.handler\n(:require [compojure.core :refer :all]\n[compojure.route :as route]\n[ring.middleware.defaults :refer [wrap-defaults site-defaults]]\n[ring.handler.dump :refer [handle-dump]]))\n</code></pre> <p>As we have multiple <code>:require</code> statements we can simply chain them all together as above.</p>"},{"location":"project-url-shortner/whats-in-a-request/#note-add-the-ringhandlerdumphandle-dump-function-into-the-shorturl-servicehandler-namespace-along-with-other-require-statements","title":"Note:: Add the <code>ring.handler.dump/handle-dump</code> function into the <code>shorturl-service.handler</code> namespace along with other require statements","text":""},{"location":"projects/","title":"Project Guides","text":"<p>Follow a step-by-step project guide and build a live services which can also be deployed.</p>"},{"location":"projects/banking-on-clojure/","title":"Banking on Clojure web application","text":"<p>Work In Progress</p> <p>Project actively being developed as part of the Practicalli Study group WebApps.</p> <p>Code so far is shared on practicalli/banking-on-clojure-webapp GitHub repository</p> <p>Building a Banking application using Clojure, spec, H2 (development) &amp; Postgresql (live) databases and next.jdbc for SQL queries (migratus for db migrations).</p> <p>The system infrastructure uses Jetty or HTTP-kit (making this switchable at runtime) and a component life cycle system (probably mount).</p>"},{"location":"projects/banking-on-clojure/#application-design-in-progress","title":"Application Design (in progress)","text":"<p>Data Specifications created using <code>clojure.spec.alpha</code></p> <ul> <li> Customer Details</li> <li> Account holder</li> <li>Bank account</li> <li>Multiple Bank accounts</li> <li>Credit Card</li> <li>Mortgate</li> </ul> <p>Functions and function specifications using <code>clojure.spec.alpha</code></p> <ul> <li> register-account-holder</li> <li>open-credit-account</li> <li>open-savings-account</li> <li>open-credit-card-account</li> <li>open-mortgage-account</li> <li>Make a payment</li> <li>Send account notification</li> <li>Check for overdraft</li> </ul> <p>Functions with specifications are instrumented to check arguments passed during function calls.</p> <p>Generative testing is carried out via the kaocha test runner</p>"},{"location":"projects/banking-on-clojure/#development-workflow","title":"Development Workflow","text":"<ul> <li> Write a failing test</li> <li> write mock data</li> <li> write an function definition that returns the argument</li> <li> run tests - tests should fail</li> <li> write a spec for the functions argument - customer</li> <li> write a spec for the return value</li> <li>write a spec for relationship between args and return value</li> <li> replace the mock data with generated values from specification</li> <li> update functions and make tests pass</li> <li>instrument functions</li> <li>run specification checks</li> </ul>"},{"location":"projects/banking-on-clojure/account-overview-page/","title":"Initial design","text":"<p>The initial design is a simple copy/paste approach to see what the results look like in the web page.  Once the design has been established, the code will be refactored to reduce duplication.</p> <pre><code>(defn accounts-overview-page\n[request]\n(response\n(html5\n{:lang \"en\"}\n[:head\n(include-css \"https://cdn.jsdelivr.net/npm/bulma@0.9.0/css/bulma.min.css\")]\n[:body\n[:section {:class \"hero is-info\"}\n[:div {:class \"hero-body\"}\n[:div {:class \"container\"}\n[:h1 {:class \"title\"} \"Banking on Clojure\"]\n[:p {:class \"subtitle\"}\n\"Making your money immutable\"]]]]\n[:section {:class \"section\"}\n[:article {:class \"media\"}\n[:figure {:class \"media-left\"}\n[:p {:class \"image is-64x64\"}\n[:img {:src \"https://raw.githubusercontent.com/jr0cket/developer-guides/master/clojure/clojure-bank-coin.png\"}]]]\n[:div {:class \"media-content\"}\n[:div {:class \"content\"}\n[:h3 {:class \"subtitle\"}\n\"Current Account : &amp;lambda;1,000,000\"]\n[:p \"Account number: 123456789   Sort code: 01-02-01\"]]]\n[:div {:class \"media-right\"}\n(link-to {:class \"button is-primary\"} \"/transfer\" \"Transfer\")\n(link-to {:class \"button is-info\"} \"/payment\" \"Payment\")]]\n[:article {:class \"media\"}\n[:figure {:class \"media-left\"}\n[:p {:class \"image is-64x64\"}\n[:img {:src \"https://raw.githubusercontent.com/jr0cket/developer-guides/master/clojure/clojure-bank-coin.png\"}]]]\n[:div {:class \"media-content\"}\n[:div {:class \"content\"}\n[:h3 {:class \"subtitle\"}\n\"Savings Account : &amp;lambda;1,000,000 \"]\n[:p \"Account number: 123454321    Sort code: 01-02-01\"]]]\n[:div {:class \"media-right\"}\n(link-to {:class \"button is-primary\"} \"/transfer\" \"Transfer\")\n(link-to {:class \"button is-info\"} \"/payment\" \"Payment\")]]\n[:article {:class \"media\"}\n[:figure {:class \"media-left\"}\n[:p {:class \"image is-64x64\"}\n[:img {:src \"https://raw.githubusercontent.com/jr0cket/developer-guides/master/clojure/clojure-bank-coin.png\"}]]]\n[:div {:class \"media-content\"}\n[:div {:class \"content\"}\n[:h3 {:class \"subtitle\"}\n\"Tax Free Savings Account : &amp;lambda;1,000,000 \"]]]\n[:div {:class \"media-right\"}\n(link-to {:class \"button is-primary\"} \"/transfer\" \"Transfer\")\n(link-to {:class \"button is-info\"} \"/payment\" \"Payment\")]]\n[:article {:class \"media\"}\n[:figure {:class \"media-left\"}\n[:p {:class \"image is-64x64\"}\n[:img {:src \"https://raw.githubusercontent.com/jr0cket/developer-guides/master/clojure/clojure-bank-coin.png\"}]]]\n[:div {:class \"media-content\"}\n[:div {:class \"content\"}\n[:h3 {:class \"subtitle\"}\n\"Mortgage Account : &amp;lambda;1,000,000 \"]\n[:p \"Mortgage Reference: 98r9e8r79wr87e9232\"]]]\n[:div {:class \"media-right\"}\n(link-to {:class \"button is-primary\"} \"/transfer\" \"Transfer\")\n(link-to {:class \"button is-info\"} \"/payment\" \"Payment\")]]\n]])))\n</code></pre>"},{"location":"projects/banking-on-clojure/account-overview-page/#refactor-page-layout-with-functions","title":"Refactor page layout with functions","text":"<p>Duplicate markup code for pages can be wrapped in a helper function that generated the correct code, usually given a few specific arguments.</p> <p>Its usually more effective to create the design with duplicate code first and then see the sections of code that are duplicated.</p> <pre><code>  (defn unordered-list [items]\n[:ul\n(for [i items]\n[:li i])])\n</code></pre> <p>Many lines of code can now be reduced to a single line when adding an unordered list to a page defined with hiccup.</p> <pre><code>  [:div\n(unordered-list [\"collection\" \"of\" \"list\" \"items\"])]\n</code></pre> <p>Applying this technique to the bank accounts overview page.  Find the code that is repeated the most and define a function containing that code.</p> <p>The function should take arguments, typically a map so its more flexible in what arguments must be passed and increases the usability of the function</p> <pre><code>(defn bank-account-media-object\n[account-details]\n[:article {:class \"media\"}\n[:figure {:class \"media-left\"}\n[:p {:class \"image is-64x64\"}\n[:img {:src \"https://raw.githubusercontent.com/jr0cket/developer-guides/master/clojure/clojure-bank-coin.png\"}]]]\n[:div {:class \"media-content\"}\n[:div {:class \"content\"}\n[:h3 {:class \"subtitle\"}\n(str (:account-type account-details) \" : &amp;lambda;\" (:account-value account-details))]\n[:p\n(str \"Account number: \" (:account-number account-details) \" Sort code: \" (:account-sort-code account-details))]]]\n[:div {:class \"media-right\"}\n(link-to {:class \"button is-primary\"} \"/transfer\" \"Transfer\")\n(link-to {:class \"button is-info\"} \"/payment\" \"Payment\")]])\n</code></pre> <p>Calling the bank-account-media-object function with a map will generate the same resulting page.</p> <pre><code>  (bank-account-media-object\n{:account-type      \"Current Account\"\n:account-number    \"123456789\"\n:account-value     \"i1,000,000\"\n:account-sort-code \"01-02-01\"})\n</code></pre> <p>Result of calling the bank-account-media-object with that map:</p> <pre><code>[:article {:class \"media\"}\n[:figure {:class \"media-left\"}\n[:p {:class \"image is-64x64\"}\n[:img {:src \"https://raw.githubusercontent.com/jr0cket/developer-guides/master/clojure/clojure-bank-coin.png\"}]]]\n[:div {:class \"media-content\"}\n[:div {:class \"content\"}\n[:h3 {:class \"subtitle\"} \"Current Account : &amp;lambda;\" \"i1,000,000\"]\n[:p \"Account number: \" {:account-number {:account-type \"Current Account\", :account-number \"123456789\", :account-value \"i1,000,000\", :account-sort-code \"01-02-01\"}} \" Sort code: \" {:account-sort-code {:account-type \"Current Account\", :account-number \"123456789\", :account-value \"i1,000,000\", :account-sort-code \"01-02-01\"}}]]]\n[:div {:class \"media-right\"}\n[:a {:href #object[java.net.URI 0x3516357f \"/transfer\"], :class \"button is-primary\"} (\"Transfer\")]\n[:a {:href #object[java.net.URI 0x4cf62d27 \"/payment\"], :class \"button is-info\"} (\"Payment\")]]]\n</code></pre> <p>If some key/value pairs are not included, the function will still work.  Worst case is that there will be gaps where expected values would otherwise be included in the page.</p> <p>Instead of many duplicate lines of code, the accounts-overview-page is reduce to less than half the code is far more readable as it is expressed as data in a hash-map.</p> <pre><code>(defn accounts-overview-page\n[request]\n(response\n(html5\n{:lang \"en\"}\n[:head\n(include-css \"https://cdn.jsdelivr.net/npm/bulma@0.9.0/css/bulma.min.css\")]\n[:body\n[:section {:class \"hero is-info\"}\n[:div {:class \"hero-body\"}\n[:div {:class \"container\"}\n[:h1 {:class \"title\"} \"Banking on Clojure\"]\n[:p {:class \"subtitle\"}\n\"Making your money immutable\"]]]]\n[:section {:class \"section\"}\n(bank-account-media-object {:account-type  \"Current Account\" :account-number    \"123456789\"\n:account-value \"1,234\"       :account-sort-code \"01-02-01\"})\n(bank-account-media-object {:account-type  \"Savings Account\" :account-number    \"123454321\"\n:account-value \"2,000\"       :account-sort-code \"01-02-01\"})\n(bank-account-media-object {:account-type  \"Tax Free Savings Account\" :account-number    \"123454321\"\n:account-value \"20,000\"                :account-sort-code \"01-02-01\"})\n(bank-account-media-object {:account-type  \"Mortgage Account\" :account-number    \"98r9e8r79wr87e9232\"\n:account-value \"354,000\"          :account-sort-code \"01-02-01\"})\n]])))\n</code></pre>"},{"location":"projects/banking-on-clojure/account-overview-page/#wrap-results-in-page-heading","title":"Wrap results in page heading","text":"<p>The heading is common in all pages, so it can be extracted to a function that processes the result of all handlers, this is referred to as middleware.</p>"},{"location":"projects/banking-on-clojure/clojure-server-project/","title":"Create Clojure server project","text":"<p>Initially the project is configured with a simple application sever using http-kit and routing defined by compojure library.  The ring library is used to generate well-formed responses.</p>"},{"location":"projects/banking-on-clojure/clojure-server-project/#create-project","title":"Create project","text":"<p>Create a Clojure CLI project from the app template</p> Practicalli Clojure CLI ConfigAlias Definition <p>Using <code>:project/create</code> alias from Practicalli Clojure CLI Config <pre><code>clojure -T:project/create :template app :name practicalli.banking-on-clojure/service :target-dir banking-on-clojure\n</code></pre></p> <p>Add an alias definition to the user configuration for Clojure CLI, eg. <code>$XDG_CONFIG_HOME/clojure/deps.edn</code> or <code>$HOME/.clojure/deps.edn</code> <pre><code>:project/create\n{:replace-deps {io.github.seancorfield/deps-new {:git/tag \"v0.4.13\" :git/sha \"879c4eb\"}}\n:exec-fn      org.corfield.new/create\n:exec-args    {:template app :name practicalli/playground}}\n</code></pre></p> <p>Consider using Practicalli Clojure CLI Config to simply add a wide range of tools for Clojure CLI</p>"},{"location":"projects/banking-on-clojure/clojure-server-project/#library-dependencies","title":"Library Dependencies","text":"<p>Add the http-kit, compojure and ring libraries to the project configuration</p> deps.edn<pre><code>{:paths [\"src\" \"resources\"]\n:deps {org.clojure/clojure {:mvn/version \"1.11.3\"}\nhttp-kit/http-kit   {:mvn/version \"2.3.0\"}\nring/ring           {:mvn/version \"1.9.6\"}}}\n</code></pre>"},{"location":"projects/banking-on-clojure/clojure-server-project/#configure-namespace","title":"Configure namespace","text":"<p>Add <code>org.httpkit.server</code>, <code>compojure</code> and <code>ring.util.response</code> as required namespaces</p> src/practicalli/banking_on_clojure/service.clj<pre><code>(ns practicalli.banking-on-clojure\n(:gen-class)\n(:require [org.httpkit.server :as app-server]\n[compojure.core :refer [defroutes GET]]\n[ring.util.response :refer [response]]))\n</code></pre>"},{"location":"projects/banking-on-clojure/clojure-server-project/#routing-and-request-handlers","title":"Routing and Request handlers","text":"<p><code>compojure</code> provides an abstraction for routing. The <code>defroutes</code> function directs requests to handlers, which are Clojure functions that take a request hash-map as an argument.</p> <p>The routing is based on the http protocol (GET, POST, etc) and URL.</p> src/practicalli/banking_on_clojure/service.clj<pre><code>(defn welcome-page\n[request]\n(response \"Banking on Clojure\"))\n(defroutes app\n(GET \"/\" [] welcome-page))\n</code></pre>"},{"location":"projects/banking-on-clojure/clojure-server-project/#defining-the-application-server-system","title":"Defining the application server system","text":"<p>A <code>clojure.core/atom</code> is used to hold a reference to application server instance for stopping/restarting the server.</p> src/practicalli/banking_on_clojure/service.clj<pre><code>(defonce app-server-instance (atom nil))\n</code></pre> <p>A function to start the application server on a given HTTP port number.</p> <p>The start process sends a timestamped log message to standard out before starting the application server.</p> <p>The <code>app-server-instance</code> is updated with a reference to the running application server.</p> src/practicalli/banking_on_clojure/service.clj<pre><code>(defn app-server-start\n\"Start the application server and log the time of start.\"\n[http-port]\n(println (str (java.util.Date.)\n\" INFO: Starting server on port: \" http-port))\n(reset! app-server-instance\n(app-server/run-server #'app {:port http-port})))\n</code></pre> <p>A function to stop the application server, send out a timestamped log message and remove the application server reference.</p> src/practicalli/banking_on_clojure/service.clj<pre><code>(defn app-server-stop\n\"Gracefully shutdown the server, waiting 100ms.  Log the time of shutdown\"\n[]\n(when-not (nil? @app-server-instance)\n(@app-server-instance :timeout 100)\n(reset! app-server-instance nil)\n(println (str (java.util.Date.)\n\" INFO: Application server shutting down...\"))))\n</code></pre> <p>A function to restart the application server, which simply calls the stop and start functions.</p> src/practicalli/banking_on_clojure/service.clj<pre><code>(defn app-server-restart\n\"Convenience function to stop and start the application server\"\n[http-port]\n(app-server-stop)\n(app-server-start http-port))\n</code></pre> <p>A <code>-main</code> function that will be called from the command line, taking an optional HTTP port.  If a port number is no provided as an argument, an operating system environment variable called PORT is used or the default <code>8888</code> is used.</p> <p>Using an operating system environment variable is important when deploying the application to a cloud environment.</p> src/practicalli/banking_on_clojure/service.clj<pre><code>(defn -main\n\"Select a value for the http port the app-server will listen to\n  and call app-server-start\n  The http port is either an argument passed to the function,\n  an operating system environment variable or a default value.\"\n[&amp; [http-port]]\n(let [http-port (Integer. (or http-port (System/getenv \"PORT\") \"8888\"))]\n(app-server-start http-port)))\n</code></pre>"},{"location":"projects/banking-on-clojure/clojure-server-project/#repl-driven-development-helpers","title":"REPL driven development helpers","text":"<p>A comment block is added at the end of the code to show how to start/stop/restart the web application, along with a few useful expressions.</p> src/practicalli/banking_on_clojure/service.clj<pre><code>(comment\n;; Start application server - via `-main` or `app-server-start`\n(-main)\n(app-server-start 8888)\n;; Stop / restart application server\n(app-server-stop)\n(app-server-restart 8888)\n;; Get PORT environment variable from Operating System\n(System/getenv \"PORT\")\n;; Get all environment variables\n;; use a data inspector to view environment-variables name\n(def environment-variables\n(System/getenv))\n;; Check values set in the default system properties\n(def system-properties\n(System/getProperties))\n)\n</code></pre>"},{"location":"projects/banking-on-clojure/clojure-server-project/#the-complete-code-so-far","title":"The Complete code so far","text":"src/practicalli/banking_on_clojure/service.clj<pre><code>(ns practicalli.banking-on-clojure\n(:gen-class)\n(:require [org.httpkit.server :as app-server]\n[compojure.core :refer [defroutes GET]]\n[ring.util.response :refer [response]]))\n;; ---------------------------------------\n;; Request handlers\n(defn welcome-page\n[request]\n(response \"Banking on Clojure\"))\n;; ---------------------------------------\n;; ---------------------------------------\n;; Request Routing\n(defroutes app\n(GET \"/\" [] welcome-page))\n;; ---------------------------------------\n;; ---------------------------------------\n;; System\n;; Reference to application server instance for stopping/restarting\n(defonce app-server-instance (atom nil))\n(defn app-server-start\n\"Start the application server and log the time of start.\"\n[http-port]\n(println (str (java.util.Date.)\n\" INFO: Starting server on port: \" http-port))\n(reset! app-server-instance\n(app-server/run-server #'app {:port http-port})))\n(defn app-server-stop\n\"Gracefully shutdown the server, waiting 100ms.  Log the time of shutdown\"\n[]\n(when-not (nil? @app-server-instance)\n(@app-server-instance :timeout 100)\n(reset! app-server-instance nil)\n(println (str (java.util.Date.)\n\" INFO: Application server shutting down...\"))))\n(defn app-server-restart\n\"Convenience function to stop and start the application server\"\n[http-port]\n(app-server-stop)\n(app-server-start http-port))\n(defn -main\n\"Select a value for the http port the app-server will listen to\n  and call app-server-start\n  The http port is either an argument passed to the function,\n  an operating system environment variable or a default value.\"\n[&amp; [http-port]]\n(let [http-port (Integer. (or http-port (System/getenv \"PORT\") \"8888\"))]\n(app-server-start http-port)))\n;; ---------------------------------------\n;; ---------------------------------------\n;; REPL driven development helpers\n(comment\n;; Start application server - via `-main` or `app-server-start`\n(-main)\n(app-server-start 8888)\n;; Stop / restart application server\n(app-server-stop)\n(app-server-restart 8888)\n;; Get PORT environment variable from Operating System\n(System/getenv \"PORT\")\n;; Get all environment variables\n;; use a data inspector to view environment-variables name\n(def environment-variables\n(System/getenv))\n;; Check values set in the default system properties\n(def system-properties\n(System/getProperties))\n)\n;; ---------------------------------------\n</code></pre>"},{"location":"projects/banking-on-clojure/clojure-spec-generate-mock-data/","title":"Clojure spec generate mock data","text":""},{"location":"projects/banking-on-clojure/clojure-spec-generate-mock-data/#generate-database-record-data-from-clojure-specifications","title":"Generate database record data from Clojure Specifications","text":"<p>The Clojure specifications developed for the banking-on-clojure application can be used to generate random data that can be used to test the database schema and CRUD functions.</p> <p>In the database schema design page the <code>next.jdbc.sql</code> functions were used to define a generic function for inserting records into a database</p> <pre><code>(defn insert-record\n[table record-data db-spec]\n(with-open [connection (jdbc/get-connection db-spec)]\n(jdbc-sql/insert! connection table record-data)))\n</code></pre> <p>The call to this function uses a value for <code>record-data</code> that is almost identical to the value generated from the <code>practicalli.banking-on-clojure/account-holder</code> specification.  The only difference is the key name styles.</p> <pre><code>(create-record db-specification-dev\n:public.account_holders\n{:account_holder_id      (java.util.UUID/randomUUID)\n:first_name             \"Rachel\"\n:last_name              \"Rocketpack\"\n:email_address          \"rach@rocketpack.org\"\n:residential_address    \"1 Ultimate Question Lane, Altar IV\"\n:social_security_number \"BB104312D\"})\n</code></pre>"},{"location":"projects/banking-on-clojure/clojure-spec-generate-mock-data/#generating-data-from-clojure-specifications","title":"Generating data from Clojure Specifications","text":"<p><code>clojure.spec.alpha/gen</code> takes a spec and returns a reference to a generator for that specification.</p> <p><code>clojure.spec.gen.alpha/generate</code> returns a random value using the spec generator.</p> <p>Generate a value from the <code>account-holder</code> specification</p> <pre><code>(spec-gen/generate (spec/gen ::account-holder))\n</code></pre> <p>Create a simple helper function in <code>practicalli/specifications-banking.clj</code> to generating mock data from the specifications relevant to the database.</p> <pre><code>(defn mock-data-account-holder\n[]\n(spec-gen/generate (spec/gen ::account-holder)))\n</code></pre> <p>The <code>practicalli.database-access/create-record</code> function can now be passed a generated record-data argument using <code>(practicalli.specifications-banking/mock-data-account-holder)</code></p> <pre><code>(create-record\ndb-specification-dev\n:public.account_holders\n(practicalli.specifications-banking/mock-data-account-holder))\n</code></pre>"},{"location":"projects/banking-on-clojure/clojure-spec-generate-mock-data/#clojure-and-database-naming-disparity","title":"Clojure and database naming disparity","text":"<p>When calling <code>create-record</code> with a specification there is a disparity between the names of the keys from the clojure specification and the names of the columns in database.</p> <ul> <li>Clojure uses <code>kebab-case</code></li> <li>Database uses <code>snake_case</code></li> </ul> <p></p> <p>Most relational databases will not accept column names in <code>kebab-case</code>.</p> <p>Do we have to compromise the Clojure style kebab-case just for the database?  Do we have to create our own generators or transform code to convert the specs generated?</p>"},{"location":"projects/banking-on-clojure/clojure-spec-generate-mock-data/#automatically-converting-key-names","title":"Automatically converting key names","text":"<p>Clojure uses kebab-case for key names in Clojure specs (and all names in general).</p> <p>Relational databases use snake_case for table and column names and most databases will not support kebab-case.</p> <p>It is simple to convert between the two cases, as its simply a string replacement for <code>-</code> with <code>_</code>.  clj-commons/camel-snake-kebab is a library that converts between each of the naming styles.</p> <p><code>camel-snake-kebab.core/-&gt;snake_case</code> takes a name and returns it in snake_case</p> <p>next.jdbc support conversion between camel-case names when clj-commons/camel-snake-kebab is added to the project dependencies.</p> <p>The next.jdbc.sql CRUD functions take an optional configuration hash-map as the fourth argument.  When ,,, is on the class path, next.jdbc has two hash-maps available that will define functions to use from the ,,, library to do the name conversions.</p> <ul> <li><code>next.jdbc/snake-kebab-opts</code> for unqualified Clojure keywords</li> <li><code>next.jdbc/unqualified-snake-kebab-opts</code> for unqualified Clojure keywords</li> </ul>"},{"location":"projects/banking-on-clojure/clojure-spec-generate-mock-data/#refactor-crud-functions-to-automatically-convert-case","title":"Refactor CRUD functions to automatically convert case","text":"<p>Refactor the CRUD functions to include the <code>snake-kebab-opts</code> hash-map as an argument.</p> <p>Only those functions that take keywords as part of the argument need to be changed, so <code>next.jdbc.sql/query</code> does not need to change and therefore the <code>practicalli.database-access/read-record</code> remains unchanged.</p> <p>Refactor the <code>practicalli.database-access/create-record</code> function</p> <pre><code>(defn create-record\n\"Insert a single record into the database using a managed connection.\n  Arguments:\n  - table - name of database table to be affected\n  - record-data - Clojure data representing a new record\n  - db-spec - database specification to establish a connection\"\n[db-spec table record-data]\n(with-open [connection (jdbc/get-connection db-spec)]\n(jdbc-sql/insert! connection table record-data jdbc/snake-kebab-opts)))\n</code></pre> <p>Refactor the <code>practicalli.database-access/update-record</code> function</p> <pre><code>(defn update-record\n\"Insert a single record into the database using a managed connection.\n  Arguments:\n  - table - name of database table to be affected\n  - record-data - Clojure data representing a new record\n  - db-spec - database specification to establish a connection\n  - where-clause - column and value to identify a record to update\"\n[db-spec table record-data where-clause]\n(with-open [connection (jdbc/get-connection db-spec)]\n(jdbc-sql/update! connection table record-data where-clause jdbc/snake-kebab-opts)))\n</code></pre>"},{"location":"projects/banking-on-clojure/clojure-spec-generate-mock-data/#disparity-between-spec-namespace-and-database-design","title":"Disparity between spec namespace and database design","text":"<p>A qualified keyword is where that keyword has a namespace, eg. <code>:practicalli/name</code> rather than <code>:name</code></p> <p>Using qualified keywords is recommended so that they can be unique across the application (and ideally multiple applications).</p> <p>When using a database, the table name can be used to qualify the results returned from queries to the database.  However, if the table names are different to the clojure.spec specification then it is harder to test</p> <p></p> <p>To resolve this issue, either the specifications should be refactored or the database names.  I suspect probably both would benefit from some redesign now experience has been gained in using them.</p>"},{"location":"projects/banking-on-clojure/continuous-integration/","title":"Continuous Integration with CirceCI","text":"<p>The application infrastructure has been established and now the main body of the development can commence.  Therefore it is very valuable to establish a continuous integration pipeline.</p> <p>Practicalli Clojure: Continuous Integration with CircleCI covers in detail how to use Continuous Integration with Clojure projects (deps.edn and Leiningen).</p>"},{"location":"projects/banking-on-clojure/continuous-integration/#using-kaocha-test-runner","title":"Using kaocha test runner","text":"<p>LambdaIsland kaocha test runner is used as the unit test runner as it will also run generative tests where functions have specifications defined.</p> <p>Add a <code>:test/run</code> alias to the <code>deps.edn</code> file in the root of the project.</p> <p>The configuration runs Kaocha without test randomisation for a consistent test order and stops the test runner if a test fails, ensuring time is not spent running tests after a failure.</p> <pre><code>:test/run\n{:extra-paths [\"test\"]\n:extra-deps {lambdaisland/kaocha {:mvn/version \"1.60.977\"}}\n:exec-fn kaocha.runner/exec-fn\n:exec-args {:randomize? false\n:fail-fast? true}}\n</code></pre> <p>Create the file <code>bin/kaocha</code> in the root of the project and make it executable (e.g. <code>chmod a+x bin/kaocha</code>)</p> <pre><code>#!/usr/bin/env bash\n## Script to run the kaocha test runner\n## for unit tests and clojure spec generative tests\nclojure -X:test/run \"$@\"\n</code></pre>"},{"location":"projects/banking-on-clojure/continuous-integration/#configure-circleci-pipeline","title":"Configure CircleCI pipeline","text":"<p>Configure a pipeline to use a docker image with Java 17 and the latest Clojure CLI tools</p> <p>The configuration uses the Kaocha Orb to simplify the configuration required to use the Kaocha test runner from within CircleCI.</p> <p>A run step will call the kaocha script that is included in the project code repository and run the unit tests.  If function specifications are present in the project, generative tests will also be run.</p> <pre><code>version: 2.1  # circleci configuration version\norbs:\nkaocha: lambdaisland/kaocha@0.0.3 # Org settings &gt; Security &gt; uncertified orbs\njobs:    # basic units of work in a run\nbuild: # runs not using Workflows must have a `build` job as entry point\nworking_directory: ~/build    # directory where steps will run\ndocker:                       # run the steps with Docker\n- image: cimg/clojure:1.10  # image is primary container where `steps` are run\nenvironment:                  # environment variables for primary container\nJVM_OPTS: -Xmx3200m         # limit the maximum heap size to prevent out of memory errors\nsteps:                        # commands that comprise the `build` job\n- checkout                  # check out source code to working directory\n- restore_cache:            # restores saved cache if checksum hasn't changed since the last run\nkey: banking-on-clojure-webapp-{{ checksum \"deps.edn\" }}\n- run: clojure -X:test/runner\n- save_cache:               # generate and store cache in the .m2 directory using a key template\npaths:\n- ~/.m2\n- ~/.gitlibs\nkey: banking-on-clojure-webapp-{{ checksum \"deps.edn\" }}\n- run: bin/kaocha --reporter kaocha.report/documentation --no-randomize --no-color --plugin kaocha.plugin.alpha/spec-test-check\n</code></pre> <p>Enable 3rd Party Orbs</p> <p>Enable 3rd Party Orbs in Organisation &gt; Security settings</p>"},{"location":"projects/banking-on-clojure/create-records/","title":"Create database records","text":"<p>Several options were explored when designing database query functions.  Using next.jdbc.sql functions provides a Clojure data structures approach, where as <code>next.jdbc/execute!</code> uses specific SQL statement code.</p> <p>Take the SQL approach if generating SQL statements directly.</p> <p>Take the Clojure approach if to generate SQL statements from Clojure data structures.</p>"},{"location":"projects/banking-on-clojure/create-records/#generic-create-record-function","title":"Generic create record function","text":"<p>Use the generic create function from the database schema design section</p> <pre><code>(defn create-record\n\"Insert a single record into the database using a managed connection.\n  Arguments:\n  - table - name of database table to be affected\n  - record-data - Clojure data representing a new record\n  - db-spec - database specification to establish a connection\"\n[db-spec table record-data]\n(with-open [connection (jdbc/get-connection db-spec)]\n(jdbc-sql/insert! connection table record-data)))\n</code></pre>"},{"location":"projects/banking-on-clojure/create-records/#create-a-new-account_holder-record","title":"Create a new account_holder record","text":"<p>Call the <code>create-record</code> function with the development database specification, the account holder table name and a Clojure hash-map of the record data.</p> <p>Each key in the map represents a column name and the value associated with the key is the value to be inserted in the record for its column.</p> <pre><code>(create-record db-specification-dev\n\"public.account_holders\"\n{:account_holder_id      (java.util.UUID/randomUUID)\n:first_name             \"Rachel\"\n:last_name              \"Rocketpack\"\n:email_address          \"rach@rocketpack.org\"\n:residential_address    \"1 Ultimate Question Lane, Altar IV\"\n:social_security_number \"BB104312D\"})\n</code></pre>"},{"location":"projects/banking-on-clojure/create-records/#create-account-record","title":"Create account record","text":"<p>Create a new record in the <code>public.accounts</code> table.</p> <pre><code>(create-record db-specification-dev\n\"public.accounts\"\n{:account_id        (java.util.UUID/randomUUID)\n:account_number    \"1234567890\"\n:account_sort_code \"102010\"\n:account_name      \"Current\"\n:current_balance   100\n:last_updated      \"2020-09-11\"\n:account_holder_id (java.util.UUID/randomUUID)})\n</code></pre>"},{"location":"projects/banking-on-clojure/create-records/#create-transaction-record","title":"Create transaction record","text":"<p>Create a record in the <code>public.transaction_history</code> table.</p> <pre><code>(create-record db-specification-dev\n\"public.transaction_history\"\n{:transaction_id        (java.util.UUID/randomUUID)\n:transaction_reference \"Salary\"\n:transaction_date      \"2020-09-11\"\n:account_number        \"1234567890\"})\n</code></pre> <p>Generating example data from Clojure Spec</p> <p>Clojure Spec: generate mock database data</p>"},{"location":"projects/banking-on-clojure/cyclic-load-dependency/","title":"Cyclic Load Dependency","text":"<p>A cyclic load dependency is where one namespace requires one or more other namespaces that then require the original namespace, forming a loop when resolve all the required namespaces.  When there are cyclic namespace dependencies a warning is returned when evaluating any of the namespaces involved.</p> <p>A good way to spot cyclic load dependencies it to regularly run a test runner on the code, or even set up a test runner to watch for changes to the file system which then triggers an automatic test run.  For example, <code>kaocha --watch</code>.</p>"},{"location":"projects/banking-on-clojure/cyclic-load-dependency/#tips-on-avoiding-cyclic-load-dependencies","title":"Tips on avoiding  cyclic load dependencies","text":"<ul> <li> <p>Add comment sections describing the purpose of the different parts of code, creating logical separation of code.  Refactor of namespaces is far easier to see and helps ensure related code is kept together.</p> </li> <li> <p>Ensure test and specification code is in its own namespace.  Keeping the right level of abstraction in tests and clojure spec test.check can help avoid issues.</p> </li> <li> <p>Use <code>require</code> to add dependent namespaces, preferably using a meaningful <code>:as</code> alias or using <code>:refer</code> for only the function names used. <code>(:require ,,, :refer :all)</code> or <code>(use ,,)</code> expressions can pull in too many other namespaces and cause issues</p> </li> <li> <p>A cyclic load dependency error message is a good point to review and refactor the application design.</p> </li> <li> <p>Where two namespaces are interdependent on each other, factor out shared code into a third namespace required by each of the other two.  This breaks the dependency between the two original namespaces.</p> </li> </ul>"},{"location":"projects/banking-on-clojure/cyclic-load-dependency/#example-banking-on-clojure","title":"Example - Banking on Clojure","text":"<p>The <code>practicalli.banking-on-clojure.handler</code> namespace contains functions that need to access data in the database, so the <code>practicalli.database-access</code> namespace is required.</p> <pre><code>(ns practicalli.banking-on-clojure.handler\n(:require\n;; Web Application\n[ring.util.response :refer [response]]\n[hiccup.core :refer [html]]\n[hiccup.page :refer [html5 include-js include-css]]\n[hiccup.element :refer [link-to]]\n;; Data access\n[practicalli.database-access :as data-access]))\n</code></pre> <p>The <code>practicalli.database-access</code> namespace required the <code>practicalli.banking-on-clojure.specification</code> namespace to use the specifications for generating data</p> <pre><code>(ns practicalli.database-access\n(:require [next.jdbc :as jdbc]\n[next.jdbc.sql :as jdbc-sql]\n[next.jdbc.specs :as jdbc-spec]\n[practicalli.banking-on-clojure.specification]))\n</code></pre> <p>In the <code>practicalli.banking-on-clojure.specification</code> namespace, a functional specification had been defined for the <code>register-account-holder</code> function, which required the <code>practicalli.banking-on-clojure.handler</code> to be required.  Even though the specifications testing had logically moved to the database-access namespace, this functional specification remained.</p> <pre><code>(ns practicalli.banking-on-clojure.specification\n(:require\n;; Clojure Specifications\n[clojure.spec.alpha :as spec]\n[clojure.spec.gen.alpha :as spec-gen]\n[clojure.spec.test.alpha :as spec-test]\n;; Helper namespaces\n[clojure.string]\n[practicalli.banking-on-clojure.handler :as handler]))\n</code></pre> <p>This set of require expressions lead to a cyclic load dependency error.</p> <p><code>-&gt;</code> indicate that a namespace requires the namespace it is pointing too.</p> <p></p> <p>Removing the require of <code>practicalli.banking-on-clojure.handler</code> from the <code>practicalli.banking-on-clojure.specification</code> namespace breaks the cyclic dependency.</p>"},{"location":"projects/banking-on-clojure/cyclic-load-dependency/#testing-the-database-on-ci","title":"Testing the database on CI","text":"<p>Need to create the tables before the tests can run. - update the schema so the create tables can run without failure, check if table exist and if not create it.</p>"},{"location":"projects/banking-on-clojure/database-queries/","title":"Defining Database Queries","text":"<p>Using the SQL statement for Inserting records as an example, several different approached are covered for defining database queries.  The options are similar for update and delete queries.</p> <p>All options use the <code>with-open</code> function to wrap the connection to the database, to automatically close that connection once the function has completed.</p> Approach Description <code>next.jdbc/execute!</code> function Simple approached used previously for creating tables Defining a generic function Pass SQL statements and connection into a single function, using <code>def</code> to define sql statements <code>next.jdbc.sql/*</code> functions Generate SQL statements from Clojure data structures, e.g. hash-maps, vectors, etc. Generic function with <code>next.jdbc.sql/*</code> functions Generic insert, update and delete functions that take a Clojure data structures"},{"location":"projects/banking-on-clojure/database-queries/#example-sql-queries-from-dbeaver","title":"Example SQL queries from DBeaver","text":"<p>Using the DBeaver tool the basic form of an insert command is generated from Generate SQL &gt; DDL</p> <pre><code>INSERT INTO PUBLIC.ACCOUNT_HOLDERS\n(ACCOUNT_HOLDER_ID, FIRST_NAME, LAST_NAME, EMAIL_ADDRESS, RESIDENTIAL_ADDRESS, SOCIAL_SECURITY_NUMBER)\nVALUES(?, '', '', '', '', '');\n</code></pre>"},{"location":"projects/banking-on-clojure/database-queries/#using-the-general-execute-command","title":"Using the general execute! command","text":"<p>Using the general jdbc/execute! is the same form as used previously to create, show and drop database tables.</p> <pre><code>(defn persist-account-holder\n\"Persist a new account holder record\"\n[account-holder-id db-spec]\n(with-open [connection (jdbc/get-connection db-spec)]\n(jdbc/execute!\nconnection\n[(str \"insert into account_holders(\n               account_holder_id,first_name,last_name,email_address,residential_address,social_security_number)\n             values(\n               '\" account-holder-id \"', 'Jenny', 'Jetpack', 'jen@jetpack.org', '42 Meaning Lane, Altar IV', 'AB101112C' )\")])) )\n</code></pre> <p>Call the function with a randomly generated UUID value for the <code>account_holder_id</code> and the database details in the form of the development database specification.</p> <pre><code>(persist-account-holder (java.util.UUID/randomUUID) db-specification-dev)\n</code></pre>"},{"location":"projects/banking-on-clojure/database-queries/#using-a-generic-function-approach","title":"Using a generic function approach","text":"<p>Write a Clojure function that takes in any SQL statement and executes that against a specific database specification.</p> <pre><code>(defn database-update\n[sql-statement db-spec ]\n(with-open [connection (jdbc/get-connection db-spec)]\n(jdbc/execute! connection sql-statement)))\n</code></pre> <p>Refactor sql statements into their own vars, so they can be reused.</p> <pre><code>(def account-holder-jenny\n[(str \"insert into account_holders(account_holder_id,first_name,last_name,email_address,residential_address,social_security_number)\n    values('\" (java.util.UUID/randomUUID) \"', 'Jenny', 'Jetpack', 'jen@jetpack.org', '42 Meaning Lane, Altar IV', 'AB101112C' )\")])\n</code></pre> <p>Update the database using the name of the SQL statement</p> <pre><code>(database-update account-holder-jenny db-specification-dev)\n</code></pre> <p>Limitation of def</p> <p>The <code>def</code> expression must be evaluated each time a new value for the account_holder_id is required.  The first time the <code>def</code> is evaluated, the <code>java-util.UUID/randomUUID</code> function is evaluated to a specific value and that value is cached.</p> <p>Using the <code>account-holder-jenny</code> name in other code will use the cache until the <code>def</code> expression is forcefully evaluated (by the developer or by restarting the REPL).</p>"},{"location":"projects/banking-on-clojure/database-queries/#using-nextjdbc-friendly-functions","title":"Using next.jdbc friendly functions","text":"<p>Using next.jdbc.sql functions.  For example:</p> <pre><code>(jdbc-sql/insert! ds :address {:name \"A. Person\" :email \"albert@person.org\"})\n</code></pre> <p>For the banking-on-clojure project this would take the form</p> <pre><code>(defn add-account-holder\n[account-holder-id data-source]\n(jdbc-sql/insert!\ndata-source\n:table-name {:column-name \"value\" ,,,}))\n</code></pre> <p>In this example, the next.jdbc insert! function is used to add an account holder record.</p> <pre><code>(defn add-account-holder\n[account-holder-id db-spec]\n(with-open [connection (jdbc/get-connection db-spec)]\n(jdbc-sql/insert!\nconnection\n:public.account_holders {:account_holder_id      account-holder-id\n:first_name             \"Rachel\"\n:last_name              \"Rocketpack\"\n:email_address          \"rach@rocketpack.org\"\n:residential_address    \"1 Ultimate Question Lane, Altar IV\"\n:social_security_number \"BB104312D\"})))\n</code></pre> <p>Calling the function with generated data.</p> <pre><code>(add-account-holder (java.util.UUID/randomUUID) db-specification-dev)\n</code></pre>"},{"location":"projects/banking-on-clojure/database-queries/#generic-insert-function-with-nextjdbcsql","title":"Generic insert function with next.jdbc.sql","text":"<pre><code>(defn insert-record\n[table record-data db-spec]\n(with-open [connection (jdbc/get-connection db-spec)]\n(jdbc-sql/insert! connection table record-data)))\n</code></pre> <p>The data to pass in looks familiar. Its the table name plus a data structure that looks like a specification for an account holder.</p> <pre><code>:public.account_holders\n{:account_holder_id      (java.util.UUID/randomUUID)\n:first_name             \"Rachel\"\n:last_name              \"Rocketpack\"\n:email_address          \"rach@rocketpack.org\"\n:residential_address    \"1 Ultimate Question Lane, Altar IV\"\n:social_security_number \"BB104312D\"}\n</code></pre> <p>So the specifications already defined can be used to generate mock data for the database.</p>"},{"location":"projects/banking-on-clojure/database-tables/","title":"Design and Create Database Tables","text":"<p>The design for Banking On Clojure database contains three tables, <code>account_holders</code>, <code>accounts</code> and <code>transaction_history</code>.</p> <p><code>account_holders</code> contains a unique entry for every customer in the bank.</p> <p><code>accounts</code> contains every account created for the bank.  Each account has an account holder, a current balance and a date of when the current balance was last updated.</p> <p><code>transaction_history</code> contains every transaction that takes place in the bank.  Each transaction is related to a specific account.  The current balance for an account is built from all the transactions for a specific account.  The number of transactions used to calculate the current balance is reduced by using the last_updated value from accounts.</p> <p></p>"},{"location":"projects/banking-on-clojure/database-tables/#organising-the-code","title":"Organising the code","text":"<p>The SQL statements that create the database tables will be bound to a suitable name using <code>def</code>.  The value will be a vector containing the string of the SQL statement.</p> <p>The SQL statements are generated by the DBever database management tool.  The tables are created in DBeaver and the DDL script is exported for each table and pasted in the Clojure code.</p> <p>A <code>create-tables</code> helper function executes the given SQL statements on a specific data source, from within a transaction so that all table are either created or none are created.</p> <p><code>db-specification-dev</code> is a name bound to the database specification map for the development database.  This should eventually end up as an aero configuration along with the production database specification.</p> <pre><code>(def db-specification-dev {:dbtype \"h2\" :dbname \"banking-on-clojure\"})\n</code></pre>"},{"location":"projects/banking-on-clojure/database-tables/#define-account-holders-table","title":"Define <code>ACCOUNT-HOLDERS</code> table","text":"<p>Define the SQL statement to create a table to hold all the <code>ACCOUNT-HOLDERS</code>.</p> <p>The design includes all the customer details plus from the Banking on Clojure specifications and the <code>account_holder_id</code> that uniquely identifies the customer.</p> <pre><code>(def schema-account-holders-table\n[\"CREATE TABLE PUBLIC.ACCOUNT_HOLDERS(\n     ACCOUNT_HOLDER_ID UUID(16) NOT NULL,\n     FIRST_NAME VARCHAR(32),\n     LAST_NAME VARCHAR(32),\n     EMAIL_ADDRESS VARCHAR(32),\n     RESIDENTIAL_ADDRESS VARCHAR(255),\n     SOCIAL_SECURITY_NUMBER VARCHAR(32),\n     CONSTRAINT CONSTRAINT_3 PRIMARY KEY (ACCOUNT_HOLDER_ID))\"])\n</code></pre> <p>UUID inefficient for large data sets</p> <p>Using random data, like uuid, for indexes can be inefficient especially for larger data sets.  There may be data types for each specific database that provide more efficient ways of managing unique ids.  For the scope of this project, using a UUID is acceptable.</p>"},{"location":"projects/banking-on-clojure/database-tables/#define-accounts-table","title":"Define <code>ACCOUNTS</code> table","text":"<p>Define the SQL statement to create the <code>ACCOUNTS</code></p> <p>Each account is associated with an <code>ACCOUNT_HOLDER_ID</code> so that all the accounts belonging to a customer can be easily found.</p> <p>The current balance holds the value of credit in an account at the time of the last updated date.  The current_balance is calculated from the values in the transaction_history and updates to the current_balance will update the last_updated value.  This provides a very simplistic mechanism for quickly presenting the value of an account.</p> <pre><code>(def schema-accounts-table\n[\"CREATE TABLE PUBLIC.ACCOUNTS(\n     ACCOUNT_ID UUID(16) NOT NULL,\n     ACCOUNT_NUMBER INTEGER NOT NULL AUTO_INCREMENT,\n     ACCOUNT_SORT_CODE VARCHAR(6),\n     ACCOUNT_NAME VARCHAR(32),\n     CURRENT_BALANCE VARCHAR(255),\n     LAST_UPDATED DATE,\n     ACCOUNT_HOLDER_ID VARCHAR(100) NOT NULL,\n     CONSTRAINT ACCOUNTS_PK PRIMARY KEY (ACCOUNT_ID))\"] )\n</code></pre>"},{"location":"projects/banking-on-clojure/database-tables/#define-transaction_history-table","title":"Define <code>TRANSACTION_HISTORY</code> table","text":"<p>Define the SQL statement to create the <code>ACCOUNTS</code></p> <p>All transactions include a value of the transaction, a reference to explain the purpose of the transaction, a date the transaction occurred, the account the transaction comes from and the account the transaction goes to.</p> <pre><code>(def schema-transaction-history-table\n[\"CREATE TABLE PUBLIC.TRANSACTION_HISTORY(\n     TRANSACTION_ID UUID(16) NOT NULL,\n     TRANSACTION_VALUE INTEGER NOT NULL,\n     TRANSACTION_REFERENCE VARCHAR(32),\n     TRANSACTION_DATE DATE,\n     ACCOUNT_FROM INTEGER,\n     ACCOUNT_TO INTEGER,\n     CONSTRAINT TRANSACTION_HISTORY_PK PRIMARY KEY (TRANSACTION_ID))\"])\n</code></pre> <p>Constraint Naming</p> <p>Constraints are used to add Primary Keys to database tables.  Each constraint needs an identifier which is included in error reporting when there are issues.  It is recommended to use meaningful names for identifiers to trace the source of errors and also support maintenance of the overall database design.</p>"},{"location":"projects/banking-on-clojure/database-tables/#execute-table-schema-in-the-development-database","title":"Execute Table schema in the development database","text":"<p>Define a function to use the table creation SQL statements and execute them on the given database.</p> <p>The function uses <code>with-open</code> to create and manage a connection, closing that connection when the function has completed.</p> <pre><code>(defn create-table\n\"Establish a connection to the data source and create a table within a transaction.\n  Close the database connection.\n  Arguments:\n  - table-schemas: a vector containing an sql statements to create a table\"\n[table-schema data-spec]\n(with-open [connection (jdbc/get-connection data-spec)]\n(jdbc/execute! connection  table-schemas)))\n</code></pre> <p><code>with-open</code> - managing resources</p> <p><code>with-open</code> ensures that resources get closed and clearly defines the scope of the using the resource.</p> <p>This helps the developer avoid using Clojure\u2019s lazy sequences in a with-open block.  Within the scope of the <code>with-open</code> expression it is important to make sure that the result is eagerly evaluated to avoid accessing the resource after it\u2019s closed, or fall foul of the \"ResultSet closed\" or \"transaction closed\" errors.</p> <p>Refactor the function to execute all the SQL statements in a transaction, so either all the databases are created or none are.</p> <p>Using transactions can help prevent databases becoming in an inconsistent state due to only partial completion of a set of SQL statements.</p> <pre><code>(defn create-tables\n\"Establish a connection to the data source and create all tables within a transaction.\n  Close the database connection.\n  Arguments:\n  - table-schemas: a vector of sql statements, each creating a table\"\n[table-schemas data-spec]\n(with-open [connection (jdbc/get-connection data-spec)]\n(jdbc/with-transaction [transaction connection]\n(doseq [sql-statement table-schemas]\n(jdbc/execute! transaction sql-statement) ))))\n</code></pre> <p>Refactor for connection pools</p> <p><code>with-open</code> function can be removed from the <code>create-tables</code> function when using a connection pool, passing the existing connection from the pool to the <code>jdbc/with-transaction</code> function.</p> <p>Calling the <code>create-tables</code> function will create the database tables in the development database.</p> <p>The H2 database writes the tables to disk in the <code>banking-on-clojure.mv.db</code> file.  Unless the table is dropped, there is no need to evaluate this function again.</p>"},{"location":"projects/banking-on-clojure/database-tables/#viewing-tables-in-the-database","title":"Viewing tables in the database","text":"<pre><code>(defn information-tables\n[data-source]\n(jdbc/execute!\ndata-source\n[\"select * from information_schema.tables\"])\n</code></pre> <p>Create a helper function to show the schema of any particular table.  The function takes a table name and using <code>str</code> to combine table name with the rest of the SQL statement.</p> <pre><code>(defn show-schema\n[table-name]\n(jdbc/execute!\ndata-source\n[(str \"show columns from \" table-name)]))\n</code></pre> <p>A specific schema can be viewed by calling the <code>show-schema</code> function</p> <pre><code>(show-schema \"accounts\")\n</code></pre> <p>Refactor the <code>show-schema</code> function to take the data source as an argument as well as the table name.  The function is then usable for development, staging and production data sources (although its not generally advisable to update production database from a REPL in the development environment once its live)</p> <pre><code>(defn show-schema\n[data-source table-name]\n(jdbc/execute! data-source [(str \"show columns from \" table-name)]))\n</code></pre> <p>The connection is not manged though, so refactor again and add the <code>with-open</code> command to ensure the connection is closed once the function has finished.</p> <pre><code>(defn show-schema\n[db-spec table-name]\n(with-open [connection (jdbc/get-connection db-spec)]\n(jdbc/execute! connection [(str \"SHOW COLUMNS FROM \" table-name)])))\n</code></pre>"},{"location":"projects/banking-on-clojure/database-tables/#removing-dropping-database-tables","title":"Removing (dropping) database tables","text":"<p>A helper function for removing tables from the database, dropping the data and the schema of the table.</p> <p><code>drop-table</code> function only differs from the show-schema function in the specific SQL statement it uses.</p> <pre><code>(defn drop-table\n[db-spec table-name]\n(with-open [connection (jdbc/get-datasource db-spec)]\n(jdbc/execute! connection [(str \"DROP TABLE \" table-name)])))\n</code></pre> <p>A generic helper function could be used if the SQL statement were also an argument.</p>"},{"location":"projects/banking-on-clojure/database-tables/#managing-database-tables-from-the-repl","title":"Managing database tables from the REPL","text":"<p>When designing the database schema it can be useful to iterate quickly around the design.  Using a Rich Comment Block to hold expressions to create show and drop tables is an effective way to manage the database schema quickly.</p> <pre><code>(comment  ;; Managing Schemas\n;; Create all tables in the development database\n(create-tables [schema-account-holders-table schema-accounts-table schema-transaction-history-table]\ndb-specification-dev)\n;; View application table schema in development database\n(show-schema data-source-dev \"PUBLIC.ACCOUNT_HOLDERS\")\n(show-schema data-source-dev \"PUBLIC.ACCOUNTS\")\n(show-schema data-source-dev \"PUBLIC.TRANSACTION_HISTORY\")\n;; View database system schema in development database\n(show-schema data-source-dev \"INFORMATION_SCHEMA.TABLES\")\n;; Remove tables from the development database\n(drop-table data-source-dev \"PUBLIC.ACCOUNT_HOLDERS\")\n(drop-table data-source-dev \"PUBLIC.ACCOUNTS\")\n(drop-table data-source-dev \"PUBLIC.TRANSACTION_HISTORY\"))\n</code></pre> <p>Manage database schema with Migratus</p> <p>Migratus provides an elegant approach to evolving database schema</p> <p>Common errors</p> <p><code>Syntax error in SQL statement</code> can occur if the SQL statement is not correct, the most common cause is a missing comma.</p> <p>Databases do not always support exactly the same SQL syntax, especially around types and more advanced features.  SQL statements may not work exactly the same for each database.  Using tools like DBever will generated SQL expressions for specific databases.</p>"},{"location":"projects/banking-on-clojure/delete-records/","title":"Delete Records in the database","text":"<p>Using <code>next.jdbc.sql</code> functions provides a Clojure data structures approach, where as <code>next.jdbc/execute!</code> uses specific SQL statement code.</p> <p>{% tabs clojure=\"next.jdbc.sql functions\", sql=\"next.jdbc/execute!\"  %}</p> <p>{% content \"clojure\" %}</p>"},{"location":"projects/banking-on-clojure/delete-records/#generic-delete-record-function","title":"Generic delete record function","text":"<p>Use the generic delete function from the database schema design section</p> <pre><code>(defn delete-record\n\"Insert a single record into the database using a managed connection.\n  Arguments:\n  - table - name of database table to be affected\n  - record-data - Clojure data representing a new record\n  - db-spec - database specification to establish a connection\"\n[db-spec table where-clause]\n(with-open [connection (jdbc/get-connection db-spec)]\n(jdbc-sql/delete! connection table where-clause)))\n</code></pre>"},{"location":"projects/banking-on-clojure/delete-records/#delete-an-existing-account_holder-record","title":"Delete an existing account_holder record","text":"<p>Call the <code>delete-record</code> function with the development database specification, the table name and a where clause to locate the specific record to delete.  This where clause should use a unique value, e.g. the primary key for the table.</p> <pre><code>  (delete-record db-specification-dev :public.account_holders {:account_holder_id \"0bed6afe-6740-46a1-b924-36ef192eac66\"})\n</code></pre> <p>If the record deletion is successful then <code>:update-count 1</code> value is returned</p> <pre><code>  ;; =&gt; #:next.jdbc{:update-count 1}\n</code></pre>"},{"location":"projects/banking-on-clojure/delete-records/#deleting-an-existing-account-record","title":"Deleting an existing account record","text":"<p>Update an existing record in the <code>public.accounts</code> table, providing new values for <code>current_balance</code> and <code>last_updated</code> columns.</p> <pre><code>(delete-record db-specification-dev :public.accounts {:account_number \"1234567890\"})\n</code></pre>"},{"location":"projects/banking-on-clojure/delete-records/#deleting-an-existing-transaction-record","title":"Deleting an existing transaction record","text":"<p>Update an existing record in the <code>public.transaction_history</code> table.</p> <pre><code>(delete-record db-specification-dev :public.transaction_history {:transaction_id  \"8ac89cfc-6874-4ebe-9ee4-59b8c5e971ff\"})\n</code></pre> <p>{% content \"sql\" %}</p>"},{"location":"projects/banking-on-clojure/delete-records/#insert-account_holders","title":"Insert account_holders","text":""},{"location":"projects/banking-on-clojure/delete-records/#insert-accounts","title":"Insert accounts","text":""},{"location":"projects/banking-on-clojure/delete-records/#insert-transactions","title":"Insert transactions","text":"<p>{% endtabs %}</p>"},{"location":"projects/banking-on-clojure/delete-records/#hintgenerating-example-data-from-clojure-spec","title":"Hint::Generating example data from Clojure Spec","text":"<p>Clojure Spec: generate mock database data</p>"},{"location":"projects/banking-on-clojure/deployment-pipeline/","title":"Deployment Pipeline Approach","text":"<p>Using the Heroku Application platform cloud simplifies the deployment of the Clojure web application.</p>"},{"location":"projects/banking-on-clojure/deployment-pipeline/#12-factor-approach","title":"12 Factor approach","text":"<p>Following the 12 factor principles, the deployment is driven by source code to multiple environments.</p> <p></p>"},{"location":"projects/banking-on-clojure/deployment-pipeline/#heroku-pipelines","title":"Heroku pipelines","text":"<p>Using Heroku Pipelines the staging environment is promoted to production rather than being rebuilt</p> <p></p> <p>The Heroku dashboard can be used to promote the application into production, once the staging application is signed off.</p> <p></p>"},{"location":"projects/banking-on-clojure/deployment-pipeline/#heroku-build-process","title":"Heroku Build process","text":"<p>The build process starts when commits are pushed to Heroku, either directly or via a continuous integration service (eg. CircleCI).</p> <p></p>"},{"location":"projects/banking-on-clojure/deployment-via-ci/","title":"Deployment via Continuous Integration","text":"<p>Deployment will be via a workflow to the CircleCI configuration that deploys the application to a staging environment on successful completion of running all tests in the project.  Once the staging application is approved, the application build can be promoted to production.</p> <p></p>"},{"location":"projects/banking-on-clojure/deployment-via-ci/#add-heroku-orb-to-circleci-configuration","title":"Add Heroku orb to CircleCI configuration","text":"<p>Edit <code>.circleci/config.yml</code> and add the heroku orb and a workflow to Heroku.  The workflow has a dependency on the build job, so that will take place first.</p> <p>The Heroku workflow will build the application from source code using the <code>heroku/deploy-via-git</code>.  Only changes pushed to the <code>live</code> branch of the GitHub repository will be used in the Heroku deploy workflow.</p> <pre><code>version: 2.1  # circleci configuration version\norbs:\nkaocha: lambdaisland/kaocha@0.0.1 # Org settings &gt; Security &gt; uncertified orbs\nheroku: circleci/heroku@1.2.6 # Invoke the Heroku orb\nworkflows:\nheroku_deploy:\njobs:\n- build\n- heroku/deploy-via-git: # Use the pre-configured job, deploy-via-git\nrequires:\n- build\nfilters:\nbranches:\nonly: live\njobs:    # basic units of work in a run\nbuild: # runs not using Workflows must have a `build` job as entry point\nworking_directory: ~/build # directory where steps will run\ndocker:                                                      # run the steps with Docker\n- image: circleci/clojure:openjdk-11-tools-deps-1.10.1.727 # image is primary container where `steps` are run\nenvironment:            # environment variables for primary container\nJVM_OPTS: -Xmx3200m   # limit the maximum heap size to prevent out of memory errors\nsteps:             # commands that comprise the `build` job\n- checkout       # check out source code to working directory\n- restore_cache: # restores saved cache if checksum hasn't changed since the last run\nkey: banking-on-clojure-webapp-{{ checksum \"deps.edn\" }}\n- run: clojure -R:test:runner -Spath\n- save_cache:    # generate and store cache in the .m2 directory using a key template\npaths:\n- ~/.m2\n- ~/.gitlibs\nkey: banking-on-clojure-webapp-{{ checksum \"deps.edn\" }}\n- run: bin/kaocha --reporter kaocha.report/documentation --no-randomize --no-color --plugin kaocha.plugin.alpha/spec-test-check\n</code></pre>"},{"location":"projects/banking-on-clojure/deployment-via-ci/#add-depstar-to-build-an-uberjar","title":"Add depstar to build an uberjar","text":"<p>The depstar tool creates a Java archive (jar) package of the application.  The <code>deps.edn</code> configuration in the root of the project already contains an <code>uberjar</code> alias for this tool.</p> <p>Check the project builds the uberjar locally:</p> <pre><code>clojure -X:project/uberjar\n</code></pre> <p>This will be the same command used in the build script</p>"},{"location":"projects/banking-on-clojure/deployment-via-ci/#create-a-custom-build-behaviour","title":"Create a custom build behaviour","text":"<p>Heroku build scripts use Leiningen by default.  Configure Heroku to build with Clojure Tools, create a custom build file which will run instead of Leiningen.</p> <p>Create a file called <code>bin/build</code> script in the root of the project</p> <pre><code>#!/usr/bin/env bash\nclojure -X:project/uberjar\n</code></pre> <p>Create an empty <code>project.clj</code> file so that Heroku recognized the project as Clojure.</p>"},{"location":"projects/banking-on-clojure/deployment-via-ci/#define-how-to-run-the-application","title":"Define how to run the application","text":"<p>Create a <code>Procfile</code> file in the root of the project directory containing the command to run the application.</p> <p>Use the <code>$PORT</code> as an argument to the command.  Heroku automatically assigns a port number for an application to listen upon when creating a contain in which the application will run.  This port number is set using the <code>PORT</code> environment variable and is available to the application on startup.  Using the PORT environment variable ensures the Clojure application will receive requests.</p> <pre><code>web: java -jar banking-on-clojure.jar $PORT\n</code></pre>"},{"location":"projects/banking-on-clojure/deployment-via-ci/#specifying-a-java-version","title":"Specifying a Java version","text":"<p>Create a <code>system.properties</code> and specify the Java version to use for the application. Java 1.8 is the default version use on Heroku, however, our development environment is Java 11, so add a property to set the Java runtime to version 11.</p> <pre><code>java.runtime.version=17\n</code></pre>"},{"location":"projects/banking-on-clojure/deployment-via-ci/#circleci-environment-variables","title":"CircleCI Environment Variables","text":"<p>Open the CircleCI and select project settings &gt; Environment Variables</p> <p>Add environment variables to define where the Heroku application can be found and a token to provide access.</p> Environment Variable Value <code>HEROKU_API_KEY</code> name of the application created on Heroku <code>HEROKU_APP_NAME</code> API key found in Account Settings &gt; API Key"},{"location":"projects/banking-on-clojure/deployment-via-ci/#heroku-pipeline-configuration","title":"Heroku Pipeline configuration","text":"<p>Login to the Heroku dashboard and create a new pipeline called <code>banking-on-clojure-webapp</code></p> <p>In the Heroku dashboard, open the application Settings and add a Config Vars using the name <code>CLOJURE_CLI_VERSION</code> with a value of <code>1.10.1.727</code></p> <p></p> <p>Using Heroku Pipelines the staging environment is promoted to production rather than being rebuilt</p> <p></p> <p>The Heroku dashboard can be used to promote the application into production, once the staging application is signed off.</p> <p></p>"},{"location":"projects/banking-on-clojure/deployment-via-ci/#push-changes-to-trigger-build","title":"Push changes to trigger build","text":"<p>Commit the changes and push them to the GitHub repository.</p> <pre><code>git push heroku live:main\n</code></pre> <p>Heroku only deploys code pushed to the main (or master) branch of the remote. Pushing code to another branch of the heroku remote has no effect. Using the <code>live:local</code> form will push the local <code>live</code> branch to the remote <code>main</code> branch on Heroku.</p> <p>This triggers a build by CircleCI.  The build downloads the dependencies and runs the unit tests.  If the tests pass, then the Heroku deploy workflow starts.</p> <p>The two stages can be seen in the dashboard as the pipeline runs.</p> <p></p> <p>Now visit the deployed Heroku application to see it in action.</p>"},{"location":"projects/banking-on-clojure/deployment-via-ci/#troubleshooting","title":"Troubleshooting","text":"<p>If there are issues, then use the Heroku toolbelt to look at the logs.  In a command line terminal, issue the login command which opens a web browser to login to Heroku.  Once logged in, run the heroku logs command to view the latest logs</p> <pre><code>heroku login\n\nheroku logs --app banking-on-clojure\n</code></pre> <p>The logs can also be viewed live, as the application is being deployed by including the <code>--tail</code> option when running the heroku logs command in a terminal</p> <pre><code>heroku logs --app banking-on-clojure --tail\n</code></pre> <p>The example Heroku logs show that the banking-on-clojure is using the default port number if non is supplied as an argument, rather than Heroku assigned port.  Heroku therefore considers the application as unresponsive and sets it status to crashed, tearing down the container the application is running in.</p> <p>These logs were generated before adding the <code>$PORT</code> to the command in the <code>Procfile</code>.</p> <p></p>"},{"location":"projects/banking-on-clojure/deployment-via-ci/#no-forced-pushes","title":"No forced pushes","text":"<p>Heroku doesn't like force Git pushes coming via CircleCI.</p> <p></p> <p>To get around this, either don't do force pushes to GitHub, or add the Heroku repository for the project as a remote to local git repository.</p> <p>Heroku repository details in heroku dashboard Settings under App Information</p> <p>Changes can now be pushed, ideally using <code>force-with-lease</code> to Heroku repository.</p>"},{"location":"projects/banking-on-clojure/deployment-via-ci/#stopping-the-application","title":"Stopping the application","text":"<p>An application can be run for free on Heroku with the monthly free credits provided.  However, to make the most out of these free credits then applications not in use should be shut down</p> <p>Run the following command in the root of the Clojure project.</p> <pre><code>heroku ps:stop banking-on-clojure\n</code></pre>"},{"location":"projects/banking-on-clojure/development-database/","title":"Provision the development database","text":"<p>To keep the development environment self-contained the H2 in-memory database will be used for development of the application.  Postgresql database will be used for testing and live environments hosted in the Cloud.</p>"},{"location":"projects/banking-on-clojure/development-database/#add-h2-database-library-dependency","title":"Add H2 database library dependency","text":"<p>Edit the <code>deps.edn</code> file in the root of the project directory. In the <code>:deps</code> hash-map, add next.jdbc library as a main dependency.</p> <p>As the H2 database is only used for development create a <code>:dev</code> alias include an <code>:extra-deps</code> section for the H2 driver</p> <pre><code>{:deps\n{org.clojure/clojure        {:mvn/version \"1.10.1\"}\norg.seancorfield/next.jdbc {:mvn/version \"1.1.569\"}}}\n{:aliases\n{:dev\n{:extra-deps {com.h2database/h2 {:mvn/version \"1.4.200\"}}}}}\n</code></pre>"},{"location":"projects/banking-on-clojure/development-database/#create-a-namespace-for-database-access","title":"Create a namespace for database access","text":"<p>Create a new file in the project called <code>src/practicalli/database-access.clj</code> which will contain the code for accessing the database.</p> <p>Require the next.jdbc namespace using the <code>jdbc</code> alias.</p> <pre><code>(ns practicalli.database-access\n(:require [next.jdbc :as jdbc]))\n</code></pre> <p>next.jdbc will use the database specification to look up the driver namespace for the specific database.  Therefore the database driver namespaces do not need to be explicitly required in the namepace.</p>"},{"location":"projects/banking-on-clojure/development-database/#specifying-the-database-and-connection","title":"Specifying the database and connection","text":"<p>H2 in-memory database is used as a self-contained database, providing a simple way to start evaluating the schema and queries as they are designed.</p> <p>Use next.jdbc library to define a database specification, represented as a map.  For the H2 database only the database type and database name are required. No roles or credentials are used to access the database as it is only running locally.</p> <p>Use the database specification to create a connection</p> <pre><code>;; Database specification and connection\n;; Development environment\n;; H2 in-memory database\n(def db-specification-dev {:dbtype \"h2\" :dbname \"banking-on-clojure\"})\n;; Database connection\n(def data-source-dev (jdbc/get-datasource db-specification-dev))\n</code></pre> <p>The database specification is used to create a database connection.  A general name can be used here as only one database will be used for one environment.</p> <p>Aero for multiple environment configuration</p> <p>juxt/aero is a library for managing configurations across multiple environments in a single EDN file.  aero can be used to hold the details of each database specification for every environment (dev, staging, live).</p> <p><code>(read-config (clojure.java.io/resource \"config.edn\"))</code> with the configuration file in the resources directory of the classpath.  This is accessible from the Jar and the REPL.</p>"},{"location":"projects/banking-on-clojure/development-database/#using-connections-effectively","title":"Using connections effectively","text":"<p>Use the <code>with-open</code> function to manage the database connections and ensure the connects are closed after the sql queries complete.</p> <pre><code>(with-open [connection (jdbc/get-connection data-source-dev)]\n(jdbc/execute! connection [\"SQL statement\"]))\n</code></pre> <p>When multiple SQL queries should be run together, the <code>with-open</code> function enables reuse of the connection and ensure the connection is cleaned up once the SQL statements are complete.</p> <pre><code>(with-open [connection (jdbc/get-connection data-source-dev)]\n(jdbc/execute! connection [\"SQL statement\"])\n(reduce my-fn init-value (jdbc/plan connection [\"SQL statement\"]))\n(jdbc/execute! connection [\"SQL statement\"]))\n</code></pre> <p>Close JDBC Connections</p> <p><code>next.jdbc</code> uses raw Java JDBC types so it is important to close connections to avoid issues.</p>"},{"location":"projects/banking-on-clojure/generate-data-from-specs/","title":"Generate Data Using Clojure Spec","text":"<p>Test data to populate the database can be generated using the specifications previously defined using Clojure Spec.</p>"},{"location":"projects/banking-on-clojure/honeysql/","title":"HoneySQL","text":"<p>HoneySQL is a library for writing SQL as Clojure data structures to programmatically query databases (develop and runtime) without string bashing.</p>"},{"location":"projects/banking-on-clojure/honeysql/#todowork-in-progress-sorry","title":"TODO::work in progress, sorry","text":""},{"location":"projects/banking-on-clojure/instrument-next-jdbc-functions/","title":"clojure.spec: Instrument next.jdbc functions","text":"<p>Clojure specifications are available for all <code>next.jdbc</code> functions contained in namespaces <code>next.jdbc</code>, <code>next.jdbc.connection</code>, <code>next.jdbc.prepare</code>, and <code>next.jdbc.sql</code>.</p> <p>Instrumenting the functions with their specifications will check the arguments passed to a function conform to the appropriate specification.  If the arguments conform, the next.jdbc function will evaluate with those arguments.  If the arguments do not conform, then an error is returned.</p> <p>Instrumenting specifications provided additional details when errors occur, helping diagnose the issue quickly.</p>"},{"location":"projects/banking-on-clojure/instrument-next-jdbc-functions/#require-the-nextjdbc-specifications","title":"Require the next.jdbc specifications","text":"<p>Require the <code>next.jdbc.specs</code> namespace in the project, typically in the namespace where <code>next.jdbc</code> is also required.</p> <pre><code>(ns practicalli.database-access\n(:require\n[next.jdbc :as jdbc]\n[next.jdbc.specs :as jdbc-spec]))\n</code></pre> <p>In a Rich Comment block, call the <code>instrument</code> function from <code>next.jdbc.specs</code> namespace.  This will instrument the specifications for all functions across all the next.jdbc namespaces.</p> <p><pre><code>(comment\n(jdbc-spec/instrument)\n)\n</code></pre> Instrumented functions are typically used during development, not in staging or production.  Only calling <code>instrument</code> manually from a rich comment block ensures the developer controls when functions are instrumented.</p>"},{"location":"projects/banking-on-clojure/instrument-next-jdbc-functions/#runtime-checking","title":"Runtime checking","text":"<p>With instrumentation enabled, any calls to <code>next.jdbc</code> functions will have the arguments checked to ensure they conform to the specification.</p> <p>For example, the instrumented <code>execute!</code> function will generate an error if passed an SQL statement as a string, rather than a vector containing a string.</p> <pre><code>(jdbc/execute! data-source \"SELECT * FROM account_holders\")\nCall to #'next.jdbc/execute! did not conform to spec.\n</code></pre> <p>The <code>:problems</code> section of the instrumented function error includes the <code>:path [:sql :sql-params]</code> and <code>:pred vector?</code> for the <code>:val \"SELECT * FROM account_holders\"</code>.</p> <p>Without the instrumented specification,  assistance, the less helpful error message <code>ClassCastException</code> is the only assistance when debugging the issue.</p> <p>Example from Banking on Clojure </p>"},{"location":"projects/banking-on-clojure/instrument-next-jdbc-functions/#turning-off-instrumentation-for-nextjdbc","title":"Turning off instrumentation for next.jdbc","text":"<p><code>unstrument</code> function removes the instrumentation from the functions.  Typically this is called from a rich comment block too, as its not common to run instrumented functions outside of the development environment.</p> <pre><code>(comment\n(jdbc-spec/instrument)\n(jdbc-spec/unstrument)\n)\n</code></pre>"},{"location":"projects/banking-on-clojure/namespace-design/","title":"Namespace design","text":"<p>A common approach to namespace design is to start with the main namespace for the application and migrate code to new namespaces as the codebase grows.</p>"},{"location":"projects/banking-on-clojure/namespace-design/#basic-principles","title":"Basic Principles","text":"<p>Basic principles of namespace design include</p> <ul> <li>focus namespaces on specific logical areas of the application</li> <li>avoid circular references between namespaces (i.e. two namespaces require each other)</li> <li>abstract code into namespaces to avoid the uber-namespace  (unless the application fits into ~100 lines of code)</li> <li>require the minimum number of namespaces</li> <li>use meaningful names for namespace aliases (if naming is hard, think again about splitting a namespace)</li> <li>use comment sections to separate code into logical groupings as its developed, highlighting potential sections of code that could split into its own namespace.</li> </ul>"},{"location":"projects/banking-on-clojure/namespace-design/#example-web-application-namespace-design","title":"Example web application namespace design","text":"<p>A general design that forms the basis of many web application projects</p> <p></p>"},{"location":"projects/banking-on-clojure/namespace-design/#main-application-namespace","title":"Main application namespace","text":"<p>The main application namespace is typically used for code that manages the system, for example starting the application server, database, etc.  These services are often managed by component lifecycle services (mount, integrant, component).</p> <p>Routing is usually a part of the  main application namespace, especially when there are a modest number of routes and a routing library such as compojure is used.  If routing becomes more extensive, then a separate routing namespace is warranted.</p>"},{"location":"projects/banking-on-clojure/namespace-design/#handlers-and-custom-middleware","title":"Handlers and custom middleware","text":"<p>Handlers define the business logic, data and presentation that turns requests into responses.  Start with a single namespace for handlers and segregate if the complexity grows sufficiently.</p> <p>Middleware used directly with handlers is required in the handler namespace.</p> <p>Middleware for the overall system may appear in the main application namespace, to wrap the application instance.</p>"},{"location":"projects/banking-on-clojure/namespace-design/#ui-pages-and-templates","title":"UI pages and templates","text":"<p>Avoid adding complexity to the handlers by moving common web page / html generation code to its own namespace.</p> <p>A single namespace provides a focused view for refactoring presentation code into templates and generators.</p>"},{"location":"projects/banking-on-clojure/namespace-design/#data-queries","title":"Data queries","text":"<p>A namespace to design all the queries for a data source, which could be database, api's, file systems, etc.</p> <p>SQL queries to relational database are defined here.</p>"},{"location":"projects/banking-on-clojure/namespace-design/#data-sources","title":"Data sources","text":"<p>Details of data sources, from databases, api's or any sources of information to be processed.</p>"},{"location":"projects/banking-on-clojure/production-database/","title":"Production Database - Heroku Postgres","text":"<p>Heroku provides a on-demand PostgreSQL service with very good support tooling.  The Hobby plan is free to use with a free Heroku account (no credit card needed).</p> <p>PostgreSQL provides a production grade relational database with support for JSON an other common data types.  As its such a feature rich database</p> <p>PostgreSQL instance runs outside the application code (unlike H2 database).</p>"},{"location":"projects/banking-on-clojure/production-database/#provision-a-database","title":"Provision a database","text":"<p>Login to Heroku using your free account.</p> <p>Two Heroku apps have already been created for the banking on Clojure project pipeline, staging and live, so a database should be provisioned for both apps.</p> <p></p> <p>Select the staging app from the pipeline dashboard.</p> <p></p> <p>In the Overview section, click Configure Add-ons</p> <p></p> <p>Start typing Postgres in the Add-ons text box to see the matching add-ons available.  Select Heroku Postgres.</p> <p></p> <p>Select the Hobby plan in the pop-up window.  The Hobby plan is free and limited to 10,000 rows.  The plan can be upgraded ones the app starts making money (or funding is raised).</p> <p></p> <p>The Postgres database is immediately provisioned and available for use.</p> <p></p>"},{"location":"projects/banking-on-clojure/production-database/#database-configuration-on-heroku","title":"Database Configuration on Heroku","text":"<p>Provisioning an Heroku postgres database adds a <code>DATABASE_URL</code> Config Var (Heroku Environment Variable) to the application the database is attached to.</p> <p>In the Heroku dashboard, view the Settings and  select Show Config Vars</p> <p></p> <p>Click on the pencil icon to see the full connection string, which takes the following form:</p> <pre><code>postgres://username:password@host:port/database-name\n</code></pre> <p>This is not a correct JDBC connection string, but it can be used to generate one.</p>"},{"location":"projects/banking-on-clojure/production-database/#generate-the-jdbc-connection","title":"Generate the JDBC connection","text":"<p>Use the Heroku CLI tool to get the JDBC connection string for the database.</p> <p>For the Banking on Clojure app, the following</p> <pre><code>heroku run echo \\$JDBC_DATABASE_URL --app banking-on-clojure-staging\n</code></pre> <p>This returns the correct JDBC connection string in the form:</p> <pre><code>\"jdbc:postgresql://&lt;hostname&gt;:port/&lt;database-name&gt;?user=&lt;username&gt;&amp;password=&lt;password&gt;&amp;sslmode=require\"\n</code></pre> <p>This jdbc connection string is generated from the <code>DATABASE_URL</code> config var that is added to the heroku app when a database is provisioned.</p> <p>There are several applications attached to the Git repository, so its required to specify which application to run. The <code>run</code> command runs a container for the app, a Linux system that has the database attached.  Once the <code>echo</code> command is complete the container is shut down and discarded automatically.</p>"},{"location":"projects/banking-on-clojure/production-database/#viewing-the-database-details-on-heroku-dashboard","title":"Viewing the database details on Heroku dashboard","text":"<p>This will switch over to the data.heroku.com website, so you may be prompted to login again.</p> <p></p>"},{"location":"projects/banking-on-clojure/production-database/#adding-postgresql-driver-to-clojure-project","title":"Adding Postgresql driver to Clojure project","text":"<p>Add the latest postgresql jdbc driver to the <code>deps.edn</code> file in the banking on clojure project</p> <pre><code> :deps\n{org.clojure/clojure {:mvn/version \"1.10.1\"}\n;; Web Application\nhttp-kit        {:mvn/version \"2.3.0\"}\nring/ring-core  {:mvn/version \"1.8.1\"}\nring/ring-devel {:mvn/version \"1.8.1\"}\ncompojure       {:mvn/version \"1.6.1\"}\nhiccup          {:mvn/version \"2.0.0-alpha2\"}\n;; Database\norg.seancorfield/next.jdbc    {:mvn/version \"1.1.569\"}\ncom.h2database/h2         {:mvn/version \"1.4.200\"}\norg.postgresql/postgresql {:mvn/version \"42.2.16\"}}\n</code></pre> <p>The Postgresql jdbc driver library will be used by next.jdbc</p>"},{"location":"projects/banking-on-clojure/production-database/#creating-a-staging-data-source","title":"Creating a staging data source","text":"<p>Add a <code>JDBC_DATABASE_URL</code> environment variable to hold the JDBC connection string to the Heroku database</p> <pre><code>(def data-source-postgresql\n(jdbc/get-datasource (System/getenv \"JDBC_DATABASE_URL\")) )\n</code></pre> <p>Now the same SQL queries created for the H2 database can be tested on with PostgreSQL.</p>"},{"location":"projects/banking-on-clojure/production-database/#testing-queries-with-postgresql","title":"Testing queries with PostgreSQL","text":"<p>In practice is seems there are noticeable differences between H2 and PostgreSQL, especially in terms of schema definitions.</p> <p>For example, to create a table the table namespace should be supplied, in this case <code>public</code>.  The table creation syntax also as an IF clause, so if the database table already exists then the SQL statement does not try to create it and cause an error.</p> <pre><code>(jdbc/execute!\ndata-source-postgresql\n[\"CREATE TABLE IF NOT EXISTS public.account_holder (\n      user_id serial PRIMARY KEY,\n      username VARCHAR ( 50 ) UNIQUE NOT NULL,\n      password VARCHAR ( 50 ) NOT NULL,\n      email VARCHAR ( 255 ) UNIQUE NOT NULL,\n      created_on TIMESTAMP NOT NULL,\n      last_login TIMESTAMP\"])\n</code></pre> <p>The PostgreSQL syntax for creating tables is:</p> <pre><code>  CREATE TABLE [IF NOT EXISTS] table_name (\ncolumn1 datatype(length) column_constraint,\ncolumn2 datatype(length) column_constraint,\ncolumn3 datatype(length) column_constraint,\ntable_constraints);\n</code></pre>"},{"location":"projects/banking-on-clojure/production-database/#hintuse-dbeaver-to-generate-sql","title":"Hint::Use DBeaver to generate SQL","text":"<p>DBeaver is a free and comprehensive database tool that will generate SQL statements from database designs.</p>"},{"location":"projects/banking-on-clojure/production-database/#resources","title":"Resources","text":"<ul> <li>Heroku Postgres Credentials</li> <li>Heroku: Database Connection Pooling with Clojure</li> </ul>"},{"location":"projects/banking-on-clojure/read-records/","title":"Read Database Records","text":"<p>Using <code>next.jdbc.sql</code> functions provides a Clojure data structures approach, where as <code>next.jdbc/execute!</code> uses specific SQL statement code.</p>"},{"location":"projects/banking-on-clojure/read-records/#generic-read-record-function","title":"Generic read record function","text":"<p>Use the generic create function from the database schema design section</p> <pre><code>(defn read-record\n\"Insert a single record into the database using a managed connection.\n  Arguments:\n  - table - name of database table to be affected\n  - record-data - Clojure data representing a new record\n  - db-spec - database specification to establish a connection\"\n[db-spec sql-query]\n(with-open [connection (jdbc/get-connection db-spec)]\n(jdbc-sql/query connection sql-query)))\n</code></pre>"},{"location":"projects/banking-on-clojure/read-records/#read-account_holder-records","title":"Read account_holder records","text":"<p>Call the <code>read-record</code> function with the development database specification and a Clojure vector containing a string of the SQL select statement.</p> <p>Return all the records from a specific table</p> <pre><code>  (read-record db-specification-dev [\"select * from public.account_holders\"])\n</code></pre> <p>Return records that match a specific where clause</p> <pre><code>  (read-record db-specification-dev [\"select * from public.account_holders where first_name = ?\" \"Rachel\"])\n</code></pre>"},{"location":"projects/banking-on-clojure/read-records/#read-account-records","title":"Read account records","text":"<p>Create a new record in the <code>public.accounts</code> table.</p> <p>Return all the records from a specific table</p> <pre><code>  (read-record db-specification-dev [\"select * from public.accounts\"])\n</code></pre> <p>Return records that match a specific where clause</p> <pre><code>  (read-record db-specification-dev [\"select * from public.accounts where account_number = ?\" \"1234567890\"])\n</code></pre>"},{"location":"projects/banking-on-clojure/read-records/#read-transaction-history-records","title":"Read transaction history records","text":"<p>Create a record in the <code>public.transaction_history</code> table.</p> <pre><code>  (read-record db-specification-dev [\"select * from public.transaction_history\"])\n</code></pre> <p>Return records that match a specific where clause</p> <pre><code>  (read-record db-specification-dev [\"select * from public.transaction_history where transaction_date = ?\" \"2020-09-11\"])\n</code></pre> <p>Generating example data from Clojure Spec</p> <p>Clojure Spec: generate mock database data</p>"},{"location":"projects/banking-on-clojure/refactor-handler/","title":"Refactor to handlers namespace","text":"<p>Create a new namespace called <code>practicalli.banking-on-clojure.handler</code> which will contain handler functions for the routes to be defined in the application.</p> <p>Additional libraries will be used to create the responses, which will only be required in the new namespace.</p> <p>Create a new file called <code>src/practicalli/banking_on_clojure/handler.clj</code></p> <p>Move the <code>[ring.util.response :refer [response]]</code> require and the handler function from <code>src/practicalli/banking_on_clojure/service.clj</code> to <code>src/practicalli/banking_on_clojure/handler.clj</code></p> src/practicalli/banking_on_clojure/handler.clj<pre><code>(ns practicalli.banking-on-clojure.handler\n\"Handler functions to satisfy requests to the service\"\n(:require\n[ring.util.response :refer [response]]))\n</code></pre> src/practicalli/banking_on_clojure/handler.clj<pre><code>(defn welcome-page\n\"Main page layout for the service\"\n[request]\n(response \"Banking on Clojure\"))\n</code></pre> <p>Require the <code>practicalli.banking-on-clojure.handler</code> namespace in <code>practicalli.banking-on-clojure</code> namespace, using the alias <code>handler</code></p> src/practicalli/banking_on_clojure/service.clj<pre><code>(ns practicalli.banking-on-clojure\n(:gen-class)\n(:require [org.httpkit.server :as app-server]\n[compojure.core :refer [defroutes GET]]\n[ring.util.response :refer [response]]\n[practicalli.handler :as handler]))\n</code></pre> <p>Update the request routing code to use the new alias for handlers</p> src/practicalli/banking_on_clojure/service.clj<pre><code>(defroutes app\n(GET \"/\" [] handler/welcome-page))\n</code></pre> <p>Restart the server to pick up the changes</p> src/practicalli/banking_on_clojure/service.clj<pre><code>(app-server-restart \"8888\")\n</code></pre> <p>Check the server is still working by visiting http://localhost:8888/</p>"},{"location":"projects/banking-on-clojure/spec-generative-testing/","title":"Generative testing","text":"<p>Specifications define the shape of data used for the application.  The specifications are defined across two namespaces, general data specifications in <code>practicalli.specifications</code> and banking specific specs in the <code>practicalli.specifications-banking</code> namespace.</p> <p>Basic customer details</p> <pre><code>(spec/def ::first-name string?)\n(spec/def ::last-name string?)\n(spec/def ::email-address string?)\n;; residential address values\n(spec/def ::house-name-number (spec/or :string string?\n:number int?))\n(spec/def ::street-name string?)\n(spec/def ::post-code string?)\n(spec/def ::county string?)\n</code></pre> <p>countries of the world as a set, containing a string for each country defined in the practicalli.specifications namespace</p> <pre><code>(spec/def ::country :practicalli.specifications/countries-of-the-world)\n</code></pre> <pre><code>(spec/def ::residential-address (spec/keys :req [::house-name-number ::street-name ::post-code]\n:opt [::county ::country]))\n</code></pre> <pre><code>(spec/def ::social-security-id-uk string?)\n(spec/def ::social-security-id-usa string?)\n(spec/def ::social-security-id (spec/or ::social-security-id-uk\n::social-security-id-usa))\n</code></pre> <pre><code>;; composite customer details specification\n(spec/def ::customer-details\n(spec/keys\n:req [::first-name ::last-name ::email-address ::residential-address ::social-security-id]))\n</code></pre>"},{"location":"projects/banking-on-clojure/spec-generative-testing/#banking-data-specifications","title":"Banking data specifications","text":"<p>The <code>specifications-banking</code> sets the overall context for the specifications defined in the namespace.</p> <p><code>account-id</code> is a unique identification across all accounts in the bank.  The type of value used is a universally unique identifier (UUID) is a 128-bit number used to identify information in computer systems.  Clojure uses a #uuid tag literal</p> <pre><code>(spec/def ::account-id uuid?)\n;; Account holder - composite specification\n(spec/def ::account-holder\n(spec/keys\n:req [::account-id\n::first-name\n::last-name\n::email-address\n::residential-address\n::social-security-id]))\n</code></pre>"},{"location":"projects/banking-on-clojure/ui-handler-functions/","title":"UI Handler Functions","text":"<p>Taking an outside-in approach, the main parts of the website user interface will be created using Hiccup and Bulma CSS library.  Mock data will be used then wired up to the database as that is designed.</p> <p>Inside-out development</p> <p>When writing a web service for an existing database design, taking an inside-out approach may be more effective.</p> <p>An inside-out approach would include * generating Clojure Specifications for values from the database schema * define database access functions * defin handlers to expose values from the database, validated via specifications * define routes to interact with the values along business functions * create UI elements for use with the handlers to make a functioning and responsive application</p> <p>The following request handlers will be created for the banking-on-clojure application</p> <ul> <li>welcome-page</li> <li>register-account-holder</li> <li>accounts-overview-page</li> <li>account-history</li> <li>money-transfer</li> <li>money-payment</li> </ul> <p>All handlers are very similar to the welcome page, which highlights that some common template should be created for all handlers to use.</p> <p>The accounts-overview-page is the main page for the application, so will be designed in more detail.</p>"},{"location":"projects/banking-on-clojure/ui-handler-functions/#account-overview-page-handler","title":"account-overview-page handler","text":"<p>This is the page customers will view by default when logging in.</p> src/practicalli/banking_on_clojure/handlers.clj<pre><code>(defn accounts-overview-page\n\"Overview of each bank account owned by the current customer.\n  Using Bulma media object style\n  https://bulma.io/documentation/layout/media-object/\n  Request hash-map is not currently used\"\n[request]\n(response\n(html5\n{:lang \"en\"}\n[:head\n(include-css \"https://cdn.jsdelivr.net/npm/bulma@0.9.0/css/bulma.min.css\")]\n[:body\n[:section {:class \"hero is-info\"}\n[:div {:class \"hero-body\"}\n[:div {:class \"container\"}\n[:h1 {:class \"title\"} \"Banking on Clojure\"]\n[:p {:class \"subtitle\"}\n\"Making your money immutable\"]]]]\n[:section {:class \"section\"}\n(bank-account-media-object {:account-type  \"Current Account\" :account-number    \"123456789\"\n:account-value \"1,234\"           :account-sort-code \"01-02-01\"})\n(bank-account-media-object {:account-type  \"Savings Account\" :account-number    \"123454321\"\n:account-value \"2,000\"           :account-sort-code \"01-02-01\"})\n(bank-account-media-object {:account-type  \"Tax Free Savings Account\" :account-number    \"123454321\"\n:account-value \"20,000\"                   :account-sort-code \"01-02-01\"})\n(bank-account-media-object {:account-type  \"Mortgage Account\" :account-number    \"98r9e8r79wr87e9232\"\n:account-value \"354,000\"          :account-sort-code \"01-02-01\"})\n]])))\n</code></pre> <p>This handler uses a helper function to reduce the amount of hiccup code.</p> src/practicalli/banking_on_clojure/handlers.clj<pre><code>(defn bank-account-media-object\n[account-details]\n[:article {:class \"media\"}\n[:figure {:class \"media-left\"}\n[:p {:class \"image is-64x64\"}\n[:img {:src \"https://raw.githubusercontent.com/jr0cket/developer-guides/master/clojure/clojure-bank-coin.png\"}]]]\n[:div {:class \"media-content\"}\n[:div {:class \"content\"}\n[:h3 {:class \"subtitle\"}\n(str (:account-type account-details) \" : &amp;lambda;\" (:account-value account-details))]]\n[:div {:class \"field is-grouped\"}\n[:div {:class \"control\"}\n[:div {:class \"tags has-addons\"}\n[:span {:class \"tag\"} \"Account number\"]\n[:span {:class \"tag is-success is-light\"} (:account-number account-details)]]]\n[:div {:class \"tags has-addons\"}\n[:span {:class \"tag\"} \"Sort Code\"]\n[:span {:class \"tag is-success is-light\"} (:account-sort-code account-details)]]]]\n[:div {:class \"media-right\"}\n(link-to {:class \"button is-primary\"} \"/transfer\" \"Transfer\")\n(link-to {:class \"button is-info\"} \"/payment\" \"Payment\")]])\n</code></pre>"},{"location":"projects/banking-on-clojure/unit-testing-the-database/","title":"Unit Testing with the Database","text":""},{"location":"projects/banking-on-clojure/unit-testing-the-database/#unit-testing-using-clojure-spec","title":"Unit testing using clojure spec","text":"<p>Require the clojure.spec namespaces * <code>[clojure.spec.alpha :as spec]</code> for the core spec functions, including <code>gen</code> for specification generators * <code>[clojure.spec.gen.alpha :as spec-gen]</code> for generate and sample functions to generate values from specifications * <code>[clojure.spec.test.alpha :as spec-test]</code> for running check on instrumented function definitions * <code>[practicalli.specifications-banking]</code> for the banking related specifications</p> <pre><code>(ns practicalli.database-access-test\n(:require\n;; Unit testing\n[clojure.test :refer [deftest is testing]]\n;; Clojure Specifications\n[clojure.spec.alpha :as spec]\n[clojure.spec.test.alpha :as spec-test]\n[clojure.spec.gen.alpha :as spec-gen]\n[practicalli.specifications-banking]\n;; System under test\n[practicalli.database-access :as SUT])\n)\n</code></pre> <p>A simpler test to check that a map of generated values is returned when calling <code>new-account-holder</code></p> <pre><code>(deftest new-account-holder-test\n(testing \"Registered account holder is valid specification\"\n(is (map? (SUT/new-account-holder\n(spec-gen/generate\n(spec/gen :practicalli.specifications-banking/customer-details)))))))\n</code></pre> <p>This test alone will fail in a CI environment as the application does not create the database tables automatically</p>"},{"location":"projects/banking-on-clojure/unit-testing-the-database/#in-a-continuous-integration-environment","title":"In a continuous integration environment","text":"<p>A Continuous Integration environment will be empty to start with, so when using an embedded database the database and database tables need to be created each time the tests run.</p> <p>Creating the tables each time the tests are run could lead to errors if the database already has those tables defined</p> <p></p> <p>Add <code>IF NOT EXISTS</code> to the <code>CREATE TABLE</code> SQL statement so that the <code>create-tables!</code> function returns nil rather than an SQL error.</p> <pre><code>(def schema-account-holders-table\n[\"CREATE TABLE IF NOT EXISTS PUBLIC.ACCOUNT_HOLDERS(\n     ACCOUNT_HOLDER_ID UUID DEFAULT RANDOM_UUID() NOT NULL,\n     FIRST_NAME VARCHAR(32),\n     LAST_NAME VARCHAR(32),\n     EMAIL_ADDRESS VARCHAR(32) NOT NULL,\n     RESIDENTIAL_ADDRESS VARCHAR(255),\n     SOCIAL_SECURITY_NUMBER VARCHAR(32),\n     CONSTRAINT ACCOUNT_HOLDERS_PK PRIMARY KEY (ACCOUNT_HOLDER_ID))\"])\n</code></pre> <p>Longer term: Run migratus scripts to establish the database schema each time.</p>"},{"location":"projects/banking-on-clojure/unit-tests/","title":"Unit tests","text":"<p>In Clojure web applications the handler functions are the main focus of the unit tests.</p> <p>Create the file <code>test/practicalli/request-handler-test.clj</code> to contain the unit tests.</p> <p>Define the <code>request-handler-test</code> namespace, including other namespaces that should be required.</p> <p>The <code>ring.mock.request</code> library is added to simulate request calls to the handlers.</p> <pre><code>(ns practicalli.request-handler-test\n(:require [practicalli.request-handler :as SUT]\n[clojure.test :refer [deftest is testing]]\n[ring.mock.request :as mock]))\n</code></pre> <p>Add unit tests for each handler that will be created in <code>practicalli.request-handler</code>.</p> <p>A simple starting point for tests is to check the correct HTTP status code is being returned.</p> <p><code>ring.mock.request</code> library contains a <code>request</code> function that will generate a mock request hash-map from a given HTTP protocol (:get :post etc.) and a address.</p> <pre><code>(deftest welcome-page-test\n(testing \"Testing elements on the welcome page\"\n(is (= 200\n(:status (SUT/welcome-page (mock/request :get \"/\")))))))\n</code></pre>"},{"location":"projects/banking-on-clojure/unit-tests/#ensuring-a-status-code-in-handlers","title":"Ensuring a status code in handlers","text":"<p>The <code>ring.util.response</code> namespace is added to the <code>practicalli.request-handlers</code> namespace. This provide the <code>response</code> function which wraps the body (i.e. web page content) with a correctly formed response hash-map.</p> <pre><code>(response \"Web page content to be added to the response hash-map\")\n</code></pre> <p>The <code>practicalli.request-handlers</code> namespace definition</p> <pre><code>(ns practicalli.request-handler\n(:require [ring.util.response :refer [response]]\n[hiccup.core :refer [html]]\n[hiccup.page :refer [html5 include-js include-css]]\n[hiccup.element :refer [link-to]]))\n</code></pre> <p>The welcome page (<code>GET \"/\"</code>) content is defined with hiccup code to generate a HTML page (<code>html5</code>).  This content is wrapped by the <code>response</code> function to return a response hash-map.</p> <pre><code>(defn welcome-page\n[request]\n(response\n(html5\n{:lang \"en\"}\n[:head\n(include-css \"https://cdn.jsdelivr.net/npm/bulma@0.9.0/css/bulma.min.css\")]\n[:body\n[:section {:class \"hero is-info\"}\n[:div {:class \"hero-body\"}\n[:div {:class \"container\"}\n[:h1 {:class \"title\"} \"Banking on Clojure\"]\n[:p {:class \"subtitle\"}\n\"Making your money immutable\"]]]]\n[:section {:class \"section\"}\n[:div {:class \"container\"}\n(link-to {:class \"button is-primary\"} \"/accounts\"    \"Login\")\n(link-to {:class \"button is-danger\"}  \"/register\" \"Register\")\n[:p {:class \"content\"}\n\"Manage your money without unexpected side-effects using a simple made easy banking service\"]\n[:img {:src \"https://raw.githubusercontent.com/jr0cket/developer-guides/master/clojure/clojure-piggy-bank.png\"}]]]])))\n</code></pre>"},{"location":"projects/banking-on-clojure/unit-tests/#using-kaocha-to-run-tests","title":"Using Kaocha to run tests","text":"<p>Kaocha was added as part of the continuous integration configuration as a local binary.  This kaocha binary can be called to run the tests and check that all the handlers are returning the right status code.</p> <pre><code>bin/kaocha\n</code></pre> <p>kaocha should return the results of running all unit tests in the project.</p> <p>If a handler does not return the correct status code, then kaocha will highlight the error in the unit test results. </p> <p>kaocha will show a summary of the results when all the tests are successful.</p> <p></p>"},{"location":"projects/banking-on-clojure/update-records/","title":"Update Records in the database","text":"<p>Several options were explored when designing database query functions.  Using next.jdbc.sql functions provides a Clojure data structures approach, where as <code>next.jdbc/execute!</code> uses specific SQL statement code.</p> <p>Take the SQL approach if generating SQL statements directly.</p> <p>Take the Clojure approach if to generate SQL statements from Clojure data structures.</p>"},{"location":"projects/banking-on-clojure/update-records/#generic-update-record-function","title":"Generic update record function","text":"<p>Use the generic create function from the database schema design section</p> <pre><code>(defn update-record\n\"Insert a single record into the database using a managed connection.\n  Arguments:\n  - table - name of database table to be affected\n  - record-data - Clojure data representing a new record\n  - db-spec - database specification to establish a connection\n  - where-clause - column and value to identify a record to update\"\n[db-spec table record-data where-clause]\n(with-open [connection (jdbc/get-connection db-spec)]\n(jdbc-sql/update! connection table record-data where-clause)))\n</code></pre>"},{"location":"projects/banking-on-clojure/update-records/#update-an-existing-account_holder-record","title":"Update an existing account_holder record","text":"<p>Call the <code>update-record</code> function with the development database specification, the account holder table name and a Clojure hash-map of the record data.</p> <p>Each key in the map represents a column name and the value associated with the key is the value to be inserted in the record for its column.</p> <pre><code>  (update-record db-specification-dev\n:public.account_holders\n{:EMAIL_ADDRESS \"rachel+update@rockketpack.org\"}\n{:account_holder_id \"f6d6c3ba-c5cc-49de-8c85-21904f8c5b4d\"})\n</code></pre> <p>If the update is successful then <code>:update-count 1</code> value is returned</p> <pre><code>  ;; =&gt; #:next.jdbc{:update-count 1}\n</code></pre>"},{"location":"projects/banking-on-clojure/update-records/#update-an-existing-account-record","title":"Update an existing account record","text":"<p>Update an existing record in the <code>public.accounts</code> table, providing new values for <code>current_balance</code> and <code>last_updated</code> columns.</p> <pre><code>(update-record db-specification-dev\n\"public.accounts\"\n{:current_balance   242\n:last_updated      \"2020-09-12\"}\n{:account_number \"1234567890\"})\n</code></pre>"},{"location":"projects/banking-on-clojure/update-records/#update-an-existing-transaction-record","title":"Update an existing transaction record","text":"<p>Update an existing record in the <code>public.transaction_history</code> table.</p> <pre><code>(update-record db-specification-dev\n\"public.transaction_history\"\n{:transaction_reference \"Salary bonus\"\n:transaction_date      \"2020-09-12\"}\n{:transaction_id  \"8ac89cfc-6874-4ebe-9ee4-59b8c5e971ff\"})\n</code></pre> <p>Generating example data from Clojure Spec</p> <p>Clojure Spec: generate mock database data</p>"},{"location":"projects/game-scoreboard-api/","title":"Game Scoreboard API","text":"<p>Building an API from scratch using</p> <ul> <li>Reitit</li> <li>muuntaja</li> <li>reitit-ring middleware</li> <li>Integrant REPL - reloaded workflow</li> <li>Integrant - runtime component lifecycle</li> <li>mulog - event logging</li> <li>Auth0 - authentication and authorisation</li> </ul>"},{"location":"projects/leiningen/todo-app/","title":"TODO web application - Leiningen project","text":"<p>A simple todo list server side web application</p> <p>The TODO work for the todo project includes:</p> <ul> <li>Leiningen - project configuration and build (add Clojure CLI tools)</li> <li>ring - jetty application server and request/response management (review)</li> <li>compojure - routing of requests (review)</li> <li>hiccup - HTML content written using Clojure (review)</li> <li>Postgresql - relational database for todo items (add next.jdbc library)</li> <li>CircleCI - continuous testing and integration</li> <li>Heroku - deployment to staging and production (pipeline)</li> </ul>"},{"location":"projects/leiningen/todo-app/#todocontent-update-through-winter-2020","title":"TODO::Content update through Winter 2020","text":"<p>This is the original project example developed several years ago, so some of the library versions may be out of date.</p> <p>Practicalli recommends using next.jdbc to talk to postgresql and examples of this are covered in the new content being created for the banking on clojure project.</p>"},{"location":"projects/leiningen/todo-app/compojure/","title":"Compojure","text":"<p>To make our webapp more useful we will add more functionality, which will require more routes.</p> <p>Compojure is a library that works with Ring to manage</p> <ul> <li>routing - running different code depending on the URL path received</li> <li>http method switching - running different code based on the HTTP method (GET, POST, PUT, DELETE)</li> </ul> <p>Compojure also has convenience functions that make ring responses easier to generate.</p> <p>In this section we will update our project to use Compojure.</p> <p></p>"},{"location":"projects/leiningen/todo-app/compojure/#leiningen-templates","title":"Leiningen Templates","text":"<p>Templates can be used to create a project with a given set of dependencies as well as Clojure code.</p> <p>There is a <code>compojure</code> template that gives you a basic running web application.  To use this template to create a new project use the following command, substituting your own project-name</p> <pre><code>lein new compojure project-name\n</code></pre> <p>This project contains ring and compojure.  The dependency for ring is <code>ring/site-defaults</code> which includes some sensible default settings for your application, eg security settings such as anti-forgery.</p> <p>See the definition of ring/site-defaults for further information.</p>"},{"location":"projects/leiningen/todo-app/compojure/#resources","title":"Resources","text":"<ul> <li>Learn X in minutes - Compojure - using httpkit (performance &amp; scalability)</li> <li>Webapps with Compojure &amp; OM</li> <li>StackOverflow - What's the \u201cbig idea\u201d behind compojure routes?</li> </ul>"},{"location":"projects/leiningen/todo-app/compojure/about/","title":"About route","text":""},{"location":"projects/leiningen/todo-app/compojure/about/#note-write-an-about-route-and-handler-that-gives-you-information-about-the-app","title":"Note:: Write an about route and handler that gives you information about the app.","text":"<pre><code>(defn about\n\"Information about the website developer\"\n[request]\n{:status 200\n:headers {}\n:body \"I am an awesome Clojure developer, well getting there...\"})\n</code></pre> <p>Add a route to call the about handler function <pre><code>(defroutes app\n(GET \"/\"        [] welcome)\n(GET \"/goodbye\" [] goodbye)\n(GET \"/about\"   [] about)\n(not-found \"&lt;h1&gt;This is not the page you are looking for&lt;/h1&gt;\n              &lt;p&gt;Sorry, the page you requested was not found!&lt;/p&gt;\"))\n</code></pre></p>"},{"location":"projects/leiningen/todo-app/compojure/adding-dependency/","title":"Add Compojure as a dependency","text":"<p>Edit your project configuration <code>project.clj</code> and add the current version of Compojure</p> <p>The <code>project.clj</code> file should look as follows:</p> <pre><code>(defproject todo-list \"0.1.0-SNAPSHOT\"\n:description \"A Todo List server-side webapp using Ring &amp; Compojure\"\n:url \"https://github.com/practicalli/clojure-todo-list-example\"\n:license {:name \"Creative Commons Attribution Share-Alike 4.0 International\"\n:url  \"https://creativecommons.org\"}\n:dependencies [[org.clojure/clojure \"1.10.1\"]\n[ring \"1.8.0\"]\n[compojure \"1.6.1\"]]\n:repl-options {:init-ns todo-list.core}\n:main todo-list.core\n:profiles {:dev\n{:main todo-list.core/-dev-main}})\n</code></pre> <p>As we are adding a library to the project we need to restart the web server.</p> <p><code>Ctrl-c</code> in the terminal to stop the server and <code>lein run 8000</code> to restart the web server</p>"},{"location":"projects/leiningen/todo-app/compojure/adding-dependency/#hintsearch-clojarsorg-for-dependency-versions","title":"Hint::Search clojars.org for dependency versions","text":"<p>The current version of Compojure or any other Clojure library can be found via Clojars.org.</p>"},{"location":"projects/leiningen/todo-app/compojure/adding-goodbye-route/","title":"Adding a goodbye route","text":""},{"location":"projects/leiningen/todo-app/compojure/adding-goodbye-route/#noteadd-another-route-to-display-a-goodbye-message","title":"Note::Add another route to display a goodbye message","text":"<pre><code>(defroutes app\n(GET \"/\" [] welcome)\n(GET \"/goodbye\" [] goodbye)\n(not-found \"Sorry, page not found\"))\n</code></pre>"},{"location":"projects/leiningen/todo-app/compojure/adding-goodbye-route/#notewrite-the-handler-function-for-the-goodbye-route","title":"Note::Write the handler function for the <code>goodbye</code> route","text":"<pre><code>(defn goodbye\n\"A song to wish you goodbye\"\n[request]\n{:status 200\n:headers {}\n:body \"&lt;h1&gt;Walking back to happiness&lt;/h1&gt;\n          &lt;p&gt;Walking back to happiness with you&lt;/p&gt;\n          &lt;p&gt;Said, Farewell to loneliness I knew&lt;/p&gt;\n          &lt;p&gt;Laid aside foolish pride&lt;/p&gt;\n          &lt;p&gt;Learnt the truth from tears I cried&lt;/p&gt;\"})\n</code></pre> <p>Now test your new route.</p> <p>As we have <code>wrap-reload</code> around app then no restart needed</p>"},{"location":"projects/leiningen/todo-app/compojure/code-so-far/","title":"Code so far","text":"<p>The code and configuration we have created so far are in the clojure-todo-list-example repository github repository.</p> <p>Code for this section is in the branch called <code>04-compojure</code></p> <p>If something is not working or you want to speed up, simply clone the project into a new directory using the command:</p> <p><pre><code>git clone https://github.com/practicalli/clojure-todo-list-example\n</code></pre> Once you have cloned the project, checkout the <code>04-compojure</code> branch</p> <pre><code>git checkout 04-compojure\n</code></pre>"},{"location":"projects/leiningen/todo-app/compojure/defroutes/","title":"Theory: defroutes is a Clojure macro","text":"<p>The Compojure function <code>defroutes</code> is actually a Clojure macro.  The <code>defroutes</code> macro provides a simple syntax for defining routes and associating handler functions.</p>"},{"location":"projects/leiningen/todo-app/compojure/defroutes/#what-is-a-macro","title":"What is a macro?","text":"<p>Clojure has a programmatic macro system which allows the Clojure community to extend the language, rather than wait for the language designers.  This macro approach also helps keep the language very compact, with a minimum of primitives.</p> <p>We have already used several macros in our code.  In our project.clj configuration we use the <code>defproject</code> macro to make it easy to define our Clojure project.  In our code we have used the <code>defn</code> macro to define names (symbols) for functions.</p>"},{"location":"projects/leiningen/todo-app/compojure/defroutes/#peeking-under-the-covers","title":"Peeking under the covers","text":"<p>You can always look at what a macro is doing by using the <code>macroexpand</code> or <code>macroexpand-all</code> functions.  These functions show you what the code looks like after the macro-reader has processed the macro.</p> <p>To expand a macro, require the <code>clojure.walk</code> library in your namespace</p> <pre><code>[clojure.walk :as walk]\n</code></pre> <p>Then wrap the macro you wish to explore with the <code>macroexpand-all</code> function.</p> <pre><code>(walk/macroexpand-all\n'(defroutes myapp\n(GET \"/\" [] \"Show something\")))\n(def myapp\n(compojure.core/routes\n(compojure.core/make-route\n:get #clout.core.CompiledRoute{:source \"/\", :re #\"/\", :keys [], :absolute? false}\n(fn* ([request__13075__auto__] (let* [] \"Show something\"))))))\n</code></pre> <p>You can see that the <code>defroutes</code> function expands to a <code>make-route</code> function that creates the details of the route and associates it with a handler or response map. The <code>routes</code> function join multiple routes together.</p> <p>For further examples, see http://learnxinyminutes.com/docs/clojure-macros/</p>"},{"location":"projects/leiningen/todo-app/compojure/lisp-calculator/","title":"Lisp style Calculator","text":"<p>Lets create a very simple lisp based calculator that works with two numbers as another example of using variable path elements.  As its a Lisp calculator, then we will use prefix notation (the 'operator' comes first)</p>"},{"location":"projects/leiningen/todo-app/compojure/lisp-calculator/#create-a-route-for-the-calculator","title":"Create a route for the calculator","text":"<pre><code>(defroutes app\n(GET \"/\" [] greet)\n(GET \"/goodbye\" [] goodbye)\n(GET \"/about\" [] about)\n(GET \"/request-info\" [] handle-dump)\n(GET \"/hello/:name\" [] hello)\n(GET \"/calculator/:op/:a/:b\" [] calculator)\n(not-found \"Sorry, page not found\"))\n</code></pre>"},{"location":"projects/leiningen/todo-app/compojure/lisp-calculator/#create-a-handler-function-to-add-subtract-divide-or-multiply-two-numbers","title":"Create a handler function to add, subtract, divide or multiply two numbers","text":"<pre><code>(defn calculator\n\"A very simple calculator that can add, divide, subtract and multiply.  This is done through the magic of variable path elements.\"\n[request]\n(let [a  (Integer. (get-in request [:route-params :a]))\nb  (Integer. (get-in request [:route-params :b]))\nop (get-in request [:route-params :op])\nf  (get operands op)]\n(if f\n{:status 200\n:body (str \"Calculated result: \" (f a b))\n:headers {}}\n{:status 404\n:body \"Sorry, unknown operator.  I only recognise + - * : (: is for division)\"\n:headers {}})))\n</code></pre>"},{"location":"projects/leiningen/todo-app/compojure/lisp-calculator/#create-a-dictionary-to-look-up-clojure-function-names","title":"Create a dictionary to look up Clojure function names","text":"<p>Define a hash-map called <code>operands</code> to look up the names of the mathematical operations (operands) to the actual functions in Clojure</p> <pre><code>(def operands {\"+\" + \"-\" - \"*\" * \":\" /})\n</code></pre> <p>Try the calculator out like follows http://localhost:8000/calculator/*/6/7</p>"},{"location":"projects/leiningen/todo-app/compojure/lisp-calculator/#the-namespace-with-changes-made","title":"The namespace with changes made","text":"<p>With all the changes from above, the code should look as follows</p> <pre><code>(def operands {\"+\" + \"-\" - \"*\" * \":\" /})\n(defn calculator\n\"A very simple calculator that can add, divide, subtract and multiply.  This is done through the magic of variable path elements.\"\n[request]\n(let [a  (Integer. (get-in request [:route-params :a]))\nb  (Integer. (get-in request [:route-params :b]))\nop (get-in request [:route-params :op])\nf  (get operands op)]\n(if f\n{:status 200\n:body (str (f a b))\n:headers {}}\n{:status 404\n:body \"Sorry, unknown operator.  I only recognise + - * : (: is for division)\"\n:headers {}})))\n(defroutes app\n(GET \"/\" [] welcome)\n(GET \"/goodbye\" [] goodbye)\n(GET \"/about\" [] about)\n(GET \"/request-info\" [] handle-dump)\n(GET \"/yo/:name\" [] yo)\n(GET \"/calculator/:op/:a/:b\" [] calculator)\n(not-found \"Sorry, page not found\"))\n</code></pre>"},{"location":"projects/leiningen/todo-app/compojure/show-request-info/","title":"Show request info","text":"<p>We can see the details of the requests being send to our Clojure webapp by looking at the request object.</p>"},{"location":"projects/leiningen/todo-app/compojure/show-request-info/#request-info-route","title":"request-info route","text":"<p>Add a <code>request-info</code> route and handler to view the request information</p> <pre><code>(defn request-info\n\"View the information contained in the request, useful for debugging\"\n[request]\n{:status 200\n:body (pr-str request)\n:headers {}})\n(defroutes app\n(GET \"/\" [] welcome)\n(GET \"/goodbye\" [] goodbye)\n(GET \"/about\" [] about)\n(GET \"/request-info\" [] request-info)\n(not-found \"&lt;h1&gt;This is not the page you are looking for&lt;/h1&gt; &lt;p&gt;Sorry, the page you requested was not found!&lt;/p&gt;\"))\n</code></pre> <p>Visit http://localhost:8000/request-info to see the results.</p> <p></p>"},{"location":"projects/leiningen/todo-app/compojure/show-request-info/#using-compojure-request-dump-function","title":"Using Compojure request dump function","text":"<p>Compojure has a request dump function that gives a much nicer output than our initial <code>request-info</code> function.  The <code>dump</code> function also separates the default response keys with any additional keys provided by the URL.</p>"},{"location":"projects/leiningen/todo-app/compojure/show-request-info/#include-handle-dump-in-the-namespace","title":"Include <code>handle-dump</code> in the namespace","text":"<pre><code>(ns webdev.core\n(:require [ring.adapter.jetty :as jetty]\n[ring.middleware.reload :refer [wrap-reload]]\n[compojure.core :refer [defroutes GET]]\n[compojure.route :refer [not-found]]\n[ring.handler.dump :refer [handle-dump]]))\n</code></pre>"},{"location":"projects/leiningen/todo-app/compojure/show-request-info/#remove-request-info-function","title":"Remove request-info function","text":"<p>Delete the <code>request-info</code> function we defined previously and update the <code>/request-info</code> route to use <code>handle-dump</code> as the handler</p> <pre><code>(defroutes app\n(GET \"/\" [] welcome)\n(GET \"/goodbye\" [] goodbye)\n(GET \"/about\" [] about)\n(GET \"/request-info\" [] handle-dump)\n(not-found \"&lt;h1&gt;This is not the page you are looking for&lt;/h1&gt; &lt;p&gt;Sorry, the page you requested was not found!&lt;/p&gt;\"))\n</code></pre> <p>Now the output is much nicer http://localhost:8000/request-info</p> <p></p>"},{"location":"projects/leiningen/todo-app/compojure/theory-local-name-bindings/","title":"Theory local name bindings","text":""},{"location":"projects/leiningen/todo-app/compojure/theory-local-name-bindings/#theory-local-binding-with-let","title":"Theory: Local binding with <code>let</code>","text":"<p>The <code>let</code> function binds a name to a value within the scope of the <code>let</code> function.  The name is used to represent the value it is bound to, especially useful if the value is complex or the result of an expression.</p> <pre><code>(let [name value])\n</code></pre> <p>Binding values to names can be used to remove duplicate code, making the code more efficient.</p>"},{"location":"projects/leiningen/todo-app/compojure/theory-local-name-bindings/#binding-any-value","title":"Binding any value","text":"<p>A let expression can bind a name to any Clojure value, from a simple number or string, to a collection or result of an expression.</p> <p>In our example we are pulling out a value from a map and using the <code>let</code> function to create a name we can use to reference that value.  The name is used to in the body of the response map, so when the response map is returned the page is displayed with the name.</p> <pre><code>(let [name (get-in request [:route-params :name])]\n{:status 200\n:body (str \"Hello \" name \".  I got your name from the web URL\")\n:headers {}})\n</code></pre> <p>The Ring adaptor creates a Clojure hash-map from the browser request which is called the request map.  The request map is passed to handler functions.</p>"},{"location":"projects/leiningen/todo-app/compojure/theory-local-name-bindings/#a-binding-is-immediately-available","title":"A binding is immediately available","text":"<p>A name is available for use as soon as it is bound, even within the name/value bindings section of the <code>let</code> expression.</p> <pre><code>(let [apples  10\n      oranges 15\n      total-fruit (+ apples oranges)]\n  (str \"Total fruit: \" total-fruit))\n</code></pre>"},{"location":"projects/leiningen/todo-app/compojure/theory-local-name-bindings/#hintuse-meaningful-names-or-avoid-local-names","title":"Hint::Use meaningful names or avoid local names","text":"<p>Use meaningful names in let expressions to effectively communicate the purpose of the code.</p> <p>If it is hard to find a meaningful name, either the problem space is not understood enough or local names may not be necessary.</p>"},{"location":"projects/leiningen/todo-app/compojure/theory-routing/","title":"Theory: routing","text":"<p>In compojure, each route is a combination offer a HTTP method paired with a URL-matching pattern, an argument list, and a handler.  The handler is typically the name of function.</p> <pre><code>(defroutes myapp\n(GET     \"/\" [] show-something)\n(POST    \"/\" [] create-something)\n(PUT     \"/\" [] replace-something)\n(PATCH   \"/\" [] modify-something)\n(DELETE  \"/\" [] annihilate-something)\n(OPTIONS \"/\" [] appease-something)\n(HEAD    \"/\" [] preview-something))\n</code></pre> <p>A handler is a functions which accept request maps and return response maps.</p> <pre><code>(defn show-something\n\"A simple handler function\"\n[request]\n{:status 200\n:headers {\"Content-Type\" \"text/html; charset=utf-8}\n   :body \"&lt;h1&gt;I am a simple handler function&lt;/h1&gt;\"})\n</code></pre> <p>These handler functions can be called by passing a Clojure hash-map.  The result is another Clojure hash-map that contains values for <code>:status</code>, <code>:headers</code> and <code>:body</code>.</p> <pre><code>(show-something {:uri \"/\" :request-method :post})\n;; =&gt; {:status 200\n;;     :headers {\"Content-Type\" \"text/html; charset=utf-8}\n;;     :body \"&lt;h1&gt;I am a simple handler function&lt;/h1&gt;\"}\n</code></pre> <p>The body may be a function, which must accept the request as a parameter:</p> <pre><code>(defroutes myapp\n(GET \"/\" [] (fn [req] \"Do something with req\")))\n</code></pre> <p>Or, you can just use the request directly:</p> <pre><code>(defroutes myapp\n(GET \"/\" req \"Do something with req\"))\n</code></pre> <p>Route patterns may include named parameters:</p> <pre><code>(defroutes myapp\n(GET \"/hello/:name\" [name] (str \"Hello \" name)))\n</code></pre> <p>You can adjust what each parameter matches by supplying a regex:</p> <pre><code>(defroutes myapp\n(GET [\"/file/:name.:ext\" :name #\".*\", :ext #\".*\"] [name ext]\n(str \"File: \" name ext)))\n</code></pre>"},{"location":"projects/leiningen/todo-app/compojure/theory-using-hash-maps/","title":"Theory: Accessing hash-maps","text":"<p>The request is a Clojure hash-map made up of key / value pairs, referred to as the request map.  The keys are Clojure keywords.  The values are typically strings or Clojure collections (vectors, hash-maps).</p> <p>Here is an example of a request map</p> <pre><code>{:request-params {:name \"John\"}}\n</code></pre> <p>Using the <code>get</code> function to return the value for a particular keyword in the request-map</p> <pre><code>(get request-map :keyword)\n</code></pre>"},{"location":"projects/leiningen/todo-app/compojure/theory-using-hash-maps/#using-hash-map-as-a-function","title":"Using hash-map as a function","text":"<p>A hash-map can be evaluated as a function call to the map with the key as an argument.  Any type of key can be used in this expression.</p> <pre><code>(request-map :keyword)\n(request-map \"key as string\")\n</code></pre>"},{"location":"projects/leiningen/todo-app/compojure/theory-using-hash-maps/#nested-hash-maps","title":"Nested hash-maps","text":"<p>Two <code>get</code> expressions could be used to return a particular value when accessing a nested hash-map.  The inner get expression returns a hash-map and the outer get expression returns the value.</p> <pre><code>(get (get outer-map :outer-keyword) :inner-keyword)\n</code></pre> <p>With many nested maps, the <code>get</code> function can lead to code that is harder to read.  Using the <code>get-in</code> function provides a simpler syntax for traversing nested maps</p> <p><code>get-in</code> walks through the nested hash-map along the path defined by the vector of keys.</p> <pre><code>(get-in request-map [:outer-keyword :inner-keyword])\n</code></pre>"},{"location":"projects/leiningen/todo-app/compojure/theory-using-hash-maps/#using-keywords-and-hash-maps","title":"Using keywords and hash-maps","text":"<p>Keywords can be evaluated as a function call with a hash-map as an argument and return their associated value in that hash-map.</p> <pre><code>(def response-map {:name \"john\" :path \"/hello\"}\n</code></pre> <p>You can get the value from this map using the keyword</p> <pre><code>(response-map :name)\n=&gt; \"john\"\n(response-map :path)\n=&gt; \"/hello\"\n</code></pre> <p>Other types of keys do not work as function calls.  Either use the map as a function with the key as an argument or use the <code>get</code> and <code>get-in</code> functions as appropriate.</p>"},{"location":"projects/leiningen/todo-app/compojure/using-compojure/","title":"Using Compojure in the project","text":"<p>The Compojure <code>defroute</code> function provides a syntax for defining routes and associating handlers.</p> <p></p>"},{"location":"projects/leiningen/todo-app/compojure/using-compojure/#add-compojure-to-the-namespace","title":"Add Compojure to the namespace","text":"<p>Add the <code>defroutes</code> function, <code>GET</code> protocol and <code>notfound</code> route from Compojure to the namespace</p> <pre><code>(ns todo-list.core\n(:require [ring.adapter.jetty :as jetty]\n[ring.middleware.reload :refer [wrap-reload]]\n[compojure.core :refer [defroutes GET]]\n[compojure.route :refer [not-found]]))\n</code></pre>"},{"location":"projects/leiningen/todo-app/compojure/using-compojure/#refactor-the-welcome-function-to-just-say-hello","title":"Refactor the welcome function to just say Hello","text":"<p>The welcome function should just do one simple thing, return a welcome message.</p> <pre><code>(defn welcome\n\"A ring handler to respond with a simple welcome message\"\n[request]\n{:status 200\n:body \"&lt;h1&gt;Hello, Clojure World&lt;/h1&gt;\n     &lt;p&gt;Welcome to your first Clojure app, I now update automatically&lt;/p&gt;\"\n&lt;p&gt;I now use defroutes to manage incoming requests&lt;/p&gt;\n:headers {}})\n</code></pre>"},{"location":"projects/leiningen/todo-app/compojure/using-compojure/#add-a-defroutes-function","title":"Add a defroutes function","text":"<p>Add a <code>defroutes</code> function called <code>app</code> to manage our routes.  Add routes for <code>/</code> and send all other requests to the Compojure <code>not-found</code> function.</p> <pre><code>(defroutes app\n(GET \"/\" [] welcome)\n(not-found \"&lt;h1&gt;This is not the page you are looking for&lt;/h1&gt;\n              &lt;p&gt;Sorry, the page you requested was not found!&lt;/p&gt;\"))\n</code></pre>"},{"location":"projects/leiningen/todo-app/compojure/using-compojure/#update-dev-main-and-main-functions","title":"Update -dev-main and -main functions","text":"<p>Change the <code>-dev-main</code> and <code>-main</code> functions to call the <code>app</code> function, instead of the <code>welcome</code> function</p> <pre><code>(defn -main\n\"A very simple web server using Ring &amp; Jetty\"\n[port-number]\n(webserver/run-jetty app\n{:port (Integer. port-number)}))\n(defn -dev-main\n\"A very simple web server using Ring &amp; Jetty that reloads code changes via the development profile of Leiningen\"\n[port-number]\n(webserver/run-jetty (wrap-reload #'app)\n{:port (Integer. port-number)}))\n</code></pre> <p>As we have changed the <code>-dev-main</code> and <code>-main</code> functions, we need to restart the server again - <code>Ctrl-c</code> then <code>lein run 8000</code></p> <p>Now test out your updated web app by visiting http://localhost:8000 and http://localhost:8000/not-there</p>"},{"location":"projects/leiningen/todo-app/compojure/variable-path-elements/","title":"Variable Path Elements","text":"<p>A simple way to affect the behaviour of a web app is to add extra text (elements) to the web address (URL).  For example, you can add your name to the end of the web address and the returned web page will include your name.</p> <p>By adding an element to the route path, we can take that element from the URL as it is part of the request.  We can then get that value from the request map and use it in our body content.</p>"},{"location":"projects/leiningen/todo-app/compojure/variable-path-elements/#hello-handler-example","title":"Hello handler example","text":"<p>Create a simple personalised hello message by adding a route for <code>/hello</code> with <code>/:name</code> as a path element.</p> <p>Create a <code>hello</code> function as the handler that pulls out the <code>:name</code> element from the request and adds it to the response.</p> <pre><code>(defn hello\n\"A simple personalised greeting showing the use of variable path elements\"\n[request]\n(let [name (get-in request [:route-params :name])]\n{:status 200\n:body (str \"Hello \" name \".  I got your name from the web URL\")\n:headers {}}))\n(defroutes app\n(GET \"/\" [] greet)\n(GET \"/goodbye\" [] goodbye)\n(GET \"/about\" [] about)\n(GET \"/request-info\" [] handle-dump)\n(GET \"/hello/:name\" [] hello)\n(not-found \"Sorry, page not found\"))\n</code></pre> <p>Now you can test this route out by also including a name to the URL path http://localhost:8000/hello/john</p>"},{"location":"projects/leiningen/todo-app/connect-to-postgres/","title":"Connecting to Heroku PostgreSQL from Clojure","text":"<ul> <li>Add dependencies</li> <li>Define a database connection (Heroku posgres)</li> <li>Migrations (TODO)</li> </ul>"},{"location":"projects/leiningen/todo-app/connect-to-postgres/#using-jdbc-for-relational-databases","title":"Using JDBC for Relational Databases","text":"<p>Java Database connectivity is a common way to connect to a relational database and has very widespread database support.</p> <p>next.jdbc is a Clojure library to send SQL statements over jdbc or use a DSL such as HoneySQL) to work with these databases.</p>"},{"location":"projects/leiningen/todo-app/connect-to-postgres/add-database-dependencies/","title":"Add Dependency","text":"<p>Our application will use JDBC (Java database connectivity) to connect to the Postgres database. So we need to add the JDBC library along with a a specific JDBC driver for Postgres.</p> <p>Edit the project configuration file, <code>project.clj</code> and add the following dependencies</p> <pre><code>[org.clojure/java.jdbc \"0.7.10\"]\n[org.postgresql/postgresql \"42.2.9\"]\n</code></pre> <p>The <code>project.clj</code> file should now look as follows:</p> <pre><code>(defproject todo-list \"0.1.0-SNAPSHOT\"\n:description \"A Todo List server-side webapp using Ring &amp; Compojure\"\n:url \"https://github.com/practicalli/clojure-todo-list-example\"\n:license {:name \"Creative Commons Attribution Share-Alike 4.0 International\"\n:url  \"https://creativecommons.org\"}\n:dependencies [[org.clojure/clojure \"1.10.1\"]\n[ring \"1.8.0\"]\n[compojure \"1.6.1\"]\n[org.clojure/java.jdbc \"0.7.10\"]\n[org.postgresql/postgresql \"42.2.9\"]]\n:min-lein-version \"2.0.0\"\n:repl-options {:init-ns todo-list.core}\n:main todo-list.core\n:profiles {:dev\n{:main todo-list.core/-dev-main}\n:uberjar {:aot :all}}\n:uberjar-name \"todo-list.jar\"\n:auto-clean false)\n</code></pre>"},{"location":"projects/leiningen/todo-app/connect-to-postgres/add-database-dependencies/#note-add-dependencies-to-the-project-for-the-heroku-postgres-database","title":"Note:: Add Dependencies to the project for the Heroku Postgres database","text":""},{"location":"projects/leiningen/todo-app/connect-to-postgres/define-db-connection/","title":"Define a Database Connection","text":""},{"location":"projects/leiningen/todo-app/connect-to-postgres/define-db-connection/#hintoutdated-use-nextjdbc-approach","title":"Hint::Outdated: Use next.jdbc approach","text":"<p>next.jdbc provides a simple way to connect to a range of databases</p> <p>Heroku provides a way to generate the connection string.  The Heroku build process sets an environment variable called JDBC_DATABASE_URL which can be used with next.jdbc.</p>"},{"location":"projects/leiningen/todo-app/connect-to-postgres/define-db-connection/#outdated-under-review","title":"Outdated - under review","text":"<p>View the Database_URL configuration variable for the Heroku Database and define a name to represent that in Clojure</p> <p>Use the Heroku Toolbelt to view the configuration variables</p> <pre><code>heroku config\n</code></pre> <p>Edit the file <code>src/todo_list/core.clj</code> file and add the following definition towards the top of the file.  Substitute your own database connection values for <code>:subname</code>, <code>user</code> and <code>password</code>.</p> <pre><code>(def postgres {:subprotocol \"postgresql\"\n:subname \"//node.domain.com:5432/database-name\"\n:user \"username\"\n:password \"password\"\n:ssl true\n:sslmode true\n:sslfactory \"org.postgresql.ssl.NonValidatingFactory\"})\n</code></pre> <p>Breaking down the Heroku Postgres connection string into a map  allows us to easily add options to the connection string whilst keeping it readable.</p> <p>Also, a JDBC connection string has a slightly different form to the Heroku string. Heroku Posgres creates a configuration variable in the form of <code>postgres://[user]:[password]@[host]:[port]/[database]</code> whereas the JDBC connection string is of the form `jdbc:postgres://[host]:[port]/[database]?user=[user]&amp;password=[pass]</p>"},{"location":"projects/leiningen/todo-app/connect-to-postgres/define-db-connection/#jdbc-connection-string-for-heroku-postgres","title":"JDBC connection string for Heroku Postgres","text":"<p><code>jdbc:postgresql://[host]:[port]/[database]?user=[user]&amp;password=[password]&amp;ssl=true&amp;sslfactory=org.postgresql.ssl.NonValidatingFactory</code>.</p> <p>Converting the map back to a JDBC connection string</p> <pre><code>(defn remote-heroku-db-spec [host port database username password]\n{:connection-uri (str \"jdbc:postgresql://\" host \":\" port \"/\" database \"?user=\" username \"&amp;password=\" password \"&amp;ssl=true&amp;sslfactory=org.postgresql.ssl.NonValidatingFactory\")})\n</code></pre>"},{"location":"projects/leiningen/todo-app/connect-to-postgres/define-db-connection/#from-heroku","title":"From Heroku","text":"<p><code>JDBC_DATABASE_URL</code> environment variable should be used for the Heroku database connection</p> <p>The <code>DATABASE_URL</code> environment variable from the Heroku Postgres add-on follows this naming convention:</p> <pre><code>postgres://&lt;username&gt;:&lt;password&gt;@&lt;host&gt;/&lt;dbname&gt;\n</code></pre> <p>However the Postgres JDBC driver uses the following convention:</p> <pre><code>jdbc:postgresql://&lt;host&gt;:&lt;port&gt;/&lt;dbname&gt;?user=&lt;username&gt;&amp;password=&lt;password&gt;\n</code></pre> <p>Notice the additional <code>ql</code> at the end of <code>jdbc:postgresql</code>.</p>"},{"location":"projects/leiningen/todo-app/create-a-handler-function/","title":"Create a handler function","text":"<p>So far we have just sent back the same response map.  To make our webapp more useful then we should have functions that return different web pages and resources (like JSON for API's).</p> <p>In Ring terminology, these functions are referred to as a handler.  They handler a request and return a response.</p> <p>When you send a request to the webapp, the ring adaptor converts this request to a map and sends it to the specified handler.</p> <p></p> <p>A handler function takes the request map as its argument and returns a response map.</p>"},{"location":"projects/leiningen/todo-app/create-a-handler-function/#noteadd-separate-handler-function","title":"Note::Add separate handler function","text":"<p>Refactor the code in the <code>src/todo-list/core.clj</code> file to create a separate <code>welcome</code> handler function that processes all requests</p> <pre><code>(defn welcome\n\"A ring handler to process all requests sent to the webapp\"\n[request]\n{:status  200\n:headers {}\n:body    \"&lt;h1&gt;Hello, Clojure World&lt;/h1&gt;\n             &lt;p&gt;Welcome to your first Clojure app.\n             This message is returned regardless of the request, sorry&lt;p&gt;\"})\n</code></pre> <p>Update the <code>-main</code> function to call the <code>welcome</code> function</p> <pre><code>(defn -main\n\"A very simple web server using Ring &amp; Jetty\"\n[port-number]\n(webserver/run-jetty\nwelcome\n{:port  (Integer. port-number)\n:join? false}))\n</code></pre>"},{"location":"projects/leiningen/todo-app/create-a-handler-function/#run-the-server-again","title":"Run the server again","text":"<p>Save code changes and run the web server (use Control-c if you need to stop the server first)</p> <pre><code>lein run 8000\n</code></pre> <p>Your webapp should behave exactly as it did before, check by visiting http://localhost:8000.</p> <p></p>"},{"location":"projects/leiningen/todo-app/create-a-handler-function/#hintautomatically-reloading","title":"Hint::Automatically reloading","text":"<p>In the middleware section the <code>wrap-reload</code> ring middleware component is used to automatically reload code changes into the running application, so no need to restart the webserver unless we have to add a dependency.</p>"},{"location":"projects/leiningen/todo-app/create-a-handler-function/add-not-found/","title":"Add Error message when request not found","text":"<p>So far our app has responded with the same message, regardless of the web address (route) requested in the browser.  The webapp will be more useful if it responds differently to different routes.</p> <pre><code>(defn welcome\n\"A ring handler to process all requests for the web server.\n  If a request is for something other than `/` then an error message is returned\"\n[request]\n(if (= \"/\" (:uri request))\n{:status 200\n:body \"&lt;h1&gt;Hello, Clojure World&lt;/h1&gt;\n            &lt;p&gt;Welcome to your first Clojure app.&lt;/p&gt;\"\n:headers {}}\n{:status 404\n:body \"&lt;h1&gt;This is not the page you are looking for&lt;/h1&gt;\n            &lt;p&gt;Sorry, the page you requested was not found!&gt;&lt;/p&gt;\"\n:headers {}}))\n</code></pre> <p>If the route matches <code>/</code> then a response map with the welcome message is returned.  For any other route, a response map containing our error message is returned.</p>"},{"location":"projects/leiningen/todo-app/create-a-handler-function/add-not-found/#noteadd-error-message-to-handler","title":"Note::Add error message to handler","text":"<p>Change the code to only respond with content when requesting the default route, that is http://localhost:8000/.  Anything else we will return an error.</p> <p>Edit the <code>welcome</code> function in <code>src/todo-list/core.clj</code> and use an <code>if</code> function to check if the request is valid or not.</p>"},{"location":"projects/leiningen/todo-app/create-a-handler-function/add-not-found/#run-the-new-version-of-your-code","title":"Run the new version of your code","text":"<p>If your server is still running, kill it first using <code>Ctrl-c</code> keyboard shortcut.  Then run the server again, this time with the new code using the same command as before:</p> <pre><code>lein run 8000\n</code></pre> <p>Open http://localhost:8000 in your browser and try out different pages, such at /hello,  /goodbye or  /complete-indifference.</p> <p>Only http://localhost:8000 will return the welcome message, everything else should return the error message.</p> <p></p>"},{"location":"projects/leiningen/todo-app/create-a-handler-function/code-so-far/","title":"Code so far","text":"<p>The code and configuration we have created so far are in the clojure-webapps-example github repository.</p> <p>Code for this section is in the branch called <code>02-create-a-handler-function</code></p> <p>If something is not working or you want to speed up, simply clone the project into a new directory using the command:</p> <p><pre><code>git clone https://github.com/practicalli/clojure-webapps-example\n</code></pre> Once you have cloned the project, checkout the <code>02-create-a-handler-function</code> branch</p> <pre><code>git checkout 02-create-a-handler-function\n</code></pre>"},{"location":"projects/leiningen/todo-app/create-a-handler-function/if-function/","title":"Theory: if function","text":"<p>Clojure has an <code>if</code> function that evaluates an expresssion.  If that expression is true, then the first value is returned, if false then the second argument is returned.</p> <p>In pseudo-code, the <code>if</code> function in Clojure works as follows</p> <pre><code>  If (this expression is true ?)\nthen return this value\nelse return this value\n</code></pre> <p>In the project code an <code>if</code> function checks the web address by returning the value associated with <code>:uri</code> in the request map.</p> <p>If the <code>:url</code> value is equal to <code>/</code> then the first response map with the hello message is returned.</p> <p>If the <code>:uri</code> value is not equal to <code>/</code> then the second resource map with an error message is returned.</p> <pre><code>  (if (= \"/\" (:uri request))\n{:status 200\n:body \"&lt;h1&gt;Hello, Clojure World&lt;/h1&gt;\n            &lt;p&gt;Welcome to your first Clojure app.&lt;/p&gt;\"\n:headers {}}\n{:status 404\n:body \"&lt;h1&gt;This is not the page you are looking for&lt;/h1&gt;\n            &lt;p&gt;Sorry, the page you requested was not found!&gt;&lt;/p&gt;\"\n:headers {}}))\n</code></pre>"},{"location":"projects/leiningen/todo-app/create-a-handler-function/if-function/#hintsingle-path-if-function","title":"Hint::Single path if function","text":"<p>In the case where an if expression is defined with only one value and the expression is false, then the value <code>nil</code> is returned.  <code>when</code> function is the idiomatic choice over a single path <code>if</code> function.</p>"},{"location":"projects/leiningen/todo-app/create-a-handler-function/if-function/#multiple-expression-if-function-with-do","title":"Multiple expression if function with do","text":"<p>Each of the two possible values the <code>if</code> function returns can come from only evaluating one expression.  For example</p> <pre><code>(if (true)\n(str \"I am the truth\")\n(str \"I am the path to darkness\")\n</code></pre> <p>If you need multiple expressions they can be wrapped in the <code>do</code> function</p> <pre><code>(if (true)\n(do (some-function)\n(another-function))\n(else-function))\n</code></pre> <p>The <code>do</code> function calls each function evaluation in turn, returning the result of the last function called.</p>"},{"location":"projects/leiningen/todo-app/create-a-handler-function/if-function/#hintcompojure-for-managing-routes","title":"Hint::Compojure for managing routes","text":"<p>The <code>if</code> function is a very simplistic way to define routes in our web application.  Compojure is a library for elegantly managing routing for our Clojure server-side applications.</p>"},{"location":"projects/leiningen/todo-app/create-a-handler-function/maps-and-keywords/","title":"Maps and keywords","text":""},{"location":"projects/leiningen/todo-app/create-a-handler-function/maps-and-keywords/#theory-maps-and-keywords","title":"Theory: maps and keywords","text":"<p>When a request is received by our application, it is converted from by Jetty to a servlet request.  Ring then converts this to a Clojure map called <code>request</code>.  All handlers in our application take a request map as an argument.</p> <p>A map in Clojure contains one or more key / value pairs, you may be familiar with the term hash map.  The keys in these maps are often defined using a Clojure keyword.  A keyword is a symbol that points to itself and so therefore is unique within a specific scope.  A keyword makes it very easy to get a value from a map and acts as a function on the map to return its associated value</p> <p>So, assume we have defined a map called <code>request</code>. This map contains a key defined with the <code>:uri</code> keyword. We can get the value associated with the key using the keyword as a function</p> <pre><code>(def request {:uri \"/\"})\n(:uri request)\n;; As a map can also act as a function to get its elements, you can also use the following form to get the same value\n(request :uri)\n</code></pre> <p>The function <code>get</code> is functions that helps us get data from maps.  The function <code>get-in</code> helps us get data from nested levels of maps.</p>"},{"location":"projects/leiningen/todo-app/create-a-project/","title":"Create a project","text":"<p>Create a project called <code>todo-list</code> using Leiningen, the build automation tool for Clojure.  This project will run the simplest possible webserver.</p> <p>On the command line:</p> <pre><code>lein new todo-list\n</code></pre> <p></p>"},{"location":"projects/leiningen/todo-app/create-a-project/#take-a-look-at-the-project-structure","title":"Take a look at the project structure","text":"<p>Change into the <code>todo-list</code> directory created by the Leiningen command and see the project structure that has been created.</p> <ul> <li><code>project.clj</code> - the project configuration, written in Clojure</li> <li><code>src</code> for all the source code</li> <li><code>test</code> for unit test code</li> </ul> <p>Using the <code>tree</code> command is a simple way to see the project structure (alternatively use <code>ls -R</code> or a graphical file browser).</p> <p></p>"},{"location":"projects/leiningen/todo-app/create-a-project/#hint-file-names-and-the-java-class-path","title":"Hint:: File names and the Java class path","text":"<p>The <code>src</code> and <code>test</code> directories both contain a directory named <code>todo_list</code> even though our project is <code>todo-list</code>.</p> <p>Unfortunately the Java classpath does not like dashes '-' in directory or file names, so Leiningen changes the directory names to <code>src/todo_list</code> &amp; <code>test/todo_list</code> and the initial test to <code>src/todo_list/core_test.clj</code>.</p>"},{"location":"projects/leiningen/todo-app/create-a-project/code-so-far/","title":"The code so far","text":"<p>The code and configuration we have created so far are in the clojure-todo-list-example repository github repository.</p> <p>Code for this section is in the branch called <code>master</code></p> <p>If something is not working or you want to speed up, simply clone the project into a new directory using the command:</p> <p><pre><code>git clone https://github.com/practicalli/clojure-todo-list-example\n</code></pre> Once you have cloned the project, checkout the <code>master</code> branch</p> <pre><code>git checkout master\n</code></pre>"},{"location":"projects/leiningen/todo-app/create-a-project/update-project-details/","title":"Update project details","text":"<p>Adding project details to the <code>project.clj</code> file helps every developer that works with the code to have a basic understanding of the projects purpose.</p>"},{"location":"projects/leiningen/todo-app/create-a-project/update-project-details/#noteupdate-project-details","title":"Note::Update project details","text":"<p>Edit the <code>project.clj</code> file and make the following changes.</p> <ul> <li>Add a description</li> <li>Add the URL of the project, eg. the github repository</li> <li>Update the licence (optional)</li> <li>Update the dependencies to the latest Clojure version</li> </ul> <p>The project.clj file for Practicalli projects is as follows:</p> <pre><code>(defproject todo-list \"0.1.0-SNAPSHOT\"\n:description \"A Todo List server-side webapp using Ring &amp; Compojure\"\n:url \"https://github.com/practicalli/clojure-todo-list-example\"\n:license {:name \"Creative Commons Attribution Share-Alike 4.0 International\"\n:url  \"https://creativecommons.org\"}\n:dependencies [[org.clojure/clojure \"1.10.1\"]]\n:repl-options {:init-ns todo-list.core})\n</code></pre>"},{"location":"projects/leiningen/todo-app/create-a-project/update-project-details/#licence-change","title":"Licence change","text":"<p>All code by Practicalli is under the Creative Commons Attribution Share-alike.</p> <p>As well as changing the <code>project.clj</code> file <code>:licence</code> declaration, the <code>LICENCE</code> file created by the Leiningen template has been deleted as it refers to another licence.</p>"},{"location":"projects/leiningen/todo-app/create-a-webserver-with-ring/","title":"Use the Ring Library to create a webserver","text":"<p>The Ring library can start an embedded Java server (eg. Jetty, Tomcat) to listen for requests from a browser.  Each browser request received is converted into a request map, a Clojure map with keys and values.  This request map is passed to a handler function, which returns a response map.</p> <p></p> <p>In the section you will discover how to:</p> <ul> <li>Add the Ring library as a dependency</li> <li>Including Ring in the namespace</li> <li>Add a main function to run a Jetty webserver</li> <li>Configure the project's main namespace</li> <li>Run webserver</li> </ul>"},{"location":"projects/leiningen/todo-app/create-a-webserver-with-ring/#related-theory","title":"Related Theory","text":"<p>We will cover some related theory on Coercing types (also known as casting types) to help us deal with Java interoperability.</p> <p>We will also cover how to manage the scope of your Clojure code with Namespaces.</p>"},{"location":"projects/leiningen/todo-app/create-a-webserver-with-ring/#hintring-details","title":"Hint::Ring details","text":"<p>Ring is covered in more detail in the next section, once you have your first webserver up and running.</p>"},{"location":"projects/leiningen/todo-app/create-a-webserver-with-ring/add-a-jetty-webserver/","title":"Run Jetty web server","text":"<p>The Ring Jetty adaptor is used to run an instance of Jetty.  The <code>-main</code> function contains an anonymous function that takes any request and returns a response map.</p> <p>The <code>-main</code> function takes a port number as an argument which we pass when running the application.</p> <p></p> <p>A response map contains the following key / value pairs * <code>:status</code> - the result of the request, eg. 200 OK, 401 Not Found, etc * <code>:body</code> - the content to be returned (web page, json, etc) * <code>:headers</code> - a map of standard headers included in any web browser response</p> <p>Add a function called <code>-main</code> to the  <code>src/todo_list/core.clj</code> file.</p> <pre><code>(defn -main\n\"A very simple web server using Ring &amp; Jetty\"\n[port-number]\n(webserver/run-jetty\n(fn [request]\n{:status  200\n:headers {}\n:body    \"&lt;h1&gt;Hello, Clojure World&lt;/h1&gt;\n                 &lt;p&gt;Welcome to your first Clojure app.\n                 This message is returned regardless of the request, sorry&lt;/p&gt;\"})\n{:port  (Integer. port-number)\n:join? false}))\n</code></pre>"},{"location":"projects/leiningen/todo-app/create-a-webserver-with-ring/add-a-jetty-webserver/#explaining-the-new-function","title":"Explaining the new function","text":"<p>Using a <code>-</code> at the start of the <code>-main</code> function is a naming convention, helping you see which function is the entry point to your program.  Leiningen also looks for this -main function by default when running your application.</p> <p>The <code>webserver/run-jetty</code> function takes two arguments.  In our example, the first argument is an anonymous function that returns a map (the response to the browser request);  the second argument is a port number to run the jetty server on expressed as a Java Integer object.</p> <p>The <code>Integer.</code> function is a call to <code>java.lang.Integer</code>.  The <code>.</code> is a special form that tells Clojure to treat this name as a call to Java.  See coercing types and java.lang</p> <p>The <code>:join? false</code> setting enables the REPL prompt to run after the web server starts.  By default the join setting is true and the running server would block access to the REPL prompt.</p>"},{"location":"projects/leiningen/todo-app/create-a-webserver-with-ring/add-ring-dependency/","title":"Add Ring Dependency","text":"<p>Add the ring library as a dependency of the todo-list project.</p>"},{"location":"projects/leiningen/todo-app/create-a-webserver-with-ring/add-ring-dependency/#noteadd-ring-dependency","title":"Note::Add ring dependency","text":"<p>Edit the <code>project.clj</code> file and add [ring \"1.8.0\"] to the <code>:dependencies</code> section, after the Clojure library dependency.</p> <pre><code>(defproject todo-list \"0.1.0-SNAPSHOT\"\n:description \"A Todo List server-side webapp using Ring &amp; Compojure\"\n:url \"https://github.com/practicalli/clojure-todo-list-example\"\n:license {:name \"Creative Commons Attribution Share-Alike 4.0 International\"\n:url  \"https://creativecommons.org\"}\n:dependencies [[org.clojure/clojure \"1.10.1\"]\n[ring \"1.8.0\"]]\n:repl-options {:init-ns todo-list.core})\n</code></pre>"},{"location":"projects/leiningen/todo-app/create-a-webserver-with-ring/add-ring-dependency/#hintdependencies-with-leiningen","title":"Hint::Dependencies with Leiningen","text":"<p>Read the dependencies section of the Leiningen documentation to learn more about adding libraries.</p>"},{"location":"projects/leiningen/todo-app/create-a-webserver-with-ring/add-ring-dependency/#looking-up-libraries-current-versions","title":"Looking up Libraries &amp; current versions","text":"<p>Libraries created by the Clojure community can be found on Clojars.org, an online repository similar to Maven Central.</p> <p>Use the Clojars.org website to search for the latest version of Ring.</p> <p></p> <p>The dependency notation for Leiningen is documented for each library, making it easy to add the library to your project.</p>"},{"location":"projects/leiningen/todo-app/create-a-webserver-with-ring/code-so-far/","title":"The code so far","text":"<p>The code created so far is in the clojure-webapps-example github repository, specifically the branch called <code>01-create-a-webserver</code></p> <p>If something is not working or you want to speed up, simply clone the project (if you have not already done so) into a new directory using the command:</p> <pre><code>git clone https://github.com/practicalli/clojure-webapps-example\n</code></pre> <p>Checkout the <code>01-create-a-webserver</code> branch to see the relevant version of the code</p> <pre><code>git checkout 01-create-a-webserver-with-ring\n</code></pre>"},{"location":"projects/leiningen/todo-app/create-a-webserver-with-ring/coersing-types-and-java-lang/","title":"Theory: Specifying Types &amp; java.lang","text":"<p>Clojure has types that are created dynamically when the code is compiled, with everything being represented by Java objects as its compiled to Java byte code.</p> <p>Clojure simply infers the type of a value, so types do not need to be specified in code.</p> <p>The built in collections (list, map, vector &amp; set) also support mixed types too.</p>"},{"location":"projects/leiningen/todo-app/create-a-webserver-with-ring/coersing-types-and-java-lang/#calling-java-code","title":"Calling Java code","text":"<p>The Clojure project uses Jetty, a web application server written in Java.  When calling the <code>run-jetty</code> function an Integer type must be passed to the Java object for the port number.</p> <p>When running the Clojure project, the argument supplied for the port number on the command line is treated as a String object.  Therefore we need to explicitly cast the port number from a Java String type to an Java Integer type.</p>"},{"location":"projects/leiningen/todo-app/create-a-webserver-with-ring/coersing-types-and-java-lang/#javalang-library","title":"java.lang library","text":"<p>The <code>java.lang.</code> library is part of all Clojure projects, so as we are going to create a Java Integer it makes sense to simply use the <code>Integer</code> constructor with a String argument which returns a new Integer object.</p> <p><code>(Integer. port-number)</code> calls the <code>java.lang.Integer</code> constructor.</p> <p>The <code>.</code> is actually a macro in Clojure that provides a simple way to work with Java, allowing you to call Java objects as if they were Clojure functions.  In Java you would have to use the form <code>Type instance-name = new Type(argument)</code>.  In our example you would write this in Java as <code>String port = new String(port-number)</code></p> <p>From the Java 8 docs for Integer class: <code>Integer(String s)</code> - constructs a newly allocated Integer object that represents the int value indicated by the String parameter.</p>"},{"location":"projects/leiningen/todo-app/create-a-webserver-with-ring/coersing-types-and-java-lang/#theory-its-java-objects-underneath-strings-numbers","title":"Theory: Its Java Objects underneath strings &amp; numbers","text":"<p>Strings and numbers are represented by Java objects underneath, so its convenient to use Java Classes to manipulate these simple data structures on the rare occasion you need a specific type.</p> <p>You can see the underlying Java types in Clojure using the <code>type</code> or <code>class</code> function.  In the following example you can see the Java types for strings and numbers</p> <p></p>"},{"location":"projects/leiningen/todo-app/create-a-webserver-with-ring/configure-main-namespace/","title":"Configure main namespace","text":"<p>Setting the default namespace will automatically call a function called <code>-main</code> when the Clojure project is run, i.e. via <code>lein run</code></p>"},{"location":"projects/leiningen/todo-app/create-a-webserver-with-ring/configure-main-namespace/#noteadd-main-namespace","title":"Note::Add main namespace","text":"<p>Edit the <code>project.clj</code> file and add <code>:main todo-list.core</code> configuration option.</p> <pre><code>(defproject todo-list \"0.1.0-SNAPSHOT\"\n:description \"A Todo List server-side webapp using Ring &amp; Compojure\"\n:url \"https://github.com/practicalli/clojure-todo-list-example\"\n:license {:name \"Creative Commons Attribution Share-Alike 4.0 International\"\n:url  \"https://creativecommons.org\"}\n:dependencies [[org.clojure/clojure \"1.10.1\"]\n[ring \"1.8.0\"]]\n:repl-options {:init-ns todo-list.core}\n:main todo-list.core)\n</code></pre>"},{"location":"projects/leiningen/todo-app/create-a-webserver-with-ring/include-ring-library/","title":"Including Ring in the Namespace","text":"<p>Add the <code>ring-adaptor-jetty</code> namespace from the ring library, so we can use the functions from that library.</p> <p>The <code>ns</code> expression defines the current namespace as <code>todo-list.core</code>, providing a scope for all the functions and data structures we define within it.</p> <p>The <code>:require</code> expression makes the <code>ring.adaptor.jetty</code> namespace accessible within the <code>todo-list.core</code> namespace.  We can now call any of the public functions in the <code>ring.adaptor.jetty</code> namespace.</p> <p>In <code>ring.adapter.jetty</code> namespace is bound to the <code>webserver</code> alias, providing a short name to refer to functions from that namespace.</p> <p>For example, the <code>run-jetty</code> function is called using <code>webserver/run-jetty</code> rather than the fully qualified namespace of <code>ring.adaptor.jetty/run-jetty</code></p>"},{"location":"projects/leiningen/todo-app/create-a-webserver-with-ring/include-ring-library/#noterequire-the-ring-adaptor","title":"NOTE::Require the ring-adaptor","text":"<p>Delete all code in <code>src/todo_list/core.clj</code> and replace it with the following code.</p> <pre><code>(ns todo-list.core\n(:require [ring.adapter.jetty :as webserver]))\n</code></pre>"},{"location":"projects/leiningen/todo-app/create-a-webserver-with-ring/include-ring-library/#hintusing-aliases-for-namespaces","title":"Hint::Using aliases for namespaces","text":"<p>Using <code>:require</code> we can use the <code>:as</code> keyword to specify an alias for a namespace, a short-hand way of referring to a library.  You can specify any valid Clojure name for a namespace alias, however please consider the readability of your code and choose a meaningful alias name.</p> <p>Later in the workshop we will show other options for including functions from other namespaces.</p>"},{"location":"projects/leiningen/todo-app/create-a-webserver-with-ring/namespaces/","title":"Theory: Namespaces","text":"<p>A namespace in Clojure is used to manage the logical separation of code, usually along features of the application.  A namespace limits the scope of functions and names of data structures to a specific namespace.</p> <p>The names bound to function definitions using the <code>defn</code> function can be used elsewhere in the namespace just by using the name.  The same goes for any values bound to a name using the <code>def</code> function.</p> <p>To use a function outside the namespace, you need to use its namespace and its name, for example <code>clojure.string/reverse</code></p>"},{"location":"projects/leiningen/todo-app/create-a-webserver-with-ring/namespaces/#hintclojure-order-of-evaluation","title":"Hint::Clojure order of evaluation","text":"<p>The code in a Clojure namespace is evaluated only once and from top to bottom.  To call a named function or data structure, it must have its definition evaluated first.</p>"},{"location":"projects/leiningen/todo-app/create-a-webserver-with-ring/namespaces/#include-another-namespace-in-the-repl","title":"Include another namespace in the REPL","text":"<p>The <code>require</code> function will provide access functions and names from specific namespaces and an alias for the namespace can also be specified with the <code>:as</code> directive.</p> <p>A function from that namespace can then be used by prefixing its name with the alias specified in the <code>require</code> expression.</p> <p>Here is an example of including the <code>clojure.string</code> namespace and calling its <code>reverse</code> function</p> <pre><code>(require '[clojure.string :as string])\n(string/reverse \"RedRum\")\n</code></pre>"},{"location":"projects/leiningen/todo-app/create-a-webserver-with-ring/namespaces/#including-another-namespace-in-source-code","title":"Including another namespace in source code","text":"<p>Instead of the <code>require</code> function, add the <code>:require</code> keyword in the namespace definition, <code>ns</code>.</p> <pre><code>(ns todo-list.core\n(:require '[clojure.string :as string])\n(string/reverse \"RedRum\")\n</code></pre> <p>If a function will be used many times in the namespace, you can <code>:refer</code> a function so you can call it just by name, as if it had been defined in the current namespace.</p> <pre><code>(ns todo-list.core\n(:require '[clojure.string :refer [reverse]]))\n(reverse \"RedRum\")\n</code></pre>"},{"location":"projects/leiningen/todo-app/create-a-webserver-with-ring/namespaces/#hintdependency-conflicts-avoid-the-use-function","title":"Hint::Dependency conflicts - avoid the <code>use</code> function","text":"<p>The <code>use</code> function and <code>:use</code> within an <code>ns</code> definition are seen as a bad practice and should be avoided.</p> <p>The <code>use</code> function includes all the functions as if they had been written in the  including a great many unused functions into the namespace.  It will also pull in all the other namespace functions that each namespace included.</p> <p>As Clojure is typically composed of many libraries, its prudent to only include the specific things you need from another namespace.  This also helps reduce conflicts when including multiple libraries in your project.</p>"},{"location":"projects/leiningen/todo-app/create-a-webserver-with-ring/namespaces/#namespaces-outside-the-project","title":"Namespaces outside the project","text":"<p>To use a namespace from a library that is not part of the project, you also need to include it as a dependency.  We saw in add ring dependency how to add a library as a <code>:dependency</code> in the Leiningen <code>project.clj</code> file.</p>"},{"location":"projects/leiningen/todo-app/create-a-webserver-with-ring/run-webserver/","title":"Run webserver","text":"<p>Run the webserver we use Leiningen, the Clojure build automation tool.</p>"},{"location":"projects/leiningen/todo-app/create-a-webserver-with-ring/run-webserver/#run-the-webserver","title":"Run the webserver","text":"<p>In a command line terminal, navigate to the root of your project and type the following command</p> <pre><code>lein run 8000\n</code></pre> <p>This command will start an embedded Jetty web server that listens on http://localhost:8000.</p> <p></p> <p>Open http://localhost:8000 in your browser and try out different pages, such at http://localhost:8000/hello,  /goodbye or  /makes-no-difference.  It should not matter what page you visit, you should get the same response.</p> <p></p> <p>To stop the server, press Control-c in the terminal used to run the lein command.</p>"},{"location":"projects/leiningen/todo-app/database-model/","title":"Creating a database model","text":"<p>Our tasks are quite simple and so its easy to represent them as a single table</p> <ul> <li>id (auto-generated)</li> <li>name of task</li> <li>description of task</li> <li>type of task</li> </ul> <p>Each task will have a unique ID, automatically generated when a new record is created.</p> <p>The name, description and type of task are all strings.</p>"},{"location":"projects/leiningen/todo-app/database-model/#hinttodo-complete-the-database-model","title":"Hint::TODO: Complete the database model","text":"<p>The examples in Database model section are not finished, although hopefully you have learned enough to be able to continue working on this for homework.</p> <p>Please ask questions and share your approaches in the Practicalli Contact channels</p> <p>These examples will be updated to use next.jdbc over Winter 2020</p>"},{"location":"projects/leiningen/todo-app/database-model/#hint-the-type-of-task-could-be-managed-by-a-second-table-that-lists-all-the-tasks-however-this-is-only-meant-to-be-a-simple-app-at-this-stage","title":"Hint:: The type of task could be managed by a second table that lists all the tasks.  However, this is only meant to be a simple app at this stage.","text":""},{"location":"projects/leiningen/todo-app/database-model/#namespace-design","title":"Namespace design","text":"<p>We need to decide what namespace to put our data model in.  It seems to make sense to create a new namespace, to help keep our code clean and to separate concerns. So we will create a namespace <code>todo-list.list</code> namespace.</p> <p>We will need to decide whether to add the <code>items</code> namespace to core or to the handlers... or maybe create another handler namespace for handlers that just access the database</p> <pre><code>(:require [todo-list.items :as items]\n</code></pre>"},{"location":"projects/leiningen/todo-app/database-model/alternative-approaches/","title":"Alternative approaches","text":""},{"location":"projects/leiningen/todo-app/database-model/alternative-approaches/#hint-here-is-an-alterative-approach-to-the-code-just-created-for-comparison-purposes-only-there-is-no-need-to-implement-any-of-the-following-code-unless-you-prefer-this-approach","title":"Hint:: Here is an alterative approach to the code just created, for comparison purposes only.  There is no need to implement any of the following code (unless you prefer this approach)","text":""},{"location":"projects/leiningen/todo-app/database-model/alternative-approaches/#using-uuid-ossp-postgres-plugin","title":"Using UUID-OSSP Postgres plugin","text":"<p>The UUID-OSSP extension to our Heroku postgres database to autogenerate universal ID's (UUID).  These UUID's are managed by postgres and therefore not resistant to braking from code.  The database memory overhead for UUID's is typically less than using text based ID's</p> <pre><code>(defn create-table [db]\n(db/execute!\ndb\n[\"CREATE EXTENSION IF NOT EXISTS \\\"UUID-OSSP\\\"\" ])\n(db/execute!\ndb\n[\"CREATE TABLE IF NOT EXISTS items\n      (id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n       name TEXT NOT NULL,\n       description BOOLEAN NOT NULL DEFAULT FALSE,\n       date_created TIMESTAMPTZ NOT NULL DEFAULT now()\"]))\n</code></pre> <p>Fixme What is the clojure.java.jdbc version of the above ?</p>"},{"location":"projects/leiningen/todo-app/database-model/alternative-approaches/#add-more-database-functions","title":"Add more database functions","text":"<pre><code>(defn create-item [db name description]\n(:id (first (db/query\ndb [\"INSERT INTO items (name, description)\n                    VALUES (?, ?)\n                    RETURN id\"\nname\ndescription]))))\n(defn update-item [db id checked]\n(= [1] (db/execute!\ndb\n[\"UPDATE items\n            SET checked = ?\n            WHERE id = ?\"\nchecked\nid])))\n(defn delete-item [db id]\n(= [1] (db/execute!\ndb\n[\"DELETE FROM items\n            WHERE id = ?\"\nid])))\n(defn read-items [db]\n(db/query\ndb\n[\"SELECT id, name, description, checked, date_created\n     FROM items\n     ORDER BY date_created\"]))\n</code></pre>"},{"location":"projects/leiningen/todo-app/database-model/create-table/","title":"Create table","text":"<p>We have our database model for tasks, so lets create write some code that will create a database table in Postgres, assuming that table is not there already.</p>"},{"location":"projects/leiningen/todo-app/database-model/create-table/#hintrecommend-using-nextjdbc","title":"Hint::Recommend using next.jdbc","text":"<p>next.jdbc is the next generation of clojure.java.jdbc and is recommended instead.  The API is very similar, although with many improvements</p>"},{"location":"projects/leiningen/todo-app/database-model/create-table/#create-items-namespace","title":"Create items namespace","text":"<p>Create a new Clojure file <code>src/todo_list/items.clj</code> and add the following code</p> <p>First add a dependency for Clojure.java.jdbc</p> <pre><code>[clojure.java.jdbc :as sql]\n</code></pre> <p>You <code>items.clj</code> should look like</p> <pre><code>(ns todo-list.items\n(:require [clojure.java.jdbc :as sql]))\n</code></pre> <p>We only want to create the database if it does not already exist, so we can check if the table is already part of the schema</p> <pre><code>(defn db-schema-migrated?\n\"Check if the schema has been migrated to the database\"\n[]\n(-&gt; (sql/query postgres\n[(str \"select count(*) from information_schema.tables \"\n\"where table_name='tasks'\")])\nfirst :count pos?))\n</code></pre> <p>Then add a condition to check if the table exists and if not then create the database table</p> <pre><code>(defn apply-schema-migration\n\"Apply the schema to the database\"\n[]\n(when (not (db-schema-migrated?))\n(sql/db-do-commands postgres\n(sql/create-table-ddl\n:tasks\n[:id :serial \"PRIMARY KEY\"]\n[:body :varchar \"NOT NULL\"]\n[:created_at :timestamp\n\"NOT NULL\" \"DEFAULT CURRENT_TIMESTAMP\"]))))\n</code></pre>"},{"location":"projects/leiningen/todo-app/database-model/create-table/#what-heroku-does-when-you-create-a-database","title":"What Heroku does when you create a database","text":"<p>Heroku Postgres users are granted all non-superuser permissions on their database. These include <code>SELECT, INSERT, UPDATE, DELETE, TRUNCATE, REFERENCES, TRIGGER, CREATE, CONNECT, TEMPORARY, EXECUTE,</code> and <code>USAGE</code>.</p> <p>Heroku runs the SQL below to create a user and database for you.</p> <p>You cannot create or modify databases and roles on Heroku Postgres. The SQL below is for reference only.</p> <pre><code>CREATE ROLE user_name;\nALTER ROLE user_name WITH LOGIN PASSWORD 'password' NOSUPERUSER NOCREATEDB NOCREATEROLE;\nCREATE DATABASE database_name OWNER user_name;\nREVOKE ALL ON DATABASE database_name FROM PUBLIC;\nGRANT CONNECT ON DATABASE database_name TO database_user;\nGRANT ALL ON DATABASE database_name TO database_user;\n</code></pre>"},{"location":"projects/leiningen/todo-app/database-model/create-task/","title":"Create a task","text":"<p>Write a function to create tasks in the database</p> <pre><code>(defn create-task [task-name]\n(sql/insert! postgres\n:tasks [:body] [task-name])\n(println task-name))\n</code></pre>"},{"location":"projects/leiningen/todo-app/database-model/delete-task/","title":"Delete task","text":""},{"location":"projects/leiningen/todo-app/database-model/show-all-task/","title":"Show all tasks","text":"<p>Write a function to list all the tasks in the database, limited to the first 128 items</p> <pre><code>(defn all-tasks []\n(into [] (sql/query postgres [\"select * from tasks order by id desc limit 128\"])))\n</code></pre>"},{"location":"projects/leiningen/todo-app/heroku/","title":"Deploying to Heroku","text":"<p>Heroku is a developer-focused Platform as a Service, using the tools developers know well.  You can simply push your projects to Heroku using Git and your application is deployed for you automatically.</p> <ul> <li>Create a free Heroku account</li> <li>Download the Heroku Toolbelt</li> </ul>"},{"location":"projects/leiningen/todo-app/heroku/#identify-your-laptop-to-heroku","title":"Identify your laptop to Heroku","text":"<p>To be able to deploy your app to Heroku, you first need establish a trusted connection between your laptop and Heroku.  Run the following command (from the Heroku Toolbelt)</p> <pre><code>heroku login\n</code></pre> <p>Enter your username and password for Heroku.  Also enter your 2-factor authorisation code if you enabled that on your Heroku account.</p> <p>Credentials are cached so <code>heroku login</code> should only need to be run once per computer and user account.</p>"},{"location":"projects/leiningen/todo-app/heroku/code-so-far/","title":"Code so far","text":"<p>The code and configuration we have created so far are in the clojure-todo-list-example repository github repository,</p> <p>Code for this section is in the branch called ``</p> <p>If something is not working or you want to speed up, simply clone the project into a new directory using the command:</p> <p><pre><code>git clone https://github.com/practicalli/clojure-todo-list-example\n</code></pre> Once you have cloned the project, checkout the `` branch</p> <pre><code>git checkout\n</code></pre>"},{"location":"projects/leiningen/todo-app/heroku/deploy/","title":"Deploy to Heroku","text":"<p>First we need to create an Heroku app to deploy our Clojure webapp to.  This adds a remote repository we can push our code to using Git.</p> <p>In a command line terminal, navigate to the root of your project (where your <code>project.clj</code> file is)</p> <pre><code>heroku create\n</code></pre> <p>If we have changes in our source code files, then we should first add and then commit them to our local repository.</p> <pre><code>git add .\ngit commit -m \"meaningful commit message\"\n</code></pre> <p>Now push the Clojure webapp code to Heroku and wait a few moments for it to deploy</p> <pre><code>git push heroku master\n</code></pre>"},{"location":"projects/leiningen/todo-app/heroku/deploy/#note-create-an-heroku-app-using-the-heroku-dashboard-or-using-the-following-heroku-toolbelt-command","title":"Note:: Create an Heroku app using the Heroku dashboard or using the following Heroku toolbelt command","text":""},{"location":"projects/leiningen/todo-app/heroku/procfile/","title":"Add Procfile","text":"<p>The <code>Procfile</code> is a simple text file that instructs Heroku how to build and run an application.</p> <p>Using the <code>web:</code> directive, we tell Heroku that our application will listen for web traffic (https).  Heroku sets a value for the port our application can listen to using the <code>PORT</code> configuration variable (ports are dynamically assigned).</p> <p>Create a new file called <code>Procfile</code> with the following text</p> <pre><code>web: java $JVM_OPTS -cp target/todo-list.jar clojure.main -m todo-list.core $PORT\n</code></pre>"},{"location":"projects/leiningen/todo-app/heroku/procfile/#hintget-webserver-port-from-heroku","title":"Hint::Get webserver PORT from Heroku","text":"<p>Heroku dynamically assigns a port number for each <code>web:</code> application deployed.  The Heroku port is set in the PORT environment variable within Heroku each time the application is deployed.</p> <p>\"$PORT\" should be an argument to any service that runs a web server (Jetty, HTTPkit server) or the value should be obtained from the Heroku environment from the Clojure code.</p>"},{"location":"projects/leiningen/todo-app/heroku/procfile/#theory-running-clojure-as-a-java-application","title":"Theory: Running Clojure as a Java application","text":"<p>When you run a Clojure project with Leiningen, two Java virtual machines (JVM's) are started.  One JVM is to run Leiningen and the second JVM is to run your application.  By using Leiningen to run your application in production you are using use extra resources and also risk pulling in unnecessary development libraries &amp; configuration only needed during development.</p> <p>When you run your application in production you can save resources by only running a JVM for your application.  This is done by running a Clojure application just like a Java application, using the <code>java</code> command in the Heroku <code>Procfile</code>.</p>"},{"location":"projects/leiningen/todo-app/heroku/procfile/#theory-building-clojure","title":"Theory: Building Clojure","text":"<p>Building a Clojure project with Leiningen generates a Java <code>jar</code> file, a packaged version of your application.  A jar file generated from Java can be run using <code>java -jar jar-file-name.jar</code>.  However to run your Clojure jar file as a Java application you also need to include the the Clojure core library.</p> <p>Leiningen can also generate an Uberjar.  The uberjar is a jar file that also includes the Clojure library as well as your application and libraries.  As the uberjar contains Clojure, you can run an uberjar in any Java environment.</p> <p>By adding an <code>:uberjar</code> entry to the <code>project.clj</code> then the Leiningen command <code>lein uberjar</code> is run during the build and an uberjar is created.</p> <p>When deploying on Heroku your application is built from your codebase using Leiningen, pulling in all the libraries your application depends on.  When your application is run it is done so as a Java application using only the uberjar, starting just the one JVM.</p> <p>Further reading: https://devcenter.heroku.com/articles/clojure-support</p>"},{"location":"projects/leiningen/todo-app/heroku/procfile/#theory-identifying-an-entry-point-for-your-application","title":"Theory: Identifying an entry point for your application","text":"<p>If your main namespace doesn\u2019t have a <code>:gen-class</code> then you can use <code>clojure.main</code> as your entry point and indicate your app\u2019s main namespace using the -m argument in your Procfile:</p> <pre><code>web: java $JVM_OPTS -cp target/project-standalone.jar clojure.main -m myproject.web $PORT\n</code></pre>"},{"location":"projects/leiningen/todo-app/heroku/update-project/","title":"Update the project","text":"<p>Specify how Leiningen builds the project in more detail and tell Heroku how to run the application.</p>"},{"location":"projects/leiningen/todo-app/heroku/update-project/#configure-the-leiningen-build","title":"Configure the Leiningen Build","text":"<p>Update the Clojure project file with a minimum version number for Leiningen and a name for the jar file that Leiningen will build</p> <p>Edit the <code>project.clj</code> file and add the following lines, usually after the dependencies declarations</p> <pre><code>:min-lein-version \"2.0.0\"\n:uberjar-name \"todo-list.jar\"\n</code></pre> <p>The update project file should look as follows</p> <pre><code>(defproject todo-list \"0.1.0-SNAPSHOT\"\n:description \"A simple webapp using Ring\"\n:url \"http://example.com/FIXME\"\n:license {:name \"Eclipse Public License\"\n:url \"http://www.eclipse.org/legal/epl-v10.html\"}\n:dependencies [[org.clojure/clojure \"1.6.0\"]\n[ring \"1.4.0-beta2\"]\n[compojure \"1.3.4\"]]\n:main todo-list.core\n:min-lein-version \"2.0.0\"\n:uberjar-name \"todo-list.jar\"\n:profiles {:dev\n{:main todo-list.core/-dev-main}})\n</code></pre>"},{"location":"projects/leiningen/todo-app/hiccup/","title":"Hiccup - HTML Library","text":"<p>Hiccup is a library for generating HTML from Clojure, keeping your code consistent and easier to write and maintain.</p> <p>Using HTML, a heading would be written as:</p> <pre><code>&lt;h1 class='heading'&gt;I am a heading&lt;/h1&gt;\n</code></pre> <p>Hiccup uses vectors to define HTML tags and maps to represent styles and other attributes.  So the same heading in Hiccup would be written as:</p> <pre><code>[:h1 {:class \"heading\"} \"I am a heading\"]\n</code></pre>"},{"location":"projects/leiningen/todo-app/hiccup/#using-hiccup","title":"Using Hiccup","text":"<p>Add the hiccup dependency to your <code>project.clj</code> file</p> <pre><code>[hiccup \"1.0.5\"]\n</code></pre> <p>In the REPL, require the hiccup.core library</p> <pre><code>user=&gt; (require '[hiccup.core :as markup])\n;; =&gt; nil\n</code></pre> <p>Or add hiccup to the namespace definition in your Clojure code file.</p> <pre><code>(ns my-namespace.core\n(require '[hiccup.core :as markup]))\n</code></pre>"},{"location":"projects/leiningen/todo-app/hiccup/#writing-hiccup","title":"Writing Hiccup","text":"<p>Here is a basic example of Hiccup syntax:</p> <pre><code>(markup/html [:span {:class \"foo\"} \"bar\"])\n;; =&gt; \"&lt;span class=\\\"foo\\\"&gt;bar&lt;/span&gt;\"\n</code></pre> <p>The first element of the vector is used as the element name. The second attribute can optionally be a map, in which case it is used to supply the element's attributes. Every other element is considered part of the tag's body.</p> <p>Hiccup is intelligent enough to render different HTML elements in different ways, in order to accommodate browser quirks:</p> <pre><code>(markup/html [:script])\n;; =&gt; \"&lt;script&gt;&lt;/script&gt;\"\n(html [:p])\n;; =&gt;  \"&lt;p /&gt;\"\n</code></pre> <p>And provides a CSS-like shortcut for denoting <code>id</code> and <code>class</code> attributes:</p> <pre><code>(markup/html [:div#foo.bar.baz \"bang\"])\n;; =&gt;  \"&lt;div id=\\\"foo\\\" class=\\\"bar baz\\\"&gt;bang&lt;/div&gt;\"\n</code></pre> <p>When writing multiple lines of hiccup markup, wrap them in either a <code>[:div ]</code> or a <code>(list )</code> expression.</p> <pre><code>[:div\n[:h1 \"My Picture Album\"]\n[:img {:src seaside.png} \"A sunny seaside view\"]\n[:img {:src pier.png} \"A walk along the pier\"]]\n</code></pre> <p>If the body of the element is a seq, its contents will be expanded out into the element body. This makes working with forms like <code>map</code> and <code>for</code> more convenient:</p> <pre><code>(html [:ul\n(for [x (range 1 4)]\n[:li x])])\n;; =&gt; \"&lt;ul&gt;&lt;li&gt;1&lt;/li&gt;&lt;li&gt;2&lt;/li&gt;&lt;li&gt;3&lt;/li&gt;&lt;/ul&gt;\"\n</code></pre> <pre><code>(html\n[:ul\n(for [x (range 1 4)]\n[:li x])])\n;; =&gt; \"&lt;ul&gt;&lt;li&gt;1&lt;/li&gt;&lt;li&gt;2&lt;/li&gt;&lt;li&gt;3&lt;/li&gt;&lt;/ul&gt;\"\n</code></pre> <p>The parent tag will still be rendered in the above example, so</p>"},{"location":"projects/leiningen/todo-app/hiccup/#hint-hiccup-reference-and-guides","title":"Hint:: Hiccup reference and guides","text":"<ul> <li>Hiccup API</li> <li>Hiccup Tips - Lisp Cast</li> </ul>"},{"location":"projects/leiningen/todo-app/hiccup/code-so-far/","title":"Code so far","text":""},{"location":"projects/leiningen/todo-app/hiccup/create-new-handler/","title":"Create a new handler","text":"<pre><code>(defn trying-hiccup\n[request]\n(html5 {:lang \"en\"}\n[:head (include-js \"myscript.js\") (include-css \"mystyle.css\")]\n[:body\n[:div [:h1 {:class \"info\"} \"This is Hiccup\"]]\n[:div [:p \"Take a look at the HTML generated in this page, compared to the about page\"]]\n[:div [:p \"Style-wise there is no difference between the pages as we haven't added anything in the stylesheet, however the hiccup page generates a more complete page in terms of HTML\"]]]))\n</code></pre>"},{"location":"projects/leiningen/todo-app/hiccup/create-new-handler/#hintnamed-content-sections","title":"Hint::Named content sections","text":"<p>As content grows, refactor it into <code>def</code> expressions to give content sections names. Pages can use names in the handler code that represent the content, simplifying the handler code.</p> <p>As the project grows, break code into a view namespace with layouts and specific views defined in their own namespace.</p>"},{"location":"projects/leiningen/todo-app/hiccup/updating-handlers-with-hiccup/","title":"Updating handlers with hiccup","text":"<p>Instead of including fiddly html code (and having to make sure you close tags), we will write our markup in Clojure syntax using hiccup.</p>"},{"location":"projects/leiningen/todo-app/hiccup/updating-handlers-with-hiccup/#add-dependencies","title":"Add dependencies","text":"<pre><code>[hiccup \"1.0.5\"]\n</code></pre>"},{"location":"projects/leiningen/todo-app/hiccup/updating-handlers-with-hiccup/#note-add-hiccup-dependencies","title":"Note:: Add hiccup dependencies","text":""},{"location":"projects/leiningen/todo-app/hiccup/updating-handlers-with-hiccup/#require-hiccup","title":"Require hiccup","text":"<pre><code>[hiccup.core :refer :all]\n[hiccup.page :refer :all]\n</code></pre> <p>Your core.clj file should look like this</p> <pre><code>(ns todo-list.core\n(:require [ring.adapter.jetty :as jetty]\n[ring.middleware.reload :refer [wrap-reload]]\n[compojure.core :refer [defroutes GET]]\n[compojure.route :refer [not-found]]\n[ring.handler.dump :refer [handle-dump]]\n[hiccup.core :refer :all]\n[hiccup.page :refer :all]))\n</code></pre>"},{"location":"projects/leiningen/todo-app/hiccup/updating-handlers-with-hiccup/#note-add-hiccup-to-your-namespace","title":"Note:: Add hiccup to your namespace","text":""},{"location":"projects/leiningen/todo-app/hiccup/updating-handlers-with-hiccup/#update-the-welcome-handler","title":"Update the welcome handler","text":"<pre><code>(defn welcome\n\"A ring handler to respond with a simple welcome message\"\n[request]\n(html [:h1 \"Hello, Clojure World\"]\n[:p \"Welcome to your first Clojure app, I now update automatically\"]))\n</code></pre> <p>The <code>html</code> function create html code based on the keywords used.  However, the html function does not create a full html web page.</p>"},{"location":"projects/leiningen/todo-app/hiccup/updating-handlers-with-hiccup/#note-change-the-welcome-handler-to-use-hiccup-rather-than-html-code","title":"Note:: Change the <code>welcome</code> handler to use hiccup rather than html code","text":""},{"location":"projects/leiningen/todo-app/hiccup/updating-handlers-with-hiccup/#update-the-goodbye-handler","title":"Update the goodbye handler","text":"<pre><code>(defn goodbye\n\"A song to wish you goodbye\"\n[request]\n(html5 {:lang \"en\"}\n[:head (include-js \"myscript.js\") (include-css \"mystyle.css\")]\n[:body\n[:div [:h1 {:class \"info\"} \"Walking back to happiness\"]]\n[:div [:p \"Walking back to happiness with you\"]]\n[:div [:p \"Said, Farewell to loneliness I knew\"]]\n[:div [:p \"Laid aside foolish pride\"]]\n[:div [:p \"Learnt the truth from tears I cried\"]]]))\n</code></pre> <p>Using the <code>html5</code> function a complete html page is created, with a header and body section.</p> <p>See the hiccup.page API documentation.</p>"},{"location":"projects/leiningen/todo-app/hiccup/updating-handlers-with-hiccup/#note-change-the-goodbye-handler-to-use-hiccup-rather-than-html","title":"Note:: Change the <code>goodbye</code> handler to use hiccup rather than html","text":""},{"location":"projects/leiningen/todo-app/introducing-ring/","title":"Introducing Ring","text":"<p>Web applications typically run on a web or application server, such as Tomcat or Jetty that provide a Java Servlet Container.</p> <p>The Ring library provides a way to use these servers without being tied to any specific implementation.  Ring provides a common way to</p> <ul> <li>Write your application using Clojure functions and maps</li> <li>Run your application in an auto-reloading development server (wrap-reload)</li> <li>Compile your application into a Java Servlet application</li> <li>Package your application into a Java war file</li> <li>Use a selection of middleware functions</li> <li>Deploy your application in cloud environments like Heroku</li> </ul> <p>In essence, Ring converts the requests that come from the browser into a Clojure map, the request map.  The request map may be passed through one or more middleware functions before being converted to a response map by a handler.  The response map may be processed by one or more middleware functions before being converted by Ring to a web server response.</p> <p></p> <p>In the following sections you will get a better understanding of</p> <ul> <li>how to represent a handler</li> <li>what do requests and responses look like</li> <li>how to separate query parameters from the design of your web app</li> </ul> <p>Ring is the current de facto standard library used to write web applications in Clojure. Higher level frameworks such as Compojure use Ring as a common basis.</p>"},{"location":"projects/leiningen/todo-app/postgres/","title":"Postgres Database","text":"<p>Postgres is a modern and powerful relational database that also supports storing of json, xml and object relationships.  Postgres has a strong open source community behind it and is actively maintained.  Postgres is also highly scalable database with drivers for all the major programming languages.</p> <p>In this workshop we are going to use Heroku Postgres, a database on demand service that requires no local installation.</p>"},{"location":"projects/leiningen/todo-app/postgres/#todocontent-may-be-a-little-dated-sorry","title":"TODO::Content may be a little dated, sorry","text":"<p>Content update during the Winter of 2020</p>"},{"location":"projects/leiningen/todo-app/postgres/#hint-alternatively-you-can-use-a-local-instance-of-postgres-if-you-are-happy-to-run-it-on-your-laptop","title":"Hint:: Alternatively, you can use a local instance of Postgres if you are happy to run it on your laptop.","text":""},{"location":"projects/leiningen/todo-app/postgres/#nextjdbc-a-modern-approach-to-relational-databases-with-clojure","title":"next.jdbc - a modern approach to relational databases with Clojure","text":"<p>See the next.jdbc getting started guide for lots of useful information on writing SQL queries in Clojure.</p>"},{"location":"projects/leiningen/todo-app/postgres/#postgresql-resources","title":"PostgreSQL Resources","text":"<ul> <li>Heroku Postgres</li> <li>Amazon Relational Database Service (RDS) - Amazon Aurora, PostgreSQL, MySQL, MariaDB, Oracle Database, and SQL Server</li> <li>IBM Cloud: Postgres services</li> <li>What is PostgreSQL - postgresqltutorial.com</li> </ul>"},{"location":"projects/leiningen/todo-app/postgres/connect-to-heroku-postgres-from-clients/","title":"Connecting to Heroku Postgres from Postgres Clients","text":"<ul> <li>Command Line</li> <li>GUI tools</li> <li>Operations tools</li> </ul> <p>Heroku Postgres databases are accessible from anywhere via a secure http connection, so you can connect your favourite Postgres client.</p>"},{"location":"projects/leiningen/todo-app/postgres/connect-to-heroku-postgres-from-clients/#view-provisioned-postgres-data-stores","title":"View Provisioned Postgres Data stores","text":"<p>Login to https://data.heroku.com/ to see all the provisioned Heroku Postgres data stores (postgres, redis, etc.) and data clips.</p> <p></p>"},{"location":"projects/leiningen/todo-app/postgres/connect-to-heroku-postgres-from-clients/#view-datastore-add-on","title":"View Datastore add-on","text":"<p>Login to https://heroku.com/ to see the dashboard of Heroku Applications created for that account.  Select a specific Application to see what Datastore add-on is attached</p> <p></p>"},{"location":"projects/leiningen/todo-app/postgres/connect-to-heroku-postgres-from-clients/#database_url-configuration-variable","title":"DATABASE_URL Configuration Variable","text":"<p>Provisioning an Heroku Postgres add-on automatically adds a <code>DATABASE_URL</code> environment variable to the Heroku app.  Use this value to connect consistently throughout the life of your database from the Heroku application</p> <p>To see the value of the <code>DATABSAE_URL</code> use the Heroku Toolbelt command <code>heroku config</code>, specifying the app name if you created multiple Heroku apps for the current project</p> <pre><code>heroku config\n\nheroku config --app my-app-name\n</code></pre> <p></p>"},{"location":"projects/leiningen/todo-app/postgres/connect-to-heroku-postgres-from-clients/#hintdatabase-clients-and-other-services","title":"Hint::Database Clients and other Services","text":"<p>The value of the DATABASE_URL can be used to connect remote database clients (DBeaver, PGAdmin) as well as other services that require a data store.</p>"},{"location":"projects/leiningen/todo-app/postgres/dataclips/","title":"Heroku Dataclips","text":"<p>Its very easy to create quick reports on your Heroku Postgres database using Dataclips and share the results with your company.</p> <p>Heroku Dataclips allow you to write SQL queries that run on Heroku Postgres.  You can then share these queries along with the results via a web address.</p> <p>You can give people the ability to create their own query based on yours and share their version of the query and results.  Its kind of Github or Gists for databases.</p>"},{"location":"projects/leiningen/todo-app/postgres/dataclips/#finding-tables-in-heroku-postgres","title":"Finding tables in Heroku Postgres","text":"<pre><code>SELECT * FROM pg_catalog.pg_tables WHERE schema-name != 'pg_catalog' AND schema-name != 'information_schema'\n</code></pre>"},{"location":"projects/leiningen/todo-app/postgres/environment-variables/","title":"Environment Variables","text":"<p>Add an Heroku Postgres database to the Heroku app creates a <code>DATABASE_URL</code> configuration variable, an environment variable manged by Heroku.  This configuration variable can be used to avoid including database connection details in the code repository.</p>"},{"location":"projects/leiningen/todo-app/postgres/environment-variables/#note-check-your-heroku-app-has-a-database_url-configuration-variable","title":"Note:: Check your Heroku app has a <code>DATABASE_URL</code> configuration variable","text":"<p>List all the configuration variables for your app using the command:</p> <pre><code>heroku config\n</code></pre> <p>The <code>DATABASE_URL</code> contains your username and password for the database, as well as the hostname and database name in the form of:</p> <pre><code>\"postgres://username:password@hostname/database-name\"\n</code></pre>"},{"location":"projects/leiningen/todo-app/postgres/environment-variables/#using-postgresql-client-applications","title":"Using PostgreSQL client applications","text":"<p>The Heroku Postgres database is available via an secure connection from anywhere on the Internet, so you can use these details with your favourite postgres client.  The postgres client must connect over SSL, or the connection will be rejected by Heroku postgres.</p>"},{"location":"projects/leiningen/todo-app/postgres/install/","title":"Postgres install","text":"<p>Using infrastructure or software as a service databases are provisioned, usually by issuing a simple command or using a web based dashboard for that service.</p> <p>Using the Heroku app created previously, a Posgres database will be provisioned.</p> <p>In the root of your Clojure project, run the following Heroku toolbelt command to add a Postgres database to your existing Heroku app</p> <pre><code>heroku addons:create heroku-postgresql\n</code></pre>"},{"location":"projects/leiningen/todo-app/postgres/install/#local-postgresql-install","title":"Local PostgreSQL Install","text":"<ul> <li>Install Postgresql locally - postgresql.org</li> <li>Ubuntu documentation: PostgreSQL</li> <li>Install and use postgresql on Ubuntu 20.04 - digitalocean</li> <li>Ubuntu Linux PostgreSQL downloads - postgresql.org</li> </ul>"},{"location":"projects/leiningen/todo-app/postgres/jira-ticket/","title":"Jira ticket","text":"<p>get-connection requires that provided URIs be structured like so:</p> <p>dbtype://user:password@host:port/database</p> <p>This is often sufficient, but many PostgreSQL URIs require the use of URI parameters to further configure connections. For example, postgresql.heroku.com provides JDBC URIs like this:</p> <p>jdbc:postgresql://ec2-22-11-231-117.compute-1.amazonaws.com:5432/d1kuttup5cbafl6?user=pcgoxvmssqabye&amp;password=PFZXtxaLFhIX-nCA0Vi4UbJ6lH&amp;ssl=true</p> <p>...which, when used outside of Heroku's network, require a further sslfactory=org.postgresql.ssl.NonValidatingFactory parameter.</p> <p>The PostgreSQL JDBC driver supports a number of different URI parameters, and recommends putting credentials into parameters rather than using the user:password@ convention. Peeking over at the Oracle thin JDBC driver's docs, it appears that it expects credentials using its own idiosyncratic convention, user/password@.</p> <p> This all leads me to think that get-connection should pass URIs along to DriverManager without modification, and leave URI format conventions up to the drivers involved. For now, my workaround is to do essentially that, using a map like this as input to with-connection et al.:</p> <p>{:factory #(DriverManager/getConnection (:url %))  :url \"jdbc:postgresql://ec2-22-11-231-117.compute-1.amazonaws.com:5432/d1kuttup5cbafl6?user=pcgoxvmssqabye&amp;password=PFZXtxaLFhIX-nCA0Vi4UbJ6lH&amp;ssl=true\"}</p> <p>That certainly works, but I presume that such a workaround won't occur to many users, despite the docs/source. </p> <p>I don't think I've used java.jdbc enough (or RDMBS' enough of late) to comfortably provide a patch (or feel particularly confident in the suggestion above). Hopefully the report is helpful in any case. Activity</p> <pre><code>All\nComments\nHistory\nActivity\n</code></pre> <p>Sean Corfield added a comment - 14/Jun/12 1:36 AM - edited</p> <p>How about an option that takes a map like:</p> <p>{:connection-uri \"jdbc:postgresql://ec2-22-11-231-117.compute-1.amazonaws.com:5432/d1kuttup5cbafl6?user=pcgoxvmssqabye&amp;password=PFZXtxaLFhIX-nCA0Vi4UbJ6lH&amp;ssl=true\"}</p> <p>Essentially as a shorthand for the workaround you've come up with? Sean Corfield added a comment - 15/Jun/12 10:20 PM</p> <p>Try 0.2.3-SNAPSHOT which has support for :connection-uri and let me know if that is a reasonable solution for you? Chas Emerick added a comment - 18/Jun/12 3:35 PM</p> <p>Yup, 0.2.3-SNAPSHOT's :connection-uri works fine. I've since moved on to using a pooled datasource, but this will hopefully be a more obvious path to newcomers than having to learn about :factory and DriverManager. Sean Corfield added a comment - 18/Jun/12 3:52 PM</p> <p>Resolved by adding :connection-uri option. Carlos Cunha added a comment - 28/Jul/12 8:09 PM</p> <p>accessing an heroku database outside heroku, \"sslfactory=org.postgresql.ssl.NonValidatingFactory\" doesn't work. i get \"ERROR: syntax error at or near \"user\" Position: 13 - (class org.postgresql.util.PSQLException\". this happens whether adding it to :subname or :connection-uri Strings</p> <p>another minor issue - why the documentation of \"with-connection\" (0.2.3) refers the following format for the connection string URI: \"subprotocol://user:password@host:post/subname An optional prefix of jdbc: is allowed.\" but the URI which can actually be parsed successfully is like the one above: jdbc:postgresql://ec2-22-11-231-117.compute-1.amazonaws.com:5432/d1kuttup5cbafl6?user=pcgoxvmssqabye&amp;password=PFZXtxaLFhIX-nCA0Vi4UbJ6lH&amp;ssl=true \"subprotocol://user:password@host:post/subname\" (format like the DATABASE environment variables on heroku) will not be parsed correctly. why the format for the URI that is used on heroku is not supported by the parser?</p> <p>maybe i'm doing something wrong here</p> <p>thanks in advance Sean Corfield added a comment - 29/Jul/12 4:57 PM</p> <p>Carlos, the :connection-uri passes the string directly to the driver with no parsing. The exception you're seeing is coming from inside the PostgreSQL driver so you'll have to consult the documentation for the driver.</p> <p>The three \"URI\" styles accepted by java.jdbc are:</p> <pre><code>:connection-uri - passed directly to the driver with no parsing or other logic in java.jdbc,\n:uri - a pre-parsed Java URI object,\na string literal - any optional \"jdbc:\" prefix is ignored, then the string is parsed by logic in java.jdbc, based on the pattern shown (subprotocol://user:password@host:port/subname).\n</code></pre> <p>If you're using :connection-uri (which is used on its own), you're dealing with the JDBC driver directly.</p> <p>If you're using :uri or a bare string literal, you're dealing with java.jdbc's parsing (implemented by Phil Hagelberg - of Heroku).</p> <p>Hope that clarifies? Carlos Cunha added a comment - 29/Jul/12 8:36 PM</p> <p>Sean, thank you for such comprehensive explanation.</p> <p>Still, it didn't work with any of the options. I used before a postgres JDBC driver to export to the same database (in an SQL modeller - SQLEditor for the MAC) and it worked (though it would connect some times, but others not). The connection String used was like \"jdbc:postgresql://host:port/database?user=xxx&amp;password=yyy&amp;ssl=true&amp;sslfactory=org.postgresql.ssl.NonValidatingFactory\". The driver name was \"org.postgresql.Driver\" (JDBC4). Anyway, time to give up. I will just use a local database.</p> <p>Thank you! Carlos Cunha added a comment - 31/Jul/12 7:20 PM</p> <p>Sean, JDBC combinations were working after. i was neglecting an insert operation in a table with a reserved sql keyword \"user\", so i was getting a \"ERROR: syntax error at or near \"user\" Position: 13\", and therefore the connection was already established at the time.</p> <p>i'm sorry for all the trouble answering the question (_</p> <p>thank you Sean Corfield added a comment - 31/Jul/12 7:46 PM</p> <p>Glad you got to the bottom of it and confirmed that it wasn't a problem in java.jdbc!</p>"},{"location":"projects/leiningen/todo-app/postgres/lobo-table-creation/","title":"How to use Lobos with Heroku","text":"<p>http://pupeno.com/2011/08/20/how-to-use-lobos-with-heroku/</p> <p>Lobos is a Clojure library to create and alter tables which also supports migrations similar to what Rails can do. I like where Lobos is going but it\u2019s a work in progress, so the information here might be out of date soon, beware!</p> <p>Let\u2019s imagine a project called px (for Project X of course) with the usual Leiningen structure. In the src directory you you need to create a lobos directory and inside there let\u2019s get started with config.clj which contains the credentials and other database information:</p> <pre><code>(ns lobos.config)\n\n(def db\n  {:classname \"org.postgresql.Driver\"\n   :subprotocol \"postgresql\"\n   :subname \"//localhost:5432/px\"})\n</code></pre> <p>then we create a simple migration in lobos/migrations.clj that creates the users table: <pre><code>(ns lobos.migrations\n  (:refer-clojure :exclude [alter defonce drop bigint boolean char double float time])\n  (:use (lobos [migration :only [defmigration]] core schema) lobos.config))\n\n(defmigration create-users\n  (up [] (create (table :users\n                   (integer :id :primary-key)\n                   (varchar :email 256 :unique))))\n  (down [] (drop (table :users))))\n</code></pre></p> <p>You run a REPL, load the migrations and run them (using the joyful Clojure example code convention): <pre><code>(require 'lobos.migrations)\n;=&gt; nil\n(lobos.core/run)\n;=&gt; java.lang.Exception: No such global connection currently open: :default-connection, only got [] (NO_SOURCE_FILE:0)\n</code></pre></p> <p>and you get an error because you didn\u2019t open the connection yet, so, let\u2019s do that: <pre><code>(require 'lobos.connectivity)\n;=&gt; nil\n(lobos.connectivity/open-global lobos.config/db)\n;=&gt; {:default-connection {:connection #&lt;Jdbc4Connection org.postgresql.jdbc4.Jdbc4Connection@2ab600af&gt;, :db-spec {:classname \"org.postgresql.Driver\", :subprotocol \"postgresql\", :subname \"//localhost:5432/px\"}}}\n</code></pre></p> <p>and now it works: <pre><code>(lobos.core/run)\n; create-users\n;=&gt; nil\n</code></pre></p> <p>and you can also rollback: <pre><code>(lobos.core/rollback)\n; create-users\n;=&gt; nil\n</code></pre></p> <p>You might be tempted to open the global connection in your config.clj and that might be fine for some, but I found it problematic that the second time I load the file, I get an error: \u201cjava.lang.Exception: A global connection by that name already exists (:default-connection) (NO_SOURCE_FILE:0)\u201d.</p> <p>My solution was to write a function called open-global-when-necessary that will open a global connection only when there\u2019s none or when the database specification changed, and will close the previous connection in that case, leaving a config.clj that looks like:</p> <pre><code>(ns lobos.config\n  (:require lobos.connectivity))\n\n(defn open-global-when-necessary\n  \"Open a global connection only when necessary, that is, when no previous\n  connection exist or when db-spec is different to the current global\n  connection.\"\n  [db-spec]\n  ;; If the connection credentials has changed, close the connection.\n  (when (and (@lobos.connectivity/global-connections :default-connection)\n             (not= (:db-spec (@lobos.connectivity/global-connections :default-connection)) db-spec))\n    (lobos.connectivity/close-global))\n  ;; Open a new connection or return the existing one.\n  (if (nil? (@lobos.connectivity/global-connections :default-connection))\n    ((lobos.connectivity/open-global db-spec) :default-connection)\n    (@lobos.connectivity/global-connections :default-connection)))\n\n(def db\n  {:classname \"org.postgresql.Driver\"\n   :subprotocol \"postgresql\"\n   :subname \"//localhost:5432/px\"})\n\n(open-global-when-necessary db)\n</code></pre> <p>That works fine locally, so let\u2019s move to Heroku. To get started with Clojure on Heroku I recommend you read:</p> <pre><code>Getting Started With Clojure on Heroku/Cedar\nBuilding a Database-Backed Clojure Web Application\n</code></pre> <p>I took the code used to extract the database specification from DATABASE_URL but I modified it so I don\u2019t depend on that environment variable existing on my local computer and I ended up with the following config.clj:</p> <pre><code>(ns lobos.config\n  (:require [clojure.string :as str] lobos.connectivity)\n  (:import (java.net URI)))\n\n(defn heroku-db\n  \"Generate the db map according to Heroku environment when available.\"\n  []\n  (when (System/getenv \"DATABASE_URL\")\n    (let [url (URI. (System/getenv \"DATABASE_URL\"))\n          host (.getHost url)\n          port (if (pos? (.getPort url)) (.getPort url) 5432)\n          path (.getPath url)]\n      (merge\n       {:subname (str \"//\" host \":\" port path)}\n       (when-let [user-info (.getUserInfo url)]\n         {:user (first (str/split user-info #\":\"))\n          :password (second (str/split user-info #\":\"))})))))\n\n(defn open-global-when-necessary\n  \"Open a global connection only when necessary, that is, when no previous\n  connection exist or when db-spec is different to the current global\n  connection.\"\n  [db-spec]\n  ;; If the connection credentials has changed, close the connection.\n  (when (and (@lobos.connectivity/global-connections :default-connection)\n             (not= (:db-spec (@lobos.connectivity/global-connections :default-connection)) db-spec))\n    (lobos.connectivity/close-global))\n  ;; Open a new connection or return the existing one.\n  (if (nil? (@lobos.connectivity/global-connections :default-connection))\n    ((lobos.connectivity/open-global db-spec) :default-connection)\n    (@lobos.connectivity/global-connections :default-connection)))\n\n(def db\n  (merge {:classname \"org.postgresql.Driver\"\n          :subprotocol \"postgresql\"\n          :subname \"//localhost:5432/px\"}\n         (heroku-db)))\n\n(open-global-when-necessary db)\n</code></pre> <p>After you push to Heroku, you can run heroku run lein repl, load lobos.config and run the migrations just as if they were local.</p>"},{"location":"projects/leiningen/todo-app/postgres/pg-admin/","title":"pgAdmin","text":""},{"location":"projects/leiningen/todo-app/postgres/postgres-cli/","title":"Postgres CLI","text":"<p>Heroku toolbelt has many commands for viewing information and querying the Heroku Postgres database.  Here is a breakdown of the most commonly used commands.</p> <p>Postgres Command Line Client required</p> <p>Heroku Toolbelt <code>pg</code> commands require a working postgres command line client to be installed and available on your operating system path.</p> <p>Ubuntu documentation: PostgreSQL has details on installing postgresql clients.</p>"},{"location":"projects/leiningen/todo-app/postgres/postgres-cli/#postgres-information","title":"Postgres Information","text":"<p>To see all PostgreSQL databases provisioned by your application and the identifying characteristics of each (db size, status, number of tables, PG version, creation date etc\u2026) use the <code>heroku pg:info</code> command.</p> <pre><code>$ heroku pg:info\n=== HEROKU_POSTGRESQL_BROWN_URL (DATABASE_URL)\nPlan:        Hobby-dev\nStatus:      available\nConnections: 0\nPG Version:  9.3.3\nCreated:     2014-03-20 23:33 UTC\nData Size:   6.5 MB\nTables:      1\nRows:        4/10000 (In compliance)\nFork/Follow: Unsupported\nRollback:    Unsupported\n</code></pre> <p>To continuously monitor the status of your database, pass pg:info through the unix watch command: <pre><code>watch heroku pg:info\n</code></pre></p>"},{"location":"projects/leiningen/todo-app/postgres/postgres-cli/#running-queries-on-postgres","title":"Running Queries on Postgres","text":"<p>psql is the native PostgreSQL interactive terminal and is used to execute queries and issue commands to the connected database.  To establish a psql session with your remote database use heroku pg:psql. You must have PostgreSQL installed on your system to use <code>heroku pg:psql</code>.</p> <pre><code>$ heroku pg:psql\n---&gt; Connecting to HEROKU_POSTGRESQL_BROWN_URL (DATABASE_URL)\npsql (9.2.6, server 9.3.3)\nWARNING: psql version 9.2, server version 9.3.\n         Some psql features might not work.\nSSL connection (cipher: DHE-RSA-AES256-SHA, bits: 256)\nType \"help\" for help.\n\nheroku-app-name::BROWN=&gt; \\dt\n               List of relations\n Schema |     Name     | Type  |     Owner\n--------|--------------|-------|----------------\n public | pl0_programs | table | moiwgreelvvujc\n(1 row)\nheroku-app-name::BROWN=&gt;\nheroku-app-name::BROWN=&gt; SELECT * FROM pl0_programs;\nname  |           source\n--------|-----------------------------\n 3m2m1  |                     3-2-1\\r+\n        |\nap1tb  | a+1*b\\r                    +\n        |\ntest   |                     a+1*b\\r+\n        |           \\r               +\n        |\nlolwut |                     3-2-1\\r+\n        |\n(4 rows)\n</code></pre> <p>If you have more than one database, specify the database to connect to as the first argument to the command (the database located at <code>DATABASE_URL</code> is used by default).</p> <pre><code>$ heroku pg:psql HEROKU_POSTGRESQL_GRAY\nConnecting to HEROKU_POSTGRESQL_GRAY... done\n</code></pre>"},{"location":"projects/leiningen/todo-app/postgres/postgres-cli/#reset-your-database","title":"Reset your database","text":"<p>To drop and recreate your database use <code>heroku pg:reset</code></p> <pre><code>$ heroku pg:reset DATABASE\n\n!    WARNING: Destructive Action\n !    This command will affect the app: heroku-app-name\n !    To proceed, type \"pegjspl0\" or re-run this command with --confirm heroku-app-name\n\n&gt; heroku-app-name\nResetting HEROKU_POSTGRESQL_BROWN_URL (DATABASE_URL)... done\n</code></pre> <p>Then restart the server</p> <pre><code>$ heroku ps:restart\nRestarting dynos... done\n</code></pre> <p>There are many more Heroku toolbelt commands you can use for postgres. [TODO: Link to postgres command]</p>"},{"location":"projects/leiningen/todo-app/postgres/postgres-cli/#resources","title":"Resources","text":"<ul> <li>Accessing a Database - postgresql.org</li> <li>Ubuntu documentation: PostgreSQL - client and server install</li> </ul>"},{"location":"projects/leiningen/todo-app/postgres/postgres-commands/","title":"pg:info","text":"<p>To see all PostgreSQL databases provisioned by your application and the identifying characteristics of each (db size, status, number of tables, PG version, creation date etc\u2026) use the heroku pg:info command.</p> <pre><code>heroku pg:info\n=== HEROKU_POSTGRESQL_BROWN_URL (DATABASE_URL)\nPlan:        Hobby-dev\nStatus:      available\nConnections: 0\nPG Version:  9.3.3\nCreated:     2014-03-20 23:33 UTC\nData Size:   6.5 MB\nTables:      1\nRows:        4/10000 (In compliance)\nFork/Follow: Unsupported\nRollback:    Unsupported\n\nTo continuously monitor the status of your database, pass pg:info through the unix watch command:\n\nwatch heroku pg:info\n-bash: watch: no se encontr\u00f3 la orden\nbrew install watch\nwatch heroku pg:info\n...\n</code></pre>"},{"location":"projects/leiningen/todo-app/postgres/postgres-commands/#pgpsql","title":"pg:psql","text":"<p>psql is the native PostgreSQL interactive terminal and is used to execute queries and issue commands to the connected database.</p> <p>To establish a psql session with your remote database use heroku pg:psql. You must have PostgreSQL installed on your system to use heroku pg:psql.</p> <pre><code>heroku pg:psql\n---&gt; Connecting to HEROKU_POSTGRESQL_BROWN_URL (DATABASE_URL)\npsql (9.2.6, server 9.3.3)\nWARNING: psql version 9.2, server version 9.3.\n         Some psql features might not work.\nSSL connection (cipher: DHE-RSA-AES256-SHA, bits: 256)\nType \"help\" for help.\n\npegjspl0::BROWN=&gt; \\dt\n               List of relations\n Schema |     Name     | Type  |     Owner\n--------|--------------|-------|----------------\n public | pl0_programs | table | moiwgreelvvujc\n(1 row)\npegjspl0::BROWN=&gt;\npegjspl0::BROWN=&gt; SELECT * FROM pl0_programs;\nname  |           source\n--------|-----------------------------\n 3m2m1  |                     3-2-1\\r+\n        |\nap1tb  | a+1*b\\r                    +\n        |\ntest   |                     a+1*b\\r+\n        |           \\r               +\n        |\nlolwut |                     3-2-1\\r+\n        |\n(4 rows)\n</code></pre> <p>If you have more than one database, specify the database to connect to as the first argument to the command (the database located at DATABASE_URL is used by default).</p> <pre><code>heroku pg:psql HEROKU_POSTGRESQL_GRAY\nConnecting to HEROKU_POSTGRESQL_GRAY... done\n...\n</code></pre>"},{"location":"projects/leiningen/todo-app/postgres/postgres-commands/#pgreset","title":"pg:reset","text":"<p>To drop and recreate your database use pg:reset:</p> <pre><code>heroku pg:reset DATABASE\n\n!    WARNING: Destructive Action\n !    This command will affect the app: pegjspl0\n !    To proceed, type \"pegjspl0\" or re-run this command with --confirm pegjspl0\n\n&gt; pegjspl0\nResetting HEROKU_POSTGRESQL_BROWN_URL (DATABASE_URL)... done\nheroku ps:restart\nRestarting dynos... done\n</code></pre>"},{"location":"projects/leiningen/todo-app/postgres/postgres-commands/#pgpull","title":"pg:pull","text":"<p><code>pg:pull</code> can be used to pull remote data from a Heroku Postgres database to a database on your local machine. The command looks like this:</p> <pre><code>pg_ctl -D /usr/local/var/postgres -l /usr/local/var/postgres/server.log start\nserver starting\n</code></pre>"},{"location":"projects/leiningen/todo-app/postgres/postgres-commands/#create-local-database","title":"Create local database","text":"<pre><code>heroku pg:pull HEROKU_POSTGRESQL_MAGENTA mylocaldb --app sushi\n</code></pre> <p>Create a new local database named <code>mylocaldb</code>,  then pull data from database at DATABASE_URL from the app sushi.</p> <p>In order to prevent accidental data overwrites and loss, the local database must not exist. You will be prompted to drop an already existing local database before proceeding.</p>"},{"location":"projects/leiningen/todo-app/postgres/postgres-commands/#pgpush","title":"pg:push","text":"<p>Like pull but in reverse, <code>pg:push</code> will push data from a local database into a remote Heroku Postgres database. The command looks like this:</p> <pre><code>heroku pg:push mylocaldb HEROKU_POSTGRESQL_MAGENTA --app sushi\n</code></pre> <p>This command will take the local database mylocaldb and push it to the database at DATABASE_URL on the app sushi. In order to prevent accidental data overwrites and loss, the remote database must be empty. You will be prompted to pg:reset an already a remote database that is not empty.</p>"},{"location":"projects/leiningen/todo-app/postgres/postgres-commands/#backups","title":"Backups","text":"<p>Heroku Postgres Backups service automates backup of the database pointed to by the DATABASE_URL environment variable in the Heroku app. Ensure the database is promoted</p> <pre><code>heroku pg:promote HEROKU_POSTGRESQL_VIOLET --app your-app\n</code></pre>"},{"location":"projects/leiningen/todo-app/postgres/postgres-commands/#monitoring-database-provisioning","title":"Monitoring database provisioning","text":"<p>When provisioning larger databases, they may take several minutes to become available.  Using the <code>heroku pg:wait</code> command you can see when the database provisioning is complete.</p> <p>You may also want to use heroku pg:wait when putting your application into maintenenace mod [TODO: expand on this]</p> <pre><code>heroku help pg:wait\n\nUsage: heroku pg:wait [DATABASE]\nmonitor database creation, exit when complete\ndefaults to all databases if no DATABASE is specified\n\n--wait-interval SECONDS      # how frequently to poll (to avoid rate-limiting)\n</code></pre>"},{"location":"projects/leiningen/todo-app/postgres/postgres-commands/#setting-a-name-for-a-new-database","title":"Setting a name for a new database","text":"<p>Once Heroku Postgres has been added a <code>HEROKU_POSTGRESQL_COLOR_URL</code> setting will be available in the app configuration and will contain the URL used to access the newly provisioned Heroku Postgres service. This can be confirmed using the heroku config command.</p> <pre><code>heroku config -s | grep HEROKU_POSTGRESQL\nHEROKU_POSTGRESQL_RED_URL=postgres://username:password@hostname.domain.com:1234/database-name\n</code></pre> <p>You can choose the alias that the add-on uses on the application using the --as flag. This will affect the name of the variable the add-on adds to the application:</p> <pre><code>heroku addons:create heroku-postgresql:hobby-dev --as USERS_DB\nAdding heroku-postgresql:hobby-dev to sushi... done, v69 (free)\nAttached as USERS_DB\nDatabase has been created and is available\n\nheroku config -s | grep USERS_DB\nUSERS_DB_URL=postgres://postgres://username:password@hostname.domain.com:1234/database-name\n</code></pre>"},{"location":"projects/leiningen/todo-app/postgres/postgres-performance-analytics/","title":"Performance Analytics","text":"<p>Performance Analytics is the visibility suite for Heroku Postgres. It enables you to monitor the performance of your database and to diagnose potential problems. It consists of several components:</p>"},{"location":"projects/leiningen/todo-app/postgres/postgres-performance-analytics/#expensive-queries","title":"Expensive Queries","text":"<p>The leading cause of poor database performance are queries that are not optimised . Expensive Queries reports, available through the Heroku dashboard helps to identify and understand the queries that take the most time in your database.</p>"},{"location":"projects/leiningen/todo-app/postgres/postgres-performance-analytics/#logging","title":"Logging","text":"<p>If your service emits logs on database access, you will be able to retrieve them through Heroku\u2019s log-stream:</p> <pre><code> heroku logs -t\n</code></pre> <p>To see logs from the database service itself you can also use heroku logs but with the -p postgres flag indicating that you only wish to see the logs from PostgreSQL.</p> <pre><code> heroku logs -p postgres -t\n</code></pre> <p>In order to have minimal impact on database performance, logs are delivered on a best-effort basis.</p> <p>Read more about Heroku Postgres log statements here.</p>"},{"location":"projects/leiningen/todo-app/postgres/postgres-performance-analytics/#pgdiagnose","title":"pg:diagnose","text":"<p>pg:diagnose performs a number of useful health and diagnostic checks that help analyst and optimize the performance of a database. The report that can be shared with others on your team or with Heroku Support.</p> <p>Before taking any action based on a report, be sure to carefully consider the impact to your database and application.</p> <pre><code> heroku pg:diagnose --app sushi\nReport 1234abc\u2026 for sushi::HEROKU_POSTGRESQL_MAROON_URL\navailable for one month after creation on 2014-07-03 21:29:40.868968+00\n\nGREEN: Connection Count\nGREEN: Long Queries\nGREEN: Idle in Transaction\nGREEN: Indexes\nGREEN: Bloat\nGREEN: Hit Rate\nGREEN: Blocking Queries\nGREEN: Load\n</code></pre>"},{"location":"projects/leiningen/todo-app/postgres/postgres-performance-analytics/#check-connection-count","title":"Check: Connection Count","text":"<p>Each Postgres connection requires memory. And database plans have a limit on the number of connections they can accept. If you are using too many connections you may want to consider using a connection pool such as PgBouncer or migrating to a larger plan with more RAM.</p>"},{"location":"projects/leiningen/todo-app/postgres/postgres-performance-analytics/#long-running-queries-idle-in-transaction","title":"Long Running Queries, Idle in Transaction","text":"<p>Long-running queries and transactions can cause problems with bloat that prevents auto vacuuming and causes followers to lag behind. They also create locks on your data which can prevent other transactions from running. You may want to consider killing the long running query with pg:kill.</p>"},{"location":"projects/leiningen/todo-app/postgres/postgres-performance-analytics/#check-indexes","title":"Check: Indexes","text":"<p>The Indexes check includes three classes of indexes.</p> <p>Never Used Indexes have not been used (since the last manual database statistics refresh). These indexes are typically safe to drop, unless they are in use on a follower.</p> <p>Low Scans, High Writes indexes are used, but infrequently relative to their write volume. Indexes are updated on every write, so are especially costly on a high write table. Consider the cost of slower writes against the performance improvements that these indexes provide.</p> <p>Seldom used Large Indexes are not used often and take up a significant space both on disk and in cache (RAM). These indexes may still be important to your application for example if they are used by periodic jobs or infrequent traffic patterns.</p> <p>Index usage is only tracked on the database receiving the query. If you use followers for reads, this check will not account for usage made against the follower and is likely inaccurate.</p>"},{"location":"projects/leiningen/todo-app/postgres/postgres-performance-analytics/#check-bloat","title":"Check: Bloat","text":"<p>Because Postgres uses MVCC, old versions of updated or deleted rows are simply made invisible rather than modified in place.</p> <p>Under normal operation an auto vacuum process goes through and asynchronously cleans these up. However sometimes it cannot work fast enough or otherwise cannot prevent some tables from becoming bloated.</p> <p>High bloat can slow down queries, waste space, and even increase load as the database spends more time looking through dead rows.</p> <p>You can manually vacuum a table with the VACUUM (VERBOSE, ANALYZE); command in psql. If this occurs frequently you may want to make auto-vacuum more aggressive.</p>"},{"location":"projects/leiningen/todo-app/postgres/postgres-performance-analytics/#check-hit-rate","title":"Check: Hit Rate","text":"<p>This checks the overall index hit rate, the overall cache hit rate, and the individual index hit rate per table. It is very important to keep hit rates in the 99+% range. Databases with lower hit rates perform significantly worse as they have to hit disk instead of reading from memory. Consider migrating to a larger plan for low cache hit rates, and adding appropriate indexes for low index hit rates. Check: Blocking Queries</p> <p>Some queries can take locks that block other queries from running. Normally these locks are acquired and released very quickly and do not cause any issues. In pathological situations however some queries can take locks that cause significant problems if held too long. You may want to consider killing the query with pg:kill.</p>"},{"location":"projects/leiningen/todo-app/postgres/postgres-performance-analytics/#check-load","title":"Check: Load","text":"<p>There are many, many reasons that load can be high on a database: bloat, CPU intensive queries, index building, and simply too much activity on the database. Review your access patterns, and consider migrating to a larger plan which would have a more powerful processor.</p>"},{"location":"projects/leiningen/todo-app/postgres/postgres-toolbelt-commands/","title":"Postgres toolbelt commands","text":""},{"location":"projects/leiningen/todo-app/postgres/postgres-toolbelt-commands/#heroku-toolbelt-for-postgres","title":"Heroku Toolbelt for Postgres","text":"<p>Heroku Postgres is integrated directly into the Heroku toolbelt and offers several commands that automate many common tasks associated with managing a database-backed application.</p> <p>psql required for some commands</p> <p>Some commands require a postgres client to be installed on your computer to work</p>"},{"location":"projects/leiningen/todo-app/postgres/postgres-toolbelt-commands/#pginfo","title":"pg:info","text":"<p>To see all PostgreSQL databases provisioned by your application and the identifying characteristics of each (db size, status, number of tables, PG version, creation date etc\u2026) use the heroku pg:info command.</p> <pre><code> heroku pg:info\n=== HEROKU_POSTGRESQL_RED\nPlan         Standard 0\nStatus       available\nData Size    82.8 GB\nTables       13\nPG Version   9.1.3\nCreated      2012-02-15 09:58 PDT\n=== HEROKU_POSTGRESQL_GRAY\nPlan         Standard 2\nStatus       available\nData Size    82.8 GB\n</code></pre> <p>To continuously monitor the status of your database, pass pg:info through the unix watch command:</p> <pre><code> watch heroku pg:info\n</code></pre>"},{"location":"projects/leiningen/todo-app/postgres/postgres-toolbelt-commands/#pgpsql","title":"pg:psql","text":"<p>psql is the native PostgreSQL interactive terminal and is used to execute queries and issue commands to the connected database.</p> <p>To establish a psql session with your remote database use heroku pg:psql.</p> <p>You must have PostgreSQL installed on your system to use heroku pg:psql.</p> <pre><code> heroku pg:psql\nConnecting to HEROKU_POSTGRESQL_RED... done\npsql (9.1.3, server 9.1.3)\nSSL connection (cipher: DHE-RSA-AES256-SHA, bits: 256)\nType \"help\" for help.\n\nrd2lk8ev3jt5j50=&gt; SELECT * FROM users;\nIf you have more than one database, specify the database to connect to (just the color works as a shorthand) as the first argument to the command (the database located at DATABASE_URL is used by default).\n\nheroku pg:psql gray\nConnecting to HEROKU_POSTGRESQL_GRAY... done\n</code></pre>"},{"location":"projects/leiningen/todo-app/postgres/postgres-toolbelt-commands/#pgpush-and-pgpull","title":"pg:push and pg:pull","text":"<p>pg:pull can be used to pull remote data from a Heroku Postgres database to a database on your local machine. The command looks like this:</p> <pre><code> heroku pg:pull HEROKU_POSTGRESQL_MAGENTA mylocaldb --app sushi\n</code></pre> <p>This command will create a new local database named \u201cmylocaldb\u201d and then pull data from database at DATABASE_URL from the app \u201csushi\u201d. In order to prevent accidental data overwrites and loss, the local database must not exist. You will be prompted to drop an already existing local database before proceeding.</p> <p>If providing a Postgres user or password for your local DB is necessary, use the appropriate environment variables like so:</p> <p>PGUSER=postgres PGPASSWORD=password heroku pg:pull HEROKU_POSTGRESQL_MAGENTA mylocaldb --app sushi</p> <p>Note: like all pg:* commands you can use the shorthand identifiers here, so to pull data from HEROKU_POSTGRESQL_RED on the app \u201csushi\u201d you could do heroku pg:pull sushi::RED mylocaldb. pg:push</p> <p>Like pull but in reverse, pg:push will push data from a local database into a remote Heroku Postgres database. The command looks like this:</p> <pre><code> heroku pg:push mylocaldb HEROKU_POSTGRESQL_MAGENTA --app sushi\n</code></pre> <p>This command will take the local database \u201cmylocaldb\u201d and push it to the database at DATABASE_URL on the app \u201csushi\u201d. In order to prevent accidental data overwrites and loss, the remote database must be empty. You will be prompted to pg:reset an already a remote database that is not empty.</p> <p>Usage of the PGUSER and PGPASSWORD for your local database is also supported for pg:push, just like for the pg:pull commands. Troubleshooting</p> <p>These commands rely on the pg_dump and pg_restore binaries that are included in a Postgres installation. It is somewhat common, however, for the wrong binaries to be loaded in $PATH. Errors such as</p> <p><pre><code>!    createdb: could not connect to database postgres: could not connect to server: No such file or directory\n!      Is the server running locally and accepting\n!      connections on Unix domain socket \"/var/pgsql_socket/.s.PGSQL.5432\"?\n!\n!    Unable to create new local database. Ensure your local Postgres is working and try again.\n</code></pre> and</p> <pre><code>pg_dump: server version: 9.3.1; pg_dump version: 9.1.5\npg_dump: aborting because of server version mismatch\npg_dump: *** aborted because of error\npg_restore: [archiver] input file is too short (read 0, expected 5)\n</code></pre> <p>are both often a result of this incorrect $PATH problem. This problem is especially common with Postgres.app users, as the post-install step of adding /Applications/Postgres.app/Contents/MacOS/bin to $PATH is easy to forget.</p>"},{"location":"projects/leiningen/todo-app/postgres/postgres-toolbelt-commands/#pgps-pgkill-pgkillall","title":"pg:ps pg:kill pg:killall","text":"<p>These commands give you view and control over currently running queries.</p> <p>The pg:ps command queries the pg_stat_statements table in postgres to give a concise view into currently running queries.</p> <pre><code> heroku pg:ps\n procpid |         source            |   running_for   | waiting |         query\n---------|---------------------------|-----------------|---------|-----------------------\n   31776 | psql                      | 00:19:08.017088 | f       | &lt;IDLE&gt; in transaction\n   31912 | psql                      | 00:18:56.12178  | t       | select * from hello;\n32670 | Heroku Postgres Data Clip | 00:00:25.625609 | f       | BEGIN READ ONLY; select 'hi'\n(3 rows)\n</code></pre> <p>The procpid column can then be used to cancel or terminate those queries with pg:kill. Without any arguments pg_cancel_backend is called on the query which will attempt to cancel the query. In some situations that can fail, in which case the --force option can be used to issue pg_terminate_backend which drops the entire connection for that query.</p> <pre><code> heroku pg:kill 31912\npg_cancel_backend\n-------------------\n t\n(1 row)\nheroku pg:kill --force 32670\npg_terminate_backend\n----------------------\n t\n(1 row)\n</code></pre> <p><code>pg:killall</code> is similar to pg:kill except it will cancel or terminate every query on your database.</p>"},{"location":"projects/leiningen/todo-app/postgres/postgres-toolbelt-commands/#pgpromote","title":"pg:promote","text":"<p>In setups where more than one database is provisioned (common use-cases include a master/slave high-availability setup or as part of the database upgrade process) it is often necessary to promote an auxiliary database to the primary role. This is accomplished with the heroku pg:promote command.</p> <pre><code> heroku pg:promote HEROKU_POSTGRESQL_GRAY_URL\nPromoting HEROKU_POSTGRESQL_GRAY_URL to DATABASE_URL... done\n</code></pre> <p><code>pg:promote</code> works by setting the value of the <code>DATABASE_URL</code> config var (which your application uses to connect to the primary database) to the newly promoted database\u2019s URL and restarting your app. The old primary database location is still accessible via its <code>HEROKU_POSTGRESQL_COLOR_URL</code> setting.</p> <p>After a promotion, the demoted database is still provisioned and incurring charges. If it\u2019s no longer need you can remove it with</p> <pre><code>heroku addons:destroy HEROKU_POSTGRESQL_COLOR.\n</code></pre>"},{"location":"projects/leiningen/todo-app/postgres/postgres-toolbelt-commands/#pgcredentials","title":"pg:credentials","text":"<p>Heroku Postgres provides convenient access to the credentials and location of your database should you want to use a GUI to access your instance.</p> <p>The database name argument must be provided with pg:credentials command. Use DATABASE for your primary database.</p> <pre><code> heroku pg:credentials DATABASE\nConnection info string:\n   \"dbname=dee932clc3mg8h host=ec2-123-73-145-214.compute-1.amazonaws.com port=6212 user=user3121 password=98kd8a9 sslmode=require\"\n</code></pre> <p>It is a good security practice to rotate the credentials for important services on a regular basis. On Heroku Postgres this can be done with heroku pg:credentials --reset.</p> <pre><code> heroku pg:credentials HEROKU_POSTGRESQL_GRAY_URL --reset\n</code></pre> <p>New credentials are created for the database and the related config vars on your Heroku application are updated.</p> <p>On Standard, Premium, and Enterprise tier databases the old credentials are not removed immediately.</p> <p>All of the open connections remain open until the currently running tasks complete, then those credentials are updated. This is to make sure that any background jobs or other workers running on your production environment aren\u2019t abruptly terminated, potentially leaving the system in an inconsistent state.</p>"},{"location":"projects/leiningen/todo-app/postgres/postgres-toolbelt-commands/#pgreset","title":"pg:reset","text":"<p>The PostgreSQL user your database is assigned doesn\u2019t have permission to create or drop databases. To drop and recreate your database use pg:reset.</p> <pre><code> heroku pg:reset DATABASE\n</code></pre>"},{"location":"projects/leiningen/todo-app/refactor-namespace/","title":"Refactor Core Namespace","text":"<p>The <code>todo-list.core</code> namespace is getting quite full and only going to get more code, unless we refactor the design and create some additional namespaces.</p> <p>A namespace is a way to group behaviour (functions) and data (data structures / defs) in one scope.  Functions can be defined as private to that scope, so only other functions in the same namespace can call them.</p>"},{"location":"projects/leiningen/todo-app/refactor-namespace/base-routes/","title":"Base routes","text":"<p><code>handlers.clj</code> should look as follows:</p> <pre><code>(ns todo-list.handlers\n(:use\n[hiccup.core]\n[hiccup.page]))\n(defn welcome\n\"A ring handler to respond with a simple welcome message\"\n[request]\n(html [:h1 \"Hello, Clojure World\"]\n[:p \"Welcome to your first Clojure app, I now update automatically\"]))\n(defn goodbye\n\"A song to wish you goodbye\"\n[request]\n(html5 {:lang \"en\"}\n[:head (include-js \"myscript.js\") (include-css \"mystyle.css\")]\n[:body\n[:div [:h1 {:class \"info\"} \"Walking back to happiness\"]]\n[:div [:p \"Walking back to happiness with you\"]]\n[:div [:p \"Said, Farewell to loneliness I knew\"]]\n[:div [:p \"Laid aside foolish pride\"]]\n[:div [:p \"Learnt the truth from tears I cried\"]]]))\n(defn about\n\"Information about the website developer\"\n[request]\n(html [:h1 \"About the Website\"]\n[:p \"I am an awesome Clojure developer, well getting there... trying some Hiccup now\"]))\n(defn hello\n\"A simple personalised greeting showing the use of variable path elements\"\n[request]\n(let [name (get-in request [:route-params :name])]\n{:status 200\n:body (str \"Hello \" name \".  I got your name from the web URL\")\n:headers {}}))\n(def operands {\"+\" + \"-\" - \"*\" * \":\" /})\n(defn calculator\n\"A very simple calculator that can add, divide, subtract and multiply.  This is done through the magic of variable path elements.\"\n[request]\n(let [a  (Integer. (get-in request [:route-params :a]))\nb  (Integer. (get-in request [:route-params :b]))\nop (get-in request [:route-params :op])\nf  (get operands op)]\n(if f\n{:status 200\n:body (str \"&lt;h1&gt;Result = \" (f a b) \"&lt;/h1&gt;\")\n:headers {}}\n{:status 404\n:body \"Sorry, unknown operator.  I only recognise + - * : (: is for division)\"\n:headers {}})))\n(defn trying-hiccup\n[request]\n(html5 {:lang \"en\"}\n[:head (include-js \"myscript.js\") (include-css \"mystyle.css\")]\n[:body\n[:div [:h1 {:class \"info\"} \"This is Hiccup\"]]\n[:div [:p \"Take a look at the HTML generated in this page, compared to the about page\"]]\n[:div [:p \"Style-wise there is no difference between the pages as we haven't added anything in the stylesheet, however the hiccup page generates a more complete page in terms of HTML\"]]]))\n</code></pre>"},{"location":"projects/leiningen/todo-app/refactor-namespace/base-routes/#note-create-a-new-file-called-srctodo_listhandlersbase-routesclj-and-move-all-the-handler-code-into-this-file-from-srctodo_listcore-make-sure-you-also-move-the-hiccup-libraries-into-the-new-handlers-namespace","title":"Note:: Create a new file called <code>src/todo_list/handlers/base-routes.clj</code> and move all the handler code into this file from <code>src/todo_list/core</code>.  Make sure you also move the <code>hiccup</code> libraries into the new <code>handlers</code> namespace.","text":""},{"location":"projects/leiningen/todo-app/refactor-namespace/code-so-far/","title":"Code so far","text":""},{"location":"projects/leiningen/todo-app/refactor-namespace/core/","title":"Refactored Core","text":"<p>Refactor the core namespace to contain the code that starts up our server and join up all the route handlers.</p> <p>Edit the <code>src/todo_list/core.clj</code> file and update the namespace definition to include the new <code>handlers</code> namespace, including the whole namespace in <code>core</code>.</p> <pre><code>(ns todo-list.core\n(:require [compojure.core          :refer [routes]]\n[todo-list.handlers.play :refer [play-routes]]\n[todo-list.handlers.task :refer [task-routes]]\n[todo-list.handlers.base :refer [base-routes]]\n[ring.middleware.reload  :refer [wrap-reload]]\n[ring.adapter.jetty      :as    jetty]))\n</code></pre> <p>Change app from a defroutes to a <code>def</code> and use the <code>route</code> function to merge all the defroutes into one</p> <pre><code>(def app\n(routes #'play-routes #'base-routes #'task-routes))\n</code></pre> <p>The <code>routes</code> function takes the names of all the other defroutes and merges into one list of handlers.</p> <p><code>app</code> is now just a name we give to reference the handlers for all routes.  We can continue to add more defroutes to app as our application grows, along with any middleware we wish to apply to our handlers.</p> <p><code>core</code> should be much smaller, containing only the route definition and the main app (plus the middleware around the app)</p> <pre><code>(ns todo-list.core\n(:require [compojure.core          :refer [routes]]\n[todo-list.handlers.play :refer [play-routes]]\n[todo-list.handlers.task :refer [task-routes]]\n[todo-list.handlers.base :refer [base-routes]]\n[ring.middleware.reload  :refer [wrap-reload]]\n[ring.adapter.jetty      :as    jetty]))\n(def app\n(routes #'play-routes #'base-routes #'task-routes))\n(defn -main\n\"A very simple web server using Ring &amp; Jetty\"\n[port-number]\n(jetty/run-jetty app\n{:port (Integer. port-number)}))\n(defn -dev-main\n\"A very simple web server using Ring &amp; Jetty that reloads code changes via the development profile of Leiningen\"\n[port-number]\n(jetty/run-jetty (wrap-reload #'app)\n{:port (Integer. port-number)}))\n</code></pre>"},{"location":"projects/leiningen/todo-app/refactor-namespace/play-routes/","title":"Play routes","text":""},{"location":"projects/leiningen/todo-app/refactor-namespace/task-routes/","title":"Task routes","text":""},{"location":"projects/leiningen/todo-app/reloading-the-application/","title":"Automatic reloading with wrap-reload middleware","text":"<p><code>wrap-reload</code> is a ring middleware function that will push all our code changes to the application each time we save.</p> <p></p>"},{"location":"projects/leiningen/todo-app/reloading-the-application/#note-include-wrap-reload-in-the-namespace-of-our-project","title":"Note::  Include wrap-reload in the namespace of our project","text":"<p>Require the <code>wrap-reload</code> directly into the namespace</p> <pre><code>(ns todo-list.core\n(:require [ring.adapter.jetty :as jetty]\n[ring.middleware.reload :refer [wrap-reload]]))\n</code></pre>"},{"location":"projects/leiningen/todo-app/reloading-the-application/#define-a-function-to-use-wrap-reload","title":"Define a function to use wrap-reload","text":"<p>A function called <code>-dev-main</code> will run the reloading web server when we are developing, ensuring we only use the <code>wrap-reload</code> function during development.</p>"},{"location":"projects/leiningen/todo-app/reloading-the-application/#note-create-a-dev-main-function","title":"Note:: Create a <code>-dev-main</code> function","text":"<p>The <code>-dev-main</code> function is the same as <code>-main</code>, except we use the <code>wrap-reload</code> middleware around the <code>welcome</code> function.  Each time you change the <code>welcome</code> function definition it will be reloaded.</p> <p>Using the quote reader macro, #' in front of the <code>welcome</code> function name tells Clojure to skip evaluation of the function and reference the name of the function instead.  This allows the <code>wrap-reload</code> middleware to decide when to evaluate the <code>welcome</code> function.</p> <pre><code>(defn -dev-main\n\"A very simple web server using Ring &amp; Jetty,\n  called via the development profile of Leiningen\n  which reloads code changes using ring middleware wrap-reload\"\n[port-number]\n(webserver/run-jetty\n(wrap-reload #'welcome)\n{:port  (Integer. port-number)\n:join? false}))\n</code></pre>"},{"location":"projects/leiningen/todo-app/reloading-the-application/#notetweak-the-main-function-for-production","title":"Note::Tweak the <code>-main</code> function for production","text":"<p>The <code>-main</code> function is typically called on the command line when run in production, so we want to be connected to the output of the webserver.</p> <p>Remove the <code>:join? false</code> option for the embedded Jetty server, so the output of the server is displayed</p> <pre><code>(defn -main\n\"A very simple web server using Ring &amp; Jetty\n  Production mode operation, no reloading.\"\n[port-number]\n(webserver/run-jetty\nwelcome\n{:port (Integer. port-number)}))\n</code></pre>"},{"location":"projects/leiningen/todo-app/reloading-the-application/#configure-the-dev-profile-in-your-project","title":"Configure the dev profile in your project","text":"<p>When you start your Clojure webapp with <code>lein run</code> it looks for main class to run in the <code>:dev</code> profile first.  So we need to create a <code>:dev</code> profile.</p> <p><code>:dev</code> profile that sets <code>-dev-main</code> to be the starting point of our application.  This</p> <pre><code>:profiles {:dev\n{:main todo-list.core/-dev-main}}\n</code></pre> <p>The <code>project.clj</code> file should look like the following:</p> <pre><code>(defproject todo-list \"0.1.0-SNAPSHOT\"\n:description \"A Todo List server-side webapp using Ring &amp; Compojure\"\n:url \"https://github.com/practicalli/clojure-todo-list-example\"\n:license {:name \"Creative Commons Attribution Share-Alike 4.0 International\"\n:url  \"https://creativecommons.org\"}\n:dependencies [[org.clojure/clojure \"1.10.1\"]\n[ring \"1.8.0\"]]\n:repl-options {:init-ns todo-list.core}\n:main todo-list.core\n:profiles {:dev\n{:main todo-list.core/-dev-main}})\n</code></pre>"},{"location":"projects/leiningen/todo-app/reloading-the-application/#noteadd-profile-to-project-configuration","title":"Note::Add profile to project configuration","text":"<p>Edit the <code>project.clj</code> and create a <code>:dev</code> profile to define the initial function to call when starting our webapp.</p>"},{"location":"projects/leiningen/todo-app/reloading-the-application/code-so-far/","title":"The code so far","text":"<p>The code and configuration we have created so far are in the clojure-todo-list-example repository github repository.</p> <p>Code for this section is in the branch called <code>03-reloading-the-application</code></p> <p>If something is not working or you want to speed up, simply clone the project into a new directory using the command:</p> <p><pre><code>git clone https://github.com/practicalli/clojure-todo-list-example\n</code></pre> Once you have cloned the project, checkout the <code>03-reloading-the-application</code> branch</p> <pre><code>git checkout 03-reloading-the-application\n</code></pre>"},{"location":"projects/leiningen/todo-app/reloading-the-application/middleware/","title":"Middleware in Ring","text":"<p>Middleware in ring is a way to modify the incoming requests or outgoing responses.</p> <p>Middleware can also wrap handlers or other middleware, affecting their behaviour.  For example the <code>wrap-reload</code> middleware enables live reloading by detecting file changes and reloading affected functions into their namespace, before the request is passed to the relevant handler function</p> <p>Middleware in <code>ring/ring-core</code></p> <ul> <li>wrap-cookies (ring.middleware.cookies)</li> <li>wrap-file (ring.middleware.file)</li> <li>wrap-file-info (ring.middleware.file-info)</li> <li>wrap-flash (ring.middleware.flash)</li> <li>wrap-keyword-params (ring.middleware.keyword-params)</li> <li>wrap-multipart-params (ring.middleware.multipart-params</li> <li>wrap-nested-params (ring.middleware.nested-params</li> <li>wrap-params (ring.middleware.params)</li> <li>wrap-session (ring.middleware.session)</li> </ul> <p>Middleware in <code>ring/ring-devel</code></p> <ul> <li>wrap-lint (ring.middleware.lint)</li> <li>wrap-reload (ring.middleware.reload)</li> <li>wrap-stacktrace (ring.middleware.stacktrace)</li> </ul>"},{"location":"projects/leiningen/todo-app/reloading-the-application/test-your-code-reloads/","title":"Test the wrap-reload middleware","text":"<p>Make a change to the <code>welcome</code> function code and check that it automatically reloads.</p> <p>Change the default response text in the <code>welcome</code> function</p> <p>Open the webapp in the browser http://localhost:8000.</p> <p>Make a change to the code in the <code>welcome</code> function, altering the text of the <code>:body</code> in the default request.</p> <pre><code>(defn welcome\n\"A ring handler to process all requests for the web server.\n  If a request is for something other than `/` then an error message is returned\"\n[request]\n(if (= \"/\" (:uri request))\n{:status  200\n:headers {}\n:body    \"&lt;h1&gt;Hello, Clojure World&lt;/h1&gt;\n               &lt;p&gt;Welcome to your first Clojure app.&lt;/p&gt;\n               &lt;p&gt;I now reload changes automatically&lt;/p&gt; \"}\n{:status  404\n:headers {}\n:body    \"&lt;h1&gt;This is not the page you are looking for&lt;/h1&gt;\n               &lt;p&gt;Sorry, the page you requested was not found!&lt;/p&gt;\"}))\n</code></pre> <p>Save the code change and refresh your browser page, you should now see the updated message.</p>"},{"location":"projects/leiningen/todo-app/task-handlers/","title":"Task handlers","text":"<p>Now we have functions that create the database and add / remove tasks, we can provide handlers to call these functions and therefore enable the user to add and remove tasks.</p> <p>In the following pages we will create handlers and use hiccup for the html markup.</p>"},{"location":"projects/leiningen/todo-app/task-handlers/#todowork-in-progress-sorry","title":"TODO::work in progress, sorry","text":""},{"location":"projects/leiningen/todo-app/task-handlers/add-a-task/","title":"Add a task","text":"<p>which namespace are these going in</p> <p>(ns todo-list.handlers.tasks   :requires models....)</p>"},{"location":"projects/leiningen/todo-app/task-handlers/add-a-task/#todowork-in-progress-sorry","title":"TODO::work in progress, sorry","text":""},{"location":"projects/leiningen/todo-app/task-handlers/delete-a-task/","title":"Delete a task","text":""},{"location":"projects/leiningen/todo-app/task-handlers/delete-a-task/#todowork-in-progress-sorry","title":"TODO::work in progress, sorry","text":""},{"location":"projects/leiningen/todo-app/task-handlers/show-task/","title":"Show tasks","text":""},{"location":"projects/leiningen/todo-app/task-handlers/show-task/#todowork-in-progress-sorry","title":"TODO::work in progress, sorry","text":""},{"location":"projects/leiningen/todo-app/unit-test-handler-function/","title":"Unit Test handler functions","text":"<p>Handler functions can be tested with unit tests as they are just pure functions.  All handlers take a request hash-map and return a response hash-map.  So its easy to give each handler a hash-map as an argument and test that we get the expected response hash-map in return.</p> <p>There is no need to mock the framework until we do integration level testing, where we are testing the full lifecycle of request-response.</p> <p>It is useful to have separate unit and integration tests to quickly narrow down the root cause of issues.</p>"},{"location":"projects/leiningen/todo-app/unit-test-handler-function/#unit-test-branch","title":"Unit test branch","text":"<p>The unit tests are placed under <code>test/full_namespace_path/</code> and reside in files with the same names as the source code filenames, with <code>-test</code> postfixed to the end.</p> <pre><code>src/practicalli/simple_webapp/handlers.clj\ntest/practicalli/simple_webapp/handlers-test.clj\n</code></pre>"},{"location":"projects/leiningen/todo-app/unit-test-handler-function/#writing-unit-tests","title":"Writing unit tests","text":"<p><code>clojure.test</code> is used to write unit tests for handlers, as we are just treating them as functions.</p>"},{"location":"projects/leiningen/working-example/","title":"A working example","text":"<p>As we don't have time to build a full web app in this workshop, here is one that was built early.</p> <p></p>"},{"location":"projects/leiningen/working-example/#note-checkout-the-shouter-code-from-gitub","title":"Note:: Checkout the Shouter code from Gitub","text":""},{"location":"projects/status-monitor-deps/","title":"Status Monitor project with Clojure tools","text":"<p>A status monitor dashboard to show operational status of a range of services.</p> <p>A server-side web application using - ring and compojure for webapp request management - bulma CSS library for styling - hiccup for writing html in Clojure syntax - SVG graphics for status graphics - clojure.spec for validating functions and svg definitions in Clojure</p>"},{"location":"projects/status-monitor-deps/#creating-a-project","title":"Creating a project","text":"deps-newManual <p>Create a project using the app template and called practicalli/status-monitor.  The <code>:project/create</code> alias from Practicalli Clojure CLI Config uses the deps-new project to create Clojure projects <pre><code>clojure -T:project/create :template app :name practicalli/status-monitor\n</code></pre> Some minor tweaks are made to the project before starting the application development</p> <ul> <li>describe the project and how it can be used in the README</li> <li>delete the LICENSE file and use a Creative Commons in the README</li> <li>format the deps.edn file for readability</li> </ul> <p>Create a project in a directory called status-monitor, with a <code>deps.end</code> file in the root of that directory deps.edn<pre><code>{:paths [\"src\"]\n:deps {org.clojure/clojure {:mvn/version \"1.11.3\"}}}\n</code></pre> Create a <code>src/practicalli/status_monitor.clj</code> file src/practicalli/status_monitor.clj<pre><code>(ns practicalli.status-monitor)\n</code></pre> Create a <code>test/practicalli/status_monitor_test.clj</code> file src/practicalli/status_monitor.clj<pre><code>(ns practicalli.status-monitor-test\n(:require [clojure.test :refer [deftest is testing]]))\n</code></pre></p> <p>practicalli/status-monitor</p> <p>The code for this project can be found at practicalli/status-monitor</p>"},{"location":"projects/status-monitor-deps/application-server/","title":"Application Server","text":""},{"location":"projects/status-monitor-deps/application-server/#add-an-embedded-web-application-server","title":"Add an embedded web application server","text":"<p>The status monitor service runs on top of an application server which handles the infrastructure of messaging over https and other Internet protocols.</p> <p>There are several libraries to provide this, ring and http-kit being the most common.</p>"},{"location":"projects/status-monitor-deps/application-server/#add-dependencies-for-application-server-and-routing","title":"Add dependencies for application server and routing","text":"<p>Edit the <code>deps.edn</code> file for the project.</p> <p>Add the http-kit library library for the application server</p> <p>Add the compojure library for routing of requests</p> <pre><code> :deps\n{org.clojure/clojure {:mvn/version \"1.10.1\"}\nhttp-kit            {:mvn/version \"2.3.0\"}\ncompojure           {:mvn/version \"1.6.1\"}}\n</code></pre>"},{"location":"projects/status-monitor-deps/application-server/#add-code-to-start-the-application-server","title":"Add code to start the application server","text":"<p>Edit the <code>src/practicalli/status_monitor_service.clj</code> file</p> <p>Include the http-kit server namespace and the compojure core namespace as requires in the <code>ns</code> definition.</p> <pre><code>(ns practicalli.status-monitor-service\n(:gen-class)\n(:require [org.httpkit.server :as app-server]\n[compojure.core :refer [defroutes GET]]))\n</code></pre> <p>Add an atom to hold a reference to the running application server.  When the server is not running, the atom contains <code>nil</code>.</p> <pre><code>(defonce app-server-instance (atom nil))\n</code></pre> <p>Update the <code>-main</code> function to start the application server using http-kit <code>run-server</code>, optionally setting the port number the server should run on.</p> <pre><code>(defn -main\n\"Start the application server and run the application\"\n[port]\n(println \"INFO: Starting server on port: \" port)\n(reset! app-server-instance\n(app-server/run-server #'status-monitor {:port (Integer/parseInt port)})))\n</code></pre>"},{"location":"projects/status-monitor-deps/application-server/#define-a-default-route-and-handler","title":"Define a default route and handler","text":"<p>Using the compojure <code>defroutes</code> function, define the default route and response when the status-monitor app received a request on the main URL, (eg. http://localhost:8888/)</p> <pre><code>(defroutes status-monitor\n(GET \"/\" [] {:status 200 :body \"Status Monitor Dashboard\"}))\n</code></pre> <p>The route returns a hash-map that is the form of a response map. http-kit server transforms all response maps into https responses that are sent back to the requesting web browser.</p>"},{"location":"projects/status-monitor-deps/application-server/#stop-and-restart-server-from-repl","title":"Stop and restart server from REPL","text":"<p>Add functions to stop and restart the server, so change to the application code can be loaded in without having to stop the Clojure REPL.</p> <p>Use the value in the app-server-instance atom to determine if the app-server is already running.  If so, then send the instance the <code>:timeout</code> key with a value of time to shut itself down.</p> <pre><code>(defn stop-app-server\n\"Gracefully shutdown the server, waiting 100ms\"\n[]\n(when-not (nil? @app-server-instance)\n(@app-server-instance :timeout 100)\n(reset! app-server-instance nil)\n(println \"INFO: Application server stopped\")))\n</code></pre> <p>With a REPL running the project, the server is started calling <code>(-main)</code> and stopped by calling <code>(stop-app-server)</code>.  A restart function is simply calling the stop and start functions.</p> <pre><code>(defn restart-app-server\n\"Convenience function to stop and start the application server\"\n[]\n(stop-app-server)\n(-main))\n</code></pre> <p>Component lifecycle service</p> <p>This approach is the essence of component lifecycle services such as mount, component and integrant.</p> <p>Use the mount library if you are starting with component lifecycle services or require a clean and simple approach.  Try integrant to take a data centric approach to such a service.</p>"},{"location":"projects/status-monitor-deps/application-server/#repl-experiment-section","title":"REPL experiment section","text":"<p>To help use the code during development a comment body has been included with calls to start, stop and restart the application.</p> <pre><code>(comment\n;; start application\n(-main)\n;; stop application\n(stop-app-server)\n;; restart application\n(restart-app-server)\n)\n</code></pre>"},{"location":"projects/status-monitor-deps/continuous-integration/","title":"Continuous Integration","text":"<p>To assist in the development of the application, CircleCI, a continuous integration service will be used.</p> <p>Initially this will run all the unit tests for the application and report on the results.  In another chapter, CircleCI will be used to package the application and deploy the application.</p>"},{"location":"projects/status-monitor-deps/continuous-integration/#alias-for-test-runner","title":"Alias for test runner","text":"<p>Edit <code>deps.edn</code> file and add an alias called <code>:test/run</code> that calls kaocha test runner on the code</p> <pre><code>  :test/run\n{:extra-paths [\"test\"]\n:extra-deps {lambdaisland/kaocha {:mvn/version \"1.71.1119\"}}\n:main-opts   [\"-m\" \"kaocha.runner\"]\n:exec-fn kaocha.runner/exec-fn\n:exec-args {:randomize? false\n:fail-fast? true}}\n</code></pre> <p>Check the test runner is working by running the <code>clojure</code> command with the <code>:test/run</code> alias in a terminal at the root of the Clojure project</p> <pre><code>clojure -X:test/run\n</code></pre>"},{"location":"projects/status-monitor-deps/continuous-integration/#add-circleci-configuration","title":"Add CircleCI configuration","text":"<p>Edit <code>.circleci/config.yml</code> and add a configuration to build and test the Clojure application.  The <code>cimg/clojure:1.10.0</code> image contains OpenJDK 17 and the latest version of Clojure CLI, Leiningen and Babashka.</p> <p>Run the <code>clojure</code> commands in the root of the project before adding the configuration, to ensure the commands work locally first.</p> <pre><code>version: 2.0\njobs:\nbuild:\nworking_directory: ~/build\ndocker:\n- image: cimg/clojure:1.10\nenvironment:\nJVM_OPTS: -Xmx3200m\nsteps:\n- checkout\n- restore_cache:\nkey: status-monitor-service-{{ checksum \"deps.edn\" }}\n- cache-dependencies\n- run: clojure -P\n- save_cache:\npaths:\n- ~/.m2\n- ~/.gitlibs\nkey: status-monitor-service-{{ checksum \"deps.edn\" }}\n- Unit-testing\n- run: clojure -X:test/run\n</code></pre>"},{"location":"projects/status-monitor-deps/continuous-integration/#add-project-on-circleci","title":"Add project on CircleCI","text":"<p>Visit the CircleCI dashboard and select Add Projects.  Find the <code>status-monitor-service</code> repository and select Set Up Project button.</p> <p>Choose the Add Manual install and Start Building</p> <p></p>"},{"location":"projects/status-monitor-deps/debugging-requests/","title":"Debug ring requests","text":"<p>Requests are Clojure hash-maps so are easy to extract data from in a meaningful way.</p> <p>If getting unexpected results, checking the details received in the request is a fast way to diagnose issues by seeing the data. The ring/ring-devel library contains a <code>handle-dump</code> function which displays the request parameters in a web page.</p>"},{"location":"projects/status-monitor-deps/debugging-requests/#add-ring-development-library","title":"Add ring development library","text":"<p>Add the <code>:env/dev</code> alias to include the <code>ring/ring-devel</code> library as a dependency.  The ring-devel library includes functions for developing and debugging ring applications.</p> <pre><code> :deps\n{org.clojure/clojure {:mvn/version \"1.10.3\"}\nhttp-kit/http-kit   {:mvn/version \"2.5.3\"}\nring/ring-core      {:mvn/version \"1.9.5\"}\ncompojure/compojure {:mvn/version \"1.6.2\"}}\n:aliases\n{:env/dev\n{:extra-deps {ring/ring-devel {:mvn/version \"1.8.1\"}}}}\n</code></pre>"},{"location":"projects/status-monitor-deps/debugging-requests/#restart-repl","title":"Restart REPL","text":"<p>Dependencies are only added to the classpath when the REPL process starts, unless using the unofficial dependency hotload approach</p> <p>Quit the REPL if it is already running</p> <p>Start the REPL including the alias <code>:env/dev</code>.  For example, run a rich terminal UI using rebel readline which also starts an nREPL sever:</p> <pre><code>clojure -M:env/dev:repl/rebel\n</code></pre> <p><code>:repl/rebel</code> is defined in the user level configuration practicalli/clojure-deps-edn</p> <p>Hotload libraries into a running REPL</p> <p>Clojure CLI Hotload Libraries can add libraries to the class path without having to restart the REPL</p>"},{"location":"projects/status-monitor-deps/debugging-requests/#require-the-ringhandlerdump-namespace","title":"Require the <code>ring.handler.dump</code> namespace","text":"<p>Require the <code>ring.handler.dump</code> namespace in the <code>ns</code> form of <code>practicalli.status-monitor-server</code> namespace and refer the specific <code>handle-dump</code> function.</p> <pre><code>(ns practicalli.status-monitor-service\n(:gen-class)\n(:require\n[org.httpkit.server       :as    app-server]\n[compojure.core           :refer [defroutes GET]]\n[compojure.route          :refer [not-found]]\n[ring.handler.dump        :refer [handle-dump]]\n[ring.util.response       :refer [response]]\n[practicalli.helpers-http :refer [http-status-code]]))\n</code></pre>"},{"location":"projects/status-monitor-deps/debugging-requests/#add-a-route-to-show-the-request-map","title":"Add a route to show the request map","text":"<p>Add a route that shows the request information using the <code>handle-dump</code> function.</p> <pre><code>(defroutes status-monitor\n(GET \"/\" [] {:status (:OK http-status-code) :body \"Status Monitor Dashboard\"})\n(GET \"/request-dump\" [] handle-dump))\n</code></pre> <p>(re)start the application server and visit the URL http://localhost:8080/request-dump</p> <p></p> <p>The request map details are also printed to the REPL buffer</p> <pre><code>{:remote-addr \"127.0.0.1\",\n :params {},\n :route-params {},\n :headers\n{\"accept\"\n\"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\",\n  \"accept-encoding\" \"gzip, deflate\",\n  \"accept-language\" \"en-US,en;q=0.5\",\n  \"connection\" \"keep-alive\",\n  \"cookie\"\n\"_ga=GA1.1.1141619352.1582159249; ring-session=0b3dc210-278e-4011-bc03-d8c2292b2c17; JSESSIONID=5RNxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxB; _gid=GA1.1.111111111.3333333333\",\n  \"host\" \"localhost:8080\",\n  \"upgrade-insecure-requests\" \"1\",\n  \"user-agent\"\n\"Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:78.0) Gecko/20100101 Firefox/78.0\"},\n :async-channel\n#object[org.httpkit.server.AsyncChannel 0x359a37c8 \"/127.0.0.1:8080&lt;-&gt;/127.0.0.1:38190\"],\n :server-port 8080,\n :content-length 0,\n :compojure/route [:get \"/request-dump\"],\n :websocket? false,\n :content-type nil,\n :character-encoding \"utf8\",\n :uri \"/request-dump\",\n :server-name \"localhost\",\n :query-string nil,\n :body nil,\n :scheme :http,\n :request-method :get}\n</code></pre>"},{"location":"projects/status-monitor-deps/deployment-via-ci/","title":"Deployment Via Continuous Integration","text":"<p>Building on the CircleCI build pipeline created so far, the application will be deployed on Heroku if all the tests pass.</p> <p>A workflow is added to the CircleCI configuration that deploys the application on Heroku from the source code.  Heroku packages the application into an uberjar and then runs the application from that uberjar.</p> <p>When commits in the Clojure project code are pushed to GitHub they are detected by CircleCI and the tests run.  If the tests pass then the Heroku deployment stage starts.</p> <p>TODO: Convert to tools.build approach</p> <p>The depstar project has been retired (although still works) in favour of the official tools.build approach</p>"},{"location":"projects/status-monitor-deps/deployment-via-ci/#add-depstar-to-build-an-uberjar","title":"Add depstar to build an uberjar","text":"<p>Use the depstar tool to create a Java archive (jar) package of the application.  The <code>deps.edn</code> configuration in the root of the project already contains an <code>uberjar</code> alias for this tool.</p> <pre><code>:project/uberjar\n{:replace-deps {com.github.seancorfield/depstar {:mvn/version \"2.1.303\"}}\n:exec-fn      hf.depstar/uberjar\n:exec-args    {:jar \"status-monitor-service.jar\"\n:aot true}}\n</code></pre> <p>To try this on the command line:</p> <pre><code>clojure -X:project/uberjar\n</code></pre> <p>This will be the same command used in the build script</p>"},{"location":"projects/status-monitor-deps/deployment-via-ci/#create-a-custom-build-behaviour","title":"Create a custom build behaviour","text":"<p>Heroku build scripts use Leiningen by default.  Configure Heroku to build with Clojure Tools, create a custom build file which will run instead of Leiningen.</p> <p>Create a file called <code>bin/build</code> script in the root of the project</p> <pre><code>#!/usr/bin/env bash\nclojure -X:project/uberjar\n</code></pre> <p>Create an empty <code>project.clj</code> file so that Heroku recognized the project as Clojure.</p>"},{"location":"projects/status-monitor-deps/deployment-via-ci/#define-how-to-run-the-application","title":"Define how to run the application","text":"<p>Create a <code>Procfile</code> file in the root of the project directory containing the command to run the application.</p> <p>Use the <code>$PORT</code> as an argument to the command.  Heroku automatically assigns a port number for an application to listen upon when creating a contain in which the application will run.  This port number is set using the <code>PORT</code> environment variable and is available to the application on startup.  Using the PORT environment variable ensures the Clojure application will receive requests.</p> <pre><code>web: java -jar status-monitor-service.jar $PORT\n</code></pre>"},{"location":"projects/status-monitor-deps/deployment-via-ci/#specifying-a-java-version","title":"Specifying a Java version","text":"<p>Create a <code>system.properties</code> and specify the Java version to use for the application. Java 1.8 is the default version use on Heroku, however, our development environment is Java 17, so add a property to set the Java runtime to version 17.</p> <pre><code>java.runtime.version=17\n</code></pre>"},{"location":"projects/status-monitor-deps/deployment-via-ci/#heroku-configuration","title":"Heroku configuration","text":"<p>Login to the Heroku dashboard and create a new application.</p> <p>In the Heroku dashboard, open the application Settings and add a Config Vars using the name <code>CLOJURE_CLI_VERSION</code> with a value of <code>1.10.1.727</code></p> <p></p>"},{"location":"projects/status-monitor-deps/deployment-via-ci/#circleci-configuration-with-heroku-orb","title":"CircleCI configuration with Heroku Orb","text":"<p>Edit the <code>.circleci/config.yml</code> file and add the heroku orb and a workflow to call the orb task.  The workflow has a dependency on the build job, so that will take place first.</p> <p>The Heroku workflow will build the application from source code using the <code>heroku/deploy-via-git</code>.  Only changes pushed to the <code>live</code> branch of the GitHub repository will be used in the Heroku deploy workflow.</p> <p>Feature branches can be deployed on Heroku by creating an additional Heroku application and push the branch to it.  Or use Heroku pipelines</p> <pre><code>version: 2.1\norbs:\nheroku: circleci/heroku@1.2.6 # Invoke the Heroku orb\nworkflows:\nheroku_deploy:\njobs:\n- build\n- heroku/deploy-via-git: # Use the pre-configured job, deploy-via-git\nrequires:\n- build\nfilters:\nbranches:\nonly: live\njobs:\nbuild:\nworking_directory: ~/build\ndocker:\n- image: cimg/clojure:1.10\nenvironment:\nJVM_OPTS: -Xmx3200m\nsteps:\n- checkout\n- restore_cache:\nkey: status-monitor-service-{{ checksum \"deps.edn\" }}\n- run: clojure -P\n- save_cache:\npaths:\n- ~/.m2\n- ~/.gitlibs\nkey: status-monitor-service-{{ checksum \"deps.edn\" }}\n- run: clojure -X:test/run\n</code></pre>"},{"location":"projects/status-monitor-deps/deployment-via-ci/#circleci-environment-variables","title":"CircleCI Environment Variables","text":"<p>Open the CircleCI and select project settings &gt; Environment Variables</p> <p>Add environment variables to define where the Heroku application can be found and a token to provide access.</p> Environment Variable Value <code>HEROKU_API_KEY</code> name of the application created on Heroku <code>HEROKU_APP_NAME</code> API key found in Account Settings &gt; API Key"},{"location":"projects/status-monitor-deps/deployment-via-ci/#push-changes-to-trigger-build","title":"Push changes to trigger build","text":"<p>Commit the changed and push them to the GitHub repository.  This triggers a build by CircleCI.  The build downloads the dependencies and runs the unit tests.  If the tests pass, then the Heroku deploy workflow starts.</p> <p>The two stages can be seen in the dashboard as the pipeline runs.</p> <p></p> <p>Now visit the deployed Heroku application to see it in action.</p>"},{"location":"projects/status-monitor-deps/deployment-via-ci/#troubleshooting","title":"Troubleshooting","text":"<p>If there are issues, then use the Heroku toolbelt to look at the logs.  In a command line terminal, issue the login command which opens a web browser to login to Heroku.  Once logged in, run the heroku logs command to view the latest logs</p> <pre><code>heroku login\n\nheroku logs --app status-monitor-service\n</code></pre> <p>The logs can also be viewed live, as the application is being deployed by including the <code>--tail</code> option when running the heroku logs command in a terminal</p> <pre><code>heroku logs --app status-monitor-service --tail\n</code></pre> <p>The example Heroku logs show that the status-monitor-service is using the default port number if non is supplied as an argument, rather than Heroku assigned port.  Heroku therefore considers the application as unresponsive and sets it status to crashed, tearing down the container the application is running in.</p> <p>These logs were generated before adding the <code>$PORT</code> to the command in the Procfile.</p> <p></p>"},{"location":"projects/status-monitor-deps/deployment-via-ci/#no-forced-pushes","title":"No forced pushes","text":"<p>Heroku doesn't like force Git pushes coming via CircleCI.</p> <p>To get around this, either don't do force pushes to GitHub, or add the Heroku repository for the project as a remote to local git repository.</p> <p>Heroku repository details in heroku dashboard Settings under App Information</p> <p>Changes can now be pushed, ideally using <code>force-with-lease</code> to Heroku repository.</p> <pre><code>git push heroku live:master\n</code></pre> <p>Heroku only builds from a branch called master or main, so the above command pushes the local <code>live</code> branch to the remote <code>master</code> branch on Heroku.</p>"},{"location":"projects/status-monitor-deps/deployment-via-ci/#stopping-the-application","title":"Stopping the application","text":"<p>An application can be run for free on Heroku with the monthly free credits provided.  However, to make the most out of these free credits then applications not in use should be shut down</p> <p>Run the following command in the root of the Clojure project.</p> <pre><code>heroku ps:stop status-monitor-service\n</code></pre>"},{"location":"projects/status-monitor-deps/refactor-handlers-and-tests/","title":"Refactor handlers and unit tests","text":"<p>Refactor the unit tests to use the ring-mock library to test handler functions.  Create separate handler functions for the routes in <code>defroute</code> (there is only one custom handler at present).</p> <pre><code>(deftest dashboard-test\n(testing \"Testing elements on the dashboard\"\n(is (= (SUT/dashboard (mock/request :get \"/\"))\n{:status  200\n:body    \"Status Monitor Dashboard\"\n:headers {}}))))\n</code></pre> <p>Create a handler for the <code>GET \"/\"</code> route</p> <pre><code>(defn dashboard\n[request]\n{:status (:OK http-status-code) :body \"Status Monitor Dashboard\" :headers {}})\n</code></pre> <p>Use the <code>ring.util.response/response</code> function to create a well formed response map which has a status code of 200.  This removes the need to type in the response map structure explicitly which potentially can introduce bugs.</p> <p>In the current namespace <code>ns</code> form, this function is required as an explicit refer, <code>[ring.util.response :refer [response]]</code>, so its available to use by its unqualified name, <code>response</code>.</p> <pre><code>(defn dashboard\n[request]\n(response \"Status Monitor Dashboard\"))\n</code></pre> <p>Update the <code>defroutes</code> definition to call this handler rather than hard coding the response map.</p> <pre><code>(defroutes status-monitor\n(GET \"/\" [] dashboard)\n(GET \"/request-dump\" [] handle-dump)\n)\n</code></pre> <p>Run the Cognitect test runner to check the unit tests are still passing after the code refactor.</p> <pre><code>clojure -M:env/dev:test:runner\n</code></pre>"},{"location":"projects/status-monitor-deps/refactor-handlers-and-tests/#helper-functions","title":"Helper functions","text":"<p>The ring util library contains several other helper functions, <code>bad-request</code>, <code>not-found</code> and <code>redirect</code>:</p> <pre><code>(ring.util.response/bad-request \"Hello\")\n;;=&gt; {:status 400, :headers {}, :body \"Hello\"}\n(ring.util.response/created \"/post/clojure-is-awesome\")\n;;=&gt; {:status 201, :headers {\"Location\" \"/post/clojure-is-awesome\"}, :body nil}\n(ring.util.response/redirect \"https://clojure.org/getting-started/\")\n;;=&gt; {:status 302, :headers {\"Location\" \"https://clojure.org/getting-started/\"}, :body \"\"}\n</code></pre> <p>The <code>status</code> function converts an existing response to use a given status code (which can be anything).  Use this with care and document what the status code means otherwise confusion will abound.</p> <pre><code>(ring.util.response/status (ring.util.response/response \"Time for Cake!\") 555)\n;;=&gt; {:status 555, :headers {}, :body \"Time for Cake!\"}\n</code></pre> <p>Ring utilities has functions for setting the header data for responses, <code>content-type</code>, <code>header</code> or <code>set-cookie</code>.</p> <pre><code>(ring.util.response/content-type (ring.util.response/response \"Hello\") \"text/plain\")\n;;=&gt;  {:status 200, :headers {\"Content-Type\" \"text/plain\"}, :body \"Hello\"}\n(ring.util.response/header (ring.util.response/response \"Hello\") \"X-Tutorial-For\" \"Practicalli\")\n;;=&gt;  {:status 200, :headers {\"X-Tutorial-For\" \"Practicalli\"}, :body \"Hello\"}\n(ring.util.response/set-cookie (ring.util.response/response \"Hello\") \"User\" \"123\")\n;;=&gt;  {:status 200, :headers {}, :body \"Hello\", :cookies {\"User\" {:value \"123\"}}}\n</code></pre> <p><code>wrap-cookies</code> middleware required</p> <p>The <code>set-cookie</code> function adds a new entry to the response map and requires the <code>wrap-cookies</code> middleware to process correctly.</p>"},{"location":"projects/status-monitor-deps/refactor-handlers-and-tests/#handler-functions","title":"Handler functions","text":"<p>A handler to return the incoming IP Address</p> <pre><code>(defn check-ip-handler [request]\n(ring.util.response/content-type\n(ring.util.response/response (:remote-addr request))\n\"text/plain\"))\n</code></pre>"},{"location":"projects/status-monitor-deps/unit-test-mocking-handlers/","title":"Mocking in Unit Tests","text":"<p>The main focus of unit tests in a web application are the handler functions, passing requests to those functions and checking the responses.</p> <p>All handler functions are passed a request object by default when using compojure <code>defroutes</code> function for routing.</p> <p>If handler functions do not use arguments then you can test those handlers by simply passing an empty hash-map, <code>{}</code>.</p> <p>For all other handler functions you can pass a request object or just specific parts of a request in a hash-map.</p>"},{"location":"projects/status-monitor-deps/unit-test-mocking-handlers/#ring-mock-library","title":"Ring mock library","text":"<p>ring-mock is a small library creating Ring request maps (Clojure hash-maps) to support unit testing. Generated hash-maps are examples of a ring request and used as arguments when calling the handler functions in tests.</p>"},{"location":"projects/status-monitor-deps/unit-test-mocking-handlers/#add-dev-dependency","title":"Add dev dependency","text":"<p>As ring-mock is a development only library, it should be added to an alias not included in the packaging of the project for production.</p> <p>Edit the project <code>deps.edn</code> file in the project and add ring-mock to an alias called <code>:env/dev</code>, creating the alias if required.</p> <pre><code>  :env/dev\n{:extra-deps {ring/ring-mock {:mvn/version \"0.4.0\"}}}\n</code></pre>"},{"location":"projects/status-monitor-deps/unit-test-mocking-handlers/#add-namespace","title":"Add namespace","text":"<p>Add the ring-mock.request namespace to any of the test namespaces mocking of requests will be useful.</p> <p>Edit the <code>test/practicalli/status-monitor-service.clj</code> and add ring-mock as a required namespace in files <code>ns</code> form.</p> <pre><code>(ns practicalli.status-monitor-service-test\n(:require [clojure.test :refer [deftest is testing]]\n[ring.mock.request :as  mock]\n[practicalli.status-monitor-service :as status-monitor]))\n</code></pre> <p>Add unit tests to check the handlers (which are going to be added next - TDD style)</p> <pre><code>(deftest test-app\n(testing \"main route\"\n(let [response ((status-monitor/app) (request :get \"/\"))]\n(is (= 200 (:status response)))))\n(testing \"not-found route\"\n(let [response ((status-monitor/app) (request :get \"/invalid\"))]\n(is (= 404 (:status response))))))\n</code></pre>"},{"location":"projects/status-monitor-deps/unit-test-mocking-handlers/#examples","title":"Examples","text":"<ul> <li>API: ring-mock</li> </ul> <pre><code>(deftest your-handler-test\n(is (= (your-handler (mock/request :get \"/doc/10\"))\n{:status  200\n:headers {\"content-type\" \"text/plain\"}\n:body    \"Your expected result\"})))\n(deftest your-json-handler-test\n(is (= (your-handler (-&gt; (mock/request :post \"/api/endpoint\")\n(mock/json-body {:foo \"bar\"})))\n{:status  201\n:headers {\"content-type\" \"application/json\"}\n:body    {:key \"your expected result\"}})))\n</code></pre>"},{"location":"reference/","title":"reference","text":""},{"location":"reference/ring/","title":"Ring specification","text":"<p>Information to complement the ring projects</p> <p>Ring provides a defacto web standard that the majority of server-side web appliications use </p> <ul> <li>request (Clojure hash-map)</li> <li>response (Clojure hash-map)</li> <li>handler  (Clojure function)</li> <li>middleware (Clojure function)</li> <li>adaptor (Clojure function / wrapper)</li> </ul> <p>Routing requests to handlers is typially managed by functions or libraries used in conjunction with ring, e.g reitit or compojure</p>"},{"location":"reference/ring/#ring-request-map","title":"Ring request map","text":"<p>Ring represents HTTP requests as simple Clojure maps, whose keys are drawn from the Java Servlet API and the official documentation RFC2616 \u2013 Hypertext Transfer Protocol - HTTP/ 1.1 ( http:// www.w3. org/ Protocols/ rfc2616/ rfc2616. html ). </p> <p>A request map contains the following keys:</p> <ul> <li><code>:server-port</code> the port the HTTP server was listening for the request </li> <li><code>:server-name</code> the resolved name or IP address of the server handling the request </li> <li><code>:remote-addr</code>  IP address of the client that made the request </li> <li><code>:uri</code> the path to the requested resource (the part of the URL address after the domain name)</li> <li><code>:query-string</code> the HTTP query string if included in the request. e.g. http://practical.li/blog?topic=clojure has a request map that includes <code>:query-string \"topic=clojure\"</code>. </li> <li><code>:scheme</code> protocol used to make the request as a keyword, i.e. <code>:http</code> for HTTP request and <code>:https</code> for Secure HTTP </li> <li><code>:request-method</code> HTTP method used to make the request as keyword, one of <code>:get</code>, <code>:post</code>, <code>:put</code>, <code>:delete</code>, <code>:head</code> or <code>:options</code></li> <li><code>:headers</code> hash-map of header names and values,  e.g: <code>{:headers {\"content-type\" \"text/html\" \"content-length\" \"500\" \"pragma\" \"no-cache\"}}</code> </li> <li><code>:body</code> a string of the request body (e.g. contents of an HTTP POST request) </li> </ul> <p>Request maps are not restricted to these top level keys.  Middleware is commonly used to mutate the request map by adding keys. </p> <p>See the reference page for a Clojure request map</p>"},{"location":"reference/ring/#response-maps","title":"Response maps","text":"<p>Ring represents an HTTP response as a simple Clojure map. </p> <p>The response map contains only three keys: </p> <ul> <li><code>:status</code> HTTP status code of the response as an integer, such as 200 or 403. A full list of HTTP status codes is made available as part of the RFC2616, and can be viewed at http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html.  </li> <li><code>:headers</code> contains a map of header names (string) to header values, similar to the request map. </li> <li><code>:body</code> the body of the response as one of the following four types, and the behavior will change for each: </li> <li>String - the body is sent directly to client </li> <li>ISeq - each element of the sequence is sent to client as a String </li> <li>File - contents of the file sent to client </li> <li>InputStream - contents of the stream sent to the client, after which the stream is closed </li> </ul> <p>An example of a simple Hello World! response map can look like this: </p> <pre><code>{:status 200 :headers {\" Content-Type\" \"text/ html\"} :body \"&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello World!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;\"}\n</code></pre>"},{"location":"reference/ring/#handlers","title":"Handlers","text":"<p>A handler is a Clojure function that accepts a request map and returns a response map.</p> <p>an example handler function: </p> <pre><code>(defn hello-world \"Returns an Hello World Response Map\" [request] {:status 200 :headers {\"Content-Type\" \"text/html\"} :body \"&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello World&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;\"}) </code></pre> <p>Handlers are the core of the application. </p> <p>Typically our URLs will map one-to-one with a handler. </p> <p>create a handler and configure a route to use that handler too generate a response.</p> <p>Open the <code>src/practicalli/routes/home.clj</code> file. </p> <p>Above the call to defroutes, add the following handler: </p> <pre><code>(defn hello-world [] {:status 200 :headers {\"Content-Type\" \"text/html\"} :body \"&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello World&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;\"})\n</code></pre> <p>Define a get request for an <code>/about</code> URI route that calls the hello-world handler:</p> <pre><code>(GET \"/about\" [] (foo-response)) </code></pre> <p>Navigate to http://localhost:3000/about in a browser and see a simple Hello World! page.</p>"},{"location":"reference/ring/#middleware","title":"Middleware","text":"<p>Middleware are functions that sit between the adapter and the handler and can be assigned to one or more routes. </p> <p>A middleware function accepts a handler function and returns a new handler function. </p> <p>Middleware functions can update the request or response map (adding keys, changingg values, coercing types or logging request and response maps) before passing it on to the handler function. </p> <p>An example: a middleware function which adds a <code>:friday?</code> key to the request map which is used in the hello-world handler : </p> <p>Edit the <code>src/practicalli/middleware.clj</code> file. </p> <p>Add the following middleware function, which takes a handler and returns a new handler function (which in turn adds a new key to the request map and calls the next handler in the chain): </p> <pre><code>(defn friday? [handler] (fn [request] (let [request (assoc request :friday? true)] (handler request)))) </code></pre> <p>In the middleware definition add the friday? middleware function call: </p> <pre><code>(def middleware [go-bowling? wrap-error-page wrap-exceptions])\n</code></pre> <p>In the <code>src/practicalli/routes/home.clj</code> adjust the <code>:body</code> value in our hello-world handler to include a message based on the :friday? key value on the request map. </p> <p>Adjust the handler function parameters to accept the request map: </p> <pre><code>(defn hello-world [request] {:status 200 :headers {\" Content-Type\" \"text/html\"} :body (str \"&lt;html&gt;&lt;body&gt; &lt;dt&gt;Is it Friday?&lt;/dt&gt;\"\"&lt;dd &gt;\"(:friday? request)\"&lt;/dd&gt;&lt;/body&gt;&lt;/html&gt;\")}) </code></pre> <p>Change the <code>/about</code> route to make use of the request map: </p> <pre><code>(GET \"/ about\" request (hello-world request))\n</code></pre> <p>Refresh the browser page at http://localhost:3000/about and see the middleware in action! </p> <p>Ring Wiki: Middleware concepts has further details on middleware and it's use in Ring </p>"},{"location":"reference/ring/#adapters","title":"Adapters","text":"<p>Adapters translate between the HTTP protocol and Clojure data, greatly simplifying all Clojure web applications.</p> <p>An adapter converts an incoming HTTP request into a Clojure request hash-map and passes the request to the Clojure web application.  The adaptor converts the Clojure response hash-map into the appropriate servlet HTTP response, sending that HTTP respose back to the client. </p> <p>The Ring library comes with a Jetty adapter ([ring/ring-jetty-adapter \"1.3.0\"]) which sits between a Jetty servlet container and the rest of the application stack. </p> <p>Http-kit also provides a ring compatible adaptor for its HTTP server.</p>"},{"location":"reference/ring/request-map/","title":"Ring - request map","text":"<ul> <li>What is a request</li> </ul> Key Always Present? Type Description :async-supported? Y boolean True if this request supports asynchronous operation :body Y ServletInputStream The body of the request. May be a zero-length stream. :content-type N String Present if sent by client. Content type of the request body. :content-length N Long Present if sent by client. Content length of the request body. :character-encoding N String Present if sent by client. Character encoding applicable to request body. :edn-params N Any :form-params N Map of keyword -&gt; String :headers Y Map of String -&gt; String Request headers sent by the client. Header names are all converted to lower case. :json-params N Map of String -&gt; String :params N Map of keyword or String -&gt; String Query params. See <code>:query-params</code>. :path-info Y String Request path, below the context path. Always at least \"/\", never an empty string. :path-params N Map of keyword -&gt; String Present if the router found any path parameters. :protocol Y String Name and version of the protocol with which the request was sent :query-params N Map of keyword -&gt; String :query-string Y String The part of the request's URL after the '?' character. :remote-addr Y String IP Address of the client (or the last proxy to forward the request) :request-method Y Keyword The HTTP verb used to make this request, lowercase and in keyword form. For example, :get or :post. <code>:put</code> and <code>:delete</code> request methods via a query parameter :_method :server-name Y String Host name of the server to which the request was sent :server-port Y int Port number to which the request was sent :scheme Y String The name of the scheme used to make this request, for example, http, https, or ftp. :ssl-client-cert N java.security.cert.X509Certificate[] Present if sent by client. Array of certificates that identify the client. :transit-params N Any data structure :uri Y String The part of this request's URL from the protocol name up to the query string in the first line of the HTTP request"},{"location":"relational-databases-and-sql/","title":"SQL and Relational Databases","text":"<p>seancorfield/next.jdbc is the defacto Clojure wrapper for SQL queries and managing connections to relational databases.</p> <p>next.jdbc supports a wide range of databases and automatically pulls in the relevant database drivers.  Abstractions are provided for insert, query, update and delete actions, which define data in a hash map allow the use of Clojure specifications (clojure.spec or Malli) for validation and generative testing.</p>"},{"location":"relational-databases-and-sql/#relational-databases","title":"Relational Databases","text":"<p>This guide will use the following relational databases</p> <ul> <li>H2 database - lightweight in-process database that writes to disk, easily added for a fast and simple dev environment.</li> <li>Postgresql - open source, feature rich and production grade database (defacto production choice)</li> </ul> <p>Other persistent storage approach include</p> <ul> <li>Amazon RDS - a postgres-like storage as an AWS service (should work just like postgres)</li> <li>CockroachDB an elastic, indestructible SQL database for developers building modern applications</li> <li>yugabyteDB open source, cloud native relational DB for powering global, internet-scale apps.</li> </ul>"},{"location":"relational-databases-and-sql/#key-value-stores","title":"Key Value stores","text":"<ul> <li>Redis</li> <li>RocksDB is a high performance embedded persistent key-value store with fast storage writes (fork of Google's LevelDB)</li> <li>AWS Dynamo - 400k limit per stored value</li> </ul>"},{"location":"relational-databases-and-sql/#clojure-databases","title":"Clojure databases","text":"<ul> <li>Crux - open database with temporal graph query</li> <li>Datomic - transactional database with a flexible data model, elastic scaling, and rich queries Interesting databases in the Clojure spaces include Datomic and Crux.</li> </ul>"},{"location":"relational-databases-and-sql/#database-drivers","title":"Database drivers","text":"<p>Database drivers for commonly used database</p> <ul> <li>Apache Derby</li> <li>H2</li> <li>HSQLDB</li> <li>Microsoft SQL Server jTDS</li> <li>Microsoft SQL Server -- Official MS Version</li> <li>MySQL</li> <li>PostgreSQL</li> <li>SQLite</li> </ul> <p>Database drivers may require a minimum version of Java, so consider Java 8 as the minimum version and Java 11 as the recommended version (until a new long term support version of Java is release).</p> <p>see database support at http://clojure-doc.org/articles/ecosystem/java_jdbc/home.html  (is this up to date?)</p> <p>Feedback welcome</p>"},{"location":"relational-databases-and-sql/h2-database/","title":"H2 Lightweight Relational Database","text":""},{"location":"relational-databases-and-sql/managing-connections/","title":"Managing database connections","text":"<p>A Clojure application / REPL can connect to a database source and request a new connection.  This connection can be used to send SQL statements to the database and receive the results.</p> <p>In a single threaded application, then only one connection to each database would be created.  In a multi-threaded application then multiple connections to the database may be created.  If multiple instances of an application are deployed, then multiple database connections will be created.</p> <p>As the number of simultaneous connections to the database grows, the more need for a connection pool service to maximize the performance of the database.</p>"},{"location":"relational-databases-and-sql/managing-connections/#postgresql","title":"PostgreSQL","text":"<p>When a client connects to PostgreSQL database the parent process spawns a worker process which listens to the newly created connection. Spawning a work process each time can support a small number of database connections. As the number of simultaneous connections increases, CPU and memory resources also increase.</p> <p>Without a connection pool a new database connection is created for each client.</p> <p></p>"},{"location":"relational-databases-and-sql/managing-connections/#hintlimits-via-postgresql-configuration","title":"Hint::Limits via PostgreSQL configuration","text":"<p>The <code>max_connections</code> configuration for PostgreSQL limits the number of client connections allowed, so additional connections are refused or dropped.</p>"},{"location":"relational-databases-and-sql/managing-connections/#connection-pool-with-postgresql","title":"Connection pool with PostgreSQL","text":"<p>A connection pool shares a fixed set of recyclable connections which can manage a large numbers of simultaneous connections due to the reduced CPU and memory usage.</p> <p>The fixed set of connections is called the pool size and it is recommended to test the size of the pool used during integration tests.</p> <p>A connection pool can efficiently deal with idle or stagnant client connections, as well as queue up client requests during traffic spikes instead of rejecting them.</p> <p></p>"},{"location":"relational-databases-and-sql/managing-connections/#connection-pool-implementations","title":"Connection pool implementations","text":"<p>A connection pool can be implemented either on the application side or as middleware between the database and your application.</p> <ul> <li>pgBouncer - a lightweight, open-source middleware connection pool for PostgreSQL.</li> <li>HikariCP - Fast, simple, reliable. HikariCP is a \"zero-overhead\" production ready JDBC connection pool. At roughly 130Kb, the library is very light.</li> <li>c3p0 - an easy-to-use library for making traditional JDBC drivers \"enterprise-ready\" by augmenting them with functionality defined by the jdbc3 spec and the optional extensions to jdbc</li> <li>Heroku pgBouncer build-pack, Heroku Postgres connection limit guidance and [Heroku Postgres plans] with connection limits.</li> <li>Tuning your PostgreSQL Server - wiki.postgresql.org</li> <li>PostgreSQL  12.4 Documentation</li> </ul>"},{"location":"relational-databases-and-sql/postgresql-database/","title":"Postgresql database","text":"<p>PostgreSQL is a powerful, open source object-relational database system with over 30 years of active development that has earned it a strong reputation for reliability, feature robustness, and performance.</p> <p>PostgreSQL is a common choice for Clojure WebApps that require a persistent store for data, especially where that data is relational in nature.  PostgreSQL is also a great choice for JSON and other formats.</p>"},{"location":"relational-databases-and-sql/postgresql-database/#heroku-postgres","title":"Heroku Postgres","text":"<p>Heroku provides a Posgresql service (free 10,000 rows limit per database) which provisions PostgreSQL databases on demand, so is a simple way to start development.</p> <p></p>"},{"location":"relational-databases-and-sql/h2-database/","title":"H2 Relational Database","text":"<p>H2 is a database distributed as library, making it a ideal for a self-contained development environment for a Clojure application with a relational database. Data is persisted to <code>mv.db</code> files as SQL queries are executed in Clojure.</p> <p></p> <p>H2 database  main features include * Very fast, open source, JDBC API * Embedded and server modes; in-memory databases * Browser based Console application * Small footprint: around 2 MB jar file size</p> <p>Whilst H2 could be used for very small production web applications, it is recommended only as a development time database.</p>"},{"location":"relational-databases-and-sql/h2-database/#using-h2-in-the-repl","title":"Using h2 in the REPL","text":"<p>H2 works with <code>next.jdbc</code>, the defacto relational database library for Clojure.</p>"},{"location":"relational-databases-and-sql/h2-database/#including-h2-in-clojure-projects","title":"Including H2 in Clojure projects","text":"<p><code>next.jdbc</code> is highly recommended library for SQL queries in Clojure</p> <p>{% tabs deps=\"deps.edn projects\", lein=\"Leiningen projects\" %}</p> <p>{% content \"deps\" %} To use H2 database as only a development database, add an <code>:extra-deps</code> entry to include the H2 library in a <code>:dev</code> alias in the project <code>deps.edn</code> file.</p> <pre><code>{:deps\n{org.clojure/clojure    {:mvn/version \"1.10.1\"}\norg.seancorfield/next.jdbc {:mvn/version \"1.1.569\"}}}\n{:aliases\n{:dev\n{:extra-deps {com.h2database/h2 {:mvn/version \"1.4.200\"}}}}}\n</code></pre> <p>Alternative, if using <code>practicalli/clojure-deps-edn</code> configuration, use the <code>:database-h2</code> alias when starting the REPL to include the H2 library on the class path.</p> <p>{% content \"lein\" %}</p> <p>Edit the <code>project.clj</code> configuration file and add the H2 library to the :dev-dependencies section to run H2 as the development only database.</p> <pre><code>(defproject project-name \"1.0-SNAPSHOT\"\n:description \"Database application using next.jdbc with H2 as development database\"\n:url \"http://practicalli.github.io/clojure/\"\n:dependencies [[org.clojure/clojure \"1.10.1\"]\n[seancorfield/next.jdbc \"1.1.582\"]]\n:dev-dependencies [[com.h2database/h2 \"1.4.200\"]])\n</code></pre> <p>{% endtabs %}</p>"},{"location":"relational-databases-and-sql/h2-database/#auto-increment-values-in-h2-database","title":"Auto-increment values in H2 database","text":"<p>The <code>IDENTITY</code> type is used for automatically generating an incrementing 64-bit long integer in H2 database.</p> <pre><code>CREATE TABLE public.account (\nid IDENTITY NOT NULL PRIMARY KEY ,\nname VARCHAR NOT NULL,\nnumber VARCHAR NOT NULL,\nsortcode VARCHAR NOT NULL,\ncreated TIMESTAMP WITH TIME ZONE NOT NULL);\n</code></pre> <p>No need to pass a value for our primary key column value as it is being automatically generated by H2.</p> <pre><code>INSERT INTO public.account ( id, name, number, sortcode, created)\nVALUES ( ? , ? , ? , ? );\n</code></pre>"},{"location":"relational-databases-and-sql/h2-database/#resources","title":"Resources","text":"<ul> <li>next.jdbc documentation and next.jdbc db-types list</li> <li>H2 Database website</li> <li>SQL Constraints - W3Schools.com</li> <li>Purpose of constraint naming - Stack Overflow</li> <li>seancorfield/honeysql - SQL as data structures</li> <li>stack overflow - auto increment id in h2 database</li> </ul>"},{"location":"relational-databases-and-sql/h2-database/database-tools/","title":"Database tools","text":"<p>DBeaver is a free database tool that supports the H2 database and many other databases.</p>"},{"location":"relational-databases-and-sql/h2-database/database-tools/#create-a-new-connection","title":"Create a new connection","text":"<p>Create a New Connection and select Embedded &gt; H2 database</p> <p>Select a <code>*.mv.db file</code> as the path</p> <p></p> <p>If the H2 driver is not installed in DBeaver, a will prompt will display to download it.</p> <p></p> <p>Expand the connection to see the schema details</p> <p></p>"},{"location":"relational-databases-and-sql/h2-database/database-tools/#h2-database-single-connection","title":"H2 database single connection","text":"<p>When connecting to the H2 database using a database management tool such  ad DBeaver, the database is locked and prevents code from running in the REPL.</p> <p></p> <p>Close the connection in the database management tool to continue using the REPL.</p>"},{"location":"relational-databases-and-sql/h2-database/schema-design/","title":"H2 Schema design","text":"<p>Key concepts and syntax for designing database schema for the H2 database</p>"},{"location":"relational-databases-and-sql/h2-database/schema-design/#auto-increment-values-in-h2-database","title":"Auto-increment values in H2 database","text":"<p>The <code>IDENTITY</code> type is used for automatically generating an incrementing 64-bit long integer in H2 database.</p> <pre><code>CREATE TABLE public.account (\nid IDENTITY NOT NULL PRIMARY KEY ,\nname VARCHAR NOT NULL,\nnumber VARCHAR NOT NULL,\nsortcode VARCHAR NOT NULL,\ncreated TIMESTAMP WITH TIME ZONE NOT NULL);\n</code></pre> <p>The value for <code>id</code> is automatically generated by H2, so no need to provide a value for id in the SQL statement</p> <pre><code>INSERT INTO public.account ( id, name, number, sortcode, created)\nVALUES ( ? , ? , ? , ? );\n</code></pre>"},{"location":"relational-databases-and-sql/h2-database/schema-design/#resources","title":"Resources","text":"<ul> <li>next.jdbc documentation and next.jdbc db-types list</li> <li>H2 Database website</li> <li>SQL Constraints - W3Schools.com</li> <li>Purpose of constraint naming - Stack Overflow</li> <li>seancorfield/honeysql - SQL as data structures</li> <li>stack overflow - auto increment id in h2 database</li> </ul>"},{"location":"relational-databases-and-sql/next-jdbc-library/","title":"SQL queries in Clojure with next.jdbc library","text":"<p>Using next.jdbc to connect to a database and run queries only a few steps</p> <ul> <li>add <code>seancorfield/next.jdbc</code> as a project dependency</li> <li>require the <code>seancorfield/next.jdbc</code> in the relevant project namespace definitions</li> <li>define a database specification (hash-map of database details or JDBC string)</li> <li>create a connection  (optionally using a connection pool)</li> <li>execute SQL statements (individual, batch, transaction)</li> </ul> <p></p>"},{"location":"relational-databases-and-sql/next-jdbc-library/#hintnextjdbc-supersedes-clojurejavajdbc","title":"Hint::next.jdbc supersedes clojure.java.jdbc","text":"<p>seancorfield/next.jdbc supersedes <code>clojure.java.jdbc</code> which used to be the defacto library for database backed projects.  next.jdbc is faster and exposes a more modern API design (according to the author of clojure.java.jdbc). Migration from clojure.java.jdbc is documented on the next.jdbc repository</p>"},{"location":"relational-databases-and-sql/next-jdbc-library/#live-coding-example","title":"Live Coding example","text":""},{"location":"relational-databases-and-sql/next-jdbc-library/#summary-of-using-nextjdbc","title":"Summary of using next.jdbc","text":"<p>Include next.jdbc as a dependency in the project</p> <pre><code>{:deps\n{org.clojure/clojure        {:mvn/version \"1.10.1\"}\norg.seancorfield/next.jdbc {:mvn/version \"1.1.569\"}}}\n</code></pre> <p>Require next.jdbc into the project namespace</p> <pre><code>(ns practicalli.database-access\n(:require [next.jdbc :as jdbc]))\n</code></pre>"},{"location":"relational-databases-and-sql/next-jdbc-library/#specify-the-database-connection","title":"Specify the database connection","text":"<p>Define a data source connection using a next.jdbc hash map or a JDBC URL</p> <p>An example next.jdbc specification for H2 database</p> <pre><code>{:dbtype \"h2\" :dbname \"banking-on-clojure\"}\n</code></pre> <p>An example JDBC connection string for postgres database</p> <pre><code>\"jdbc:postgresql://&lt;hostname&gt;:port/&lt;database-name&gt;?user=&lt;username&gt;&amp;password=&lt;password&gt;&amp;sslmode=require\"\n</code></pre>"},{"location":"relational-databases-and-sql/next-jdbc-library/#running-sql-queries","title":"Running SQL queries","text":"<p><code>execute!</code> runs an SQL statement and returns the results as a vector of hash maps. The hash maps use table and column name to create qualified keywords in the results.</p> <p>A Clojure string contains the SQL statement.</p> <pre><code>(jdbc/execute!\nconnection\n[(str \"insert into account_holders(\n               account_holder_id,first_name,last_name,email_address,residential_address,social_security_number)\n             values(\n               '\" account-holder-id \"', 'Jenny', 'Jetpack', 'jen@jetpack.org', '42 Meaning Lane, Altar IV', 'AB101112C' )\")])\n</code></pre>"},{"location":"relational-databases-and-sql/next-jdbc-library/#hintdatafy-results","title":"Hint::Datafy results","text":"<p>Hash maps returned by <code>execute!</code> use Datafy and are therefore navigable using Clojure data browsers</p>"},{"location":"relational-databases-and-sql/next-jdbc-library/#using-connections-and-queries-effectively","title":"Using connections and queries effectively","text":"<p>Define a name for the database connection using the form <code>(jdbc/get-datasource {:dbtype \"...\" :dbname \"...\" ...})</code></p> <pre><code>(def db-spec (jdbc/get-datasource {:dbtype \"h2\" :dbname \"banking-on-clojure\"}))\n</code></pre> <p>Use the <code>with-open</code> Clojure core function to automatically close connections after running SQL expressions</p> <pre><code>    (with-open [connection (jdbc/get-connection db-spec)]\n(jdbc/execute! connection [...]))\n</code></pre> <p>Defining a generic function provides a simple way to run any SQL query for a specified data base connection.</p> <pre><code>(defn query-database\n[db-spec sql-statement]\n(with-open [connection (jdbc/get-connection db-spec)]\n(jdbc/execute! connection sql-statement)))\n</code></pre>"},{"location":"relational-databases-and-sql/next-jdbc-library/#using-nextjdbc-friendly-functions","title":"Using next.jdbc friendly functions","text":"<p>next.jdbc provides higher level abstractions over execute! function.  These friendly functions take a database connection, a table name as a Clojure keyword and a hash map that contains the values in the query.  As the query is a hash map it can also be represented by a Clojure specification (clojure.spec or Malli).</p> <p>Function names ending with a bang, <code>!</code>, change the contents of the database</p> <ul> <li><code>insert!</code> - insert new rows</li> <li><code>query</code> - read data</li> <li><code>update!</code> - update existing rows</li> <li><code>delete!</code> - remove rows</li> </ul>"},{"location":"relational-databases-and-sql/next-jdbc-library/#generic-insert-function-with-nextjdbcsql","title":"Generic insert function with next.jdbc.sql","text":"<p>To save repetition, define a generic function that uses <code>insert</code> and takes a database table name, data to insert and the database connection.</p> <pre><code>(defn insert-data\n[db-spec table record-data]\n(with-open [connection (jdbc/get-connection db-spec)]\n(jdbc-sql/insert! connection table record-data)))\n</code></pre> <p>Call the generic insert function with the database connection, table name and query specification</p> <pre><code>(insert-data\ndb-spec\n:public.account_holders\n{:account_holder_id      (java.util.UUID/randomUUID)\n:first_name             \"Rachel\"\n:last_name              \"Rocketpack\"\n:email_address          \"rach@rocketpack.org\"\n:residential_address    \"1 Ultimate Question Lane, Altar IV\"\n:social_security_number \"BB104312D\"} )\n</code></pre>"},{"location":"relational-databases-and-sql/next-jdbc-library/#hintnextjdbc-getting-started-guide","title":"HINT::next.jdbc getting started guide","text":"<p>next.jdbc getting started guide is very detailed.</p>"},{"location":"relational-databases-and-sql/next-jdbc-library/add-to-project/","title":"Add next.jdbc to a project","text":"<p>Create a new Clojure project using clj-new tool (see Clojure install for details)</p> <pre><code>clojure -T:project/new :template app :name practicalli/simple-database\n</code></pre>"},{"location":"relational-databases-and-sql/next-jdbc-library/add-to-project/#main-library-dependency","title":"Main library dependency","text":"<p>Edit the <code>deps.edn</code> file in the root of the project directory.</p> <p>In the <code>:deps</code> hash-map, add next.jdbc libraries as a dependency</p> <pre><code>{:deps {org.clojure/clojure    {:mvn/version \"1.10.1\"}\norg.seancorfield/next.jdbc {:mvn/version \"1.1.569\"}}}\n</code></pre> <p>An alias should be used to include the H2 database library as a development dependency, to avoid including it in the packaged project.</p> <p>{% tabs practicalli=\"practicalli/clojure-deps-edn\", manual=\"Manually add Alias\" %}</p> <p>{% content \"practicalli\" %}</p> <p>practicalli/clojure-deps-edn provides user level aliases that can be used with any project</p> <p><code>:database/h2</code> adds the library dependency for H2 database</p> <p>{% content \"manual\" %}</p> <p>Edit the project <code>deps.edn</code> file in the root of the project (or add an alias to the user level deps.edn to use with any project).</p> <p>Include an <code>:extra-deps</code> section for the H2 library</p> <pre><code>{:deps {org.clojure/clojure    {:mvn/version \"1.10.1\"}\norg.seancorfield/next.jdbc {:mvn/version \"1.1.569\"}}}\n:aliases\n{:database/h2\n{:extra-deps {com.h2database/h2 {:mvn/version \"2.1.210\"}}}}\n</code></pre> <p>{% endtabs %}</p>"},{"location":"relational-databases-and-sql/next-jdbc-library/add-to-project/#starting-a-repl-for-development","title":"Starting a REPL for development","text":"<p>Include the <code>:database/h2</code> alias when starting a REPL</p> <pre><code>clojure -M:database/h2:repl/rebel\n</code></pre>"},{"location":"relational-databases-and-sql/next-jdbc-library/add-to-project/#staging-and-production-dependencies","title":"Staging and Production dependencies","text":"<p>Assuming PostgreSQL is used as the staging and production database, the postgres library should be added to the main dependencies of the project.</p> <p>In the <code>:deps</code> hash-map, add the PostgreSQL JDBC driver library as dependencies along-side next.jdbc.</p> <pre><code>{:deps\n{org.clojure/clojure {:mvn/version \"1.10.1\"}\n;; Database\norg.seancorfield/next.jdbc    {:mvn/version \"1.1.582\"}\norg.postgresql/postgresql {:mvn/version \"42.2.16\"}}}\n</code></pre>"},{"location":"relational-databases-and-sql/next-jdbc-library/add-to-project/#hintcheck-for-latest-library-versions","title":"Hint::Check for latest library versions","text":"<p>Check clojars.org for latest version org.seancorfield/next.jdbc and Maven Central for latest version of H2 database</p> <p>jdbc.postgres.org shows the latest release, or look at the Postgresql page on Maven Central</p>"},{"location":"relational-databases-and-sql/next-jdbc-library/connection-pool-lifecycle/","title":"Using next.jdbc with a Connection pool","text":"<p>As the scale of database use increases it becomes more efficient to continually re-use existing connections to the database, rather than create a new connection to execute each SQL statement.</p> <p>A connection pool is a set of open connections that are used over and over again, enhancing the performance of the database and allowing the database to scale more efficiently.</p> <p>Databases may provide their own connection pool (postgres has ..., h2 has ...).  Hikari and c3p0  are commonly used database connection pool libraries</p> <p></p>"},{"location":"relational-databases-and-sql/next-jdbc-library/connection-pool-lifecycle/#configure-nextjdbc-with-a-connection-pool","title":"Configure next.jdbc with a connection pool","text":"<ul> <li>Add connection pool library (question: if using a db connection pool, is this just the driver?)</li> <li>Require <code>next.jdbc</code> and <code>next.jdbc.connection</code> in the Clojure namespace where the connection pool will be used</li> </ul> <p>{% tabs hikari=\"hikari\", c3p0=\"C3P0\", h2=\"H2 database\", postgresql=\"PostgreSQL database\" %}</p> <p>{% content \"hikari\" %}</p> <pre><code>(ns my.main\n(:require\n[next.jdbc :as jdbc]\n[next.jdbc.connection :as connection])\n(:import\n(com.zaxxer.hikari HikariDataSource)))\n</code></pre> <p>Create a database specification</p> <p>HikariCP requires <code>:username</code> instead of <code>:user</code> in the db-spec</p> <pre><code>(def ^:private db-spec {:dbtype \"...\" :dbname \"...\" :username \"...\" :password \"...\"})\n</code></pre> <p>When using a JDBC URL with a connection pool, use <code>:jdbcUrl</code> in the database spec instead of <code>:dbtype</code>, <code>:dbname</code>, etc)</p> <p>{% content \"c3p0\" %}</p> <pre><code>(ns my.main\n(:require\n[next.jdbc :as jdbc]\n[next.jdbc.connection :as connection])\n(:import\n(com.mchange.v2.c3p0 ComboPooledDataSource PooledDataSource)))\n</code></pre> <p>{% content \"h2\" %}</p> <p>{% endtabs %}</p>"},{"location":"relational-databases-and-sql/next-jdbc-library/connection-pool-lifecycle/#execute-with-a-connection-pools","title":"Execute with a connection pools","text":"<p><code>next.jdbc.connection/-&gt;pool</code> takes a connection pool (Java Class) and a database specification.</p> <pre><code>(with-open [^HikariDataSource ds (connection/-&gt;pool HikariDataSource db-spec)]\n(jdbc/execute! ds ...)\n(jdbc/execute! ds ...)\n(do-other-stuff ds args)\n(into [] (map :column) (jdbc/plan ds ...)))\n</code></pre>"},{"location":"relational-databases-and-sql/next-jdbc-library/connection-pool-lifecycle/#configure-nextjdbc-with-lifecycle-management-libraries","title":"Configure next.jdbc with lifecycle management libraries","text":"<p>A connection pool has a start/stop lifecycle, so fits easily into lifecycle management libraries such as mount, component and integrant.</p> <p>Start the database server connection pool</p> <p>Assumes database is a separate service already running.  Add a check for the status of the database before starting the components?</p> <p>{% tabs mount=\"Mount\", component=\"Component\", integrant=\"Integrant\" %}</p> <p>{% content \"mount\" %}</p> <p>{% content \"component\" %} <code>next.jdbc.connection/component</code> supports Component directly by creating a Component-compatible entity.</p> <p>Example code from next.jdbc.connection/component</p> <pre><code>(component/start (connection/component HikariDataSource db-spec))\n</code></pre> <pre><code>(ns practicalli.application\n(:require\n[com.stuartsierra.component :as component]\n[next.jdbc :as jdbc]\n[next.jdbc.connection :as connection])\n(:import\n(com.zaxxer.hikari HikariDataSource)))\n(def ^:private db-spec {:dbtype \"...\" :dbname \"...\" :username \"...\" :password \"...\"})\n(defn -main [&amp; args]\n;; connection/component takes the same arguments as connection/-&gt;pool:\n(let [ds (component/start (connection/component HikariDataSource db-spec))]\n(try\n;; \"invoke\" the data source component to get the javax.sql.DataSource:\n(jdbc/execute! (ds) ...)\n(jdbc/execute! (ds) ...)\n;; can pass the data source component around other code:\n(do-other-stuff ds args)\n(into [] (map :column) (jdbc/plan (ds) ...))\n(finally\n;; stopping the component will close the connection pool:\n(component/stop ds)))))\n</code></pre> <p>{% content \"integrant\" %}</p> <p>{% endtabs %}</p>"},{"location":"relational-databases-and-sql/next-jdbc-library/database-specifications/","title":"Database Specifications","text":"<p>Call the <code>next.jdbc/get-datasource</code> function with a database specification or a JDBC URL string</p> <p>A database specification is a hash map describing the database you wish to connect to.  TODO: examples of database specifications</p> <p>A \"database spec\" is a Clojure map that specifies how to access the data source. Specify the database type, the database name, and the username and password.</p> <pre><code>(def db-spec\n{:dbtype \"mysql\"\n:dbname \"db-name\"\n:user \"user-account\"\n:password \"secret\"})\n</code></pre> <p>use aero to use a different database specification based on the environment being run (dev, test, prod, etc.)</p> <p>next.jdbc also works with connection pooling libraries which can be used to construct a datasource from. Examples include HikariCP or c3p0</p>"},{"location":"relational-databases-and-sql/next-jdbc-library/next-jdbc-and-resultsets/","title":"next.jdbc and result sets","text":"<p>We are using the db-query-with-resultset  to apply a result-set-fn on the result-set lazily (in the db sense) but the fetch-size doesn't seem to be respected. If I do a (count result-set) it returns the size of the all the rows expected from the query instead of the fetch size, this is how our function looks like. clojure.java.jdbc version is \"0.3.5\" <pre><code>(defn do-lazy-read [db-spec sql-params size result-set-fn]\n(jdbc/db-query-with-resultset\ndb-spec\n(into [] (cons {:fetch-size size} sql-params))\n(fn [result-set]\n(prn (count result-set))\n(-&gt; result-set\n(jdbc/result-set-seq :identifiers qstr/underscores-&gt;hyphens)\nresult-set-fn))))\n</code></pre></p> <p>That is expected <code>:fetch-size</code> is not a limit, it's just a hint for each \"chunk\" of the overall result set during database access.</p> <p>But we are facing memory issues and we think this not being lazy is the cause, number of rows are in the order of a few 100,000 rows to a million</p> <p>You need reducible-query</p> <p>Haven\u2019t used it before, but it seems it will close the connection after reducing the result-set, how would I go about maintaining the cursor? (edited)</p> <p>I am going through the documentation, will explore reducible query. But the question is if lets say the fetch size 1000 is just a hint, why is the hint not considered? Why would it always return all the rows, that too rows close to a million?</p> <p>Reading this answer of yours https://stackoverflow.com/questions/39765943/clojure-java-jdbc-lazy-query/39775018#39775018 and the linked docs and the other SO question on why jdbc ignores setFetchSize (edited)</p> <ol> <li>fetch size tells the JDBC driver to try to only fetch that many rows at a time but it is not a limit on how many rows come back in the result set 17:43</li> <li>the result set is built lazily -- so result-set is a lazy sequence and if you call count you will realize the entire sequence, which will be you 1M rows 17:44</li> <li>even trying to process result set lazily and using fetch, you are at the usual mercy of Clojure's treatment of very large lazy sequences -- and you must completely process the result set before c.j.j. closes the connection (otherwise you'll get errors when you try to realize the next piece of the lazy result set -- because it relies on the connection staying open). 17:45</li> <li>since all of that is very tricky (as you're discovering), reducible-query was added so you can process the result set in a single pass reduction without needing to worry about laziness 17:46 FWIW, next.jdbc is built on that concept as a primary API: next.jdbc/plan is explicitly a reducible that is also \"foldable\" (in the clojure.core.reducers/fold sense so you can achieve some level of concurrency as well). 17:47 The reducible-query function in c.j.j. is the predecessor to next.jdbc/plan -- but the latter is better designed for performance (as is the whole of next.jdbc). 17:49 As another part of #3 above: holding onto the head is definitely a possibility -- as with processing any very large lazy sequence, but you're dealing with a Clojure problem there, not a JDBC problem. 17:49</li> </ol>"},{"location":"relational-databases-and-sql/next-jdbc-library/simple-example/","title":"Simple database example","text":"<p>Create a project called simple database</p> <pre><code>clojure -T:project/new :template app :name practicalli/simple-database\n</code></pre> <p>Edit the <code>deps.edn</code> file in the root of the project directory.</p> <p>In the <code>:deps</code> hash-map, add next.jdbc library as dependency and add a <code>:dev</code> alias could include an <code>:extra-deps</code> section for the H2 driver</p> <pre><code>{:deps {org.clojure/clojure        {:mvn/version \"1.10.1\"}\norg.seancorfield/next.jdbc {:mvn/version \"1.1.569\"}}}\n{:dev\n{:extra-deps {com.h2database/h2 {:mvn/version \"1.4.200\"}}}}\n</code></pre> <p>{% tabs repl=\"In the REPL\", project=\"In a Clojure Project\" %}</p> <p>{% content \"repl\" %}</p>"},{"location":"relational-databases-and-sql/next-jdbc-library/simple-example/#using-nextjdbc-in-a-repl-session","title":"Using next.jdbc in a REPL session","text":"<p>In a terminal window, change to the root directory of the <code>simple-database</code> project.</p> <p>Start a Rebel REPL from the root of the new project</p> <p><pre><code>cd simple-project\n\nclojure -M:repl/rebel\n</code></pre> The first time libraries are used they are downloaded and cached locally (<code>~/.m2/repository</code>)</p> <p></p> <p>Require the <code>next.jdbc</code> namespace using an alias called <code>jdbc</code></p> <pre><code>(require '[next.jdbc :as jdbc])\n</code></pre> <p>Define a database specification containing the details of the H2 database to be used</p> <pre><code>(def db-specification {:dbtype \"h2\" :dbname \"address-book\"})\n</code></pre> <p>Define a data source that is a connection to the database</p> <pre><code>(def data-source (jdbc/get-datasource db-specification))\n</code></pre> <p>Create a table in the database using a standard SQL statement</p> <pre><code>(jdbc/execute!\ndata-source\n[\"create table contacts (\n     id int auto_increment primary key,\n     name varchar(32),\n     email varchar(255))\"])\n</code></pre> <p>An <code>address-book.mv.db</code> file is created in the root of the project</p> <p>Insert an entry into the database by executing an SQL insert query</p> <pre><code>(jdbc/execute!\ndata-source\n[\"insert into contacts(name,email)\n    values('Jenny Jetpack','jenny@jetpack.org')\"])\n</code></pre> <p>View all the records added to the database (there should be only one)</p> <pre><code>(jdbc/execute!\ndata-source\n[\"select * from address\"])\n</code></pre> <p></p> <p>To delete all the records in the database, drop the contacts table in the database</p> <pre><code>(jdbc/execute!\ndata-source\n[\"drop table contacts\"])\n</code></pre> <p></p> <p>{% content \"project\" %}</p> <p>Edit the file <code>src/practicalli/simple-database.clj</code> from the <code>simple-database</code> project.</p> <p>Update the <code>practicalli.simple-database</code> namespace definition with a require statement for next.jdbc</p> <pre><code>(ns practicalli.simple-database\n(:gen-class)\n(:require [next.jdbc :as jdbc]))\n</code></pre> <p>Define a data source for the H2 database</p> <pre><code>(def db-specification {:dbtype \"h2\" :dbname \"address-book\"})\n</code></pre> <p>Define a data source that is a connection to the database</p> <pre><code>(def data-source (jdbc/get-datasource db-specification))\n</code></pre> <p>Create a table in the database using a standard SQL statement</p> <pre><code>(jdbc/execute!\ndata-source\n[\"create table contacts (\n     id int auto_increment primary key,\n     name varchar(32),\n     email varchar(255))\"])\n</code></pre> <p>An <code>address-book.mv.db</code> file is created in the root of the project</p> <p>Insert an entry into the database by executing an SQL insert query</p> <pre><code>(jdbc/execute!\ndata-source\n[\"insert into contacts(name,email)\n    values('Jenny Jetpack','jenny@jetpack.org')\"])\n</code></pre> <p>View all the records added to the database (there should be only one)</p> <pre><code>(jdbc/execute!\ndata-source\n[\"select * from address\"])\n</code></pre> <p>To delete all the records in the database, drop the contacts table in the database</p> <pre><code>(jdbc/execute!\ndata-source\n[\"drop table contacts\"])\n</code></pre> <p>{% endtabs %}</p>"},{"location":"relational-databases-and-sql/next-jdbc-library/simple-example/#hintdatabase-driver-lookup","title":"Hint::Database driver lookup","text":"<p>The <code>:dbtype</code> (:classname) is used to find the correct database driver</p>"},{"location":"server-side-api/","title":"Server-side API's","text":"<p>We can build an Application Programming Interface (API) in Clojure by building on the techniques we have learnt as we built our server-side web applications (ring, compojure, etc.).</p>"},{"location":"server-side-api/#compojure-api","title":"compojure-api","text":"<p>We are going to use the <code>compojure-api</code> library and its Leiningen template to quickly build our API.</p> <p></p> <p>Compojure API documentation</p>"},{"location":"server-side-api/#prismatic-schema","title":"Prismatic schema","text":"<p>Schema validation defines the shape of any data that the API will respond with as well as any data that is sent along with a request.</p>"},{"location":"server-side-api/#self-documenting-with-swagger","title":"Self-documenting with Swagger","text":"<p>This template contains Swagger that documents the API's you are creating and ring-swagger constructs the documentation as you create your code.</p> <p></p>"},{"location":"server-side-api/#lein-ring-reloaded-workflow","title":"lein-ring Reloaded workflow","text":"<p><code>lein-ring</code> is a plugin for Leiningen that will reload code changes into a running web application server (i.e. Jetty).</p>"},{"location":"server-side-api/#references","title":"References","text":"<ul> <li>Getting started with Compojure API</li> <li><code>ring-swagger</code></li> <li>RESTful CRUD APIs Using Compojure-API and Toucan - part1</li> <li>RESTful CRUD APIs Using Compojure-API and Toucan - part2</li> </ul>"},{"location":"server-side-api/#alternatives","title":"Alternatives","text":"<ul> <li>Yada introduction - JUXT.pro</li> <li>Yada manual</li> </ul>"},{"location":"server-side-api/cheshire/","title":"Cheshire - fast JSON encoding","text":"<p>Cheshire is fast JSON encoding library with support for Date/UUID/Set/Symbol encoding and SMILE support.</p> <ul> <li>Github repository and usage</li> <li>API documentation</li> </ul>"},{"location":"server-side-api/compojure-api-template/","title":"compojure-api template","text":"<p>Quickly create the basics of a server-side webapp with the compojure-api template for Leiningen.</p> <pre><code>lein new compojure-api project-name\n</code></pre> <p>This command creates a new Clojure project in a directory called scoreboard-service.</p>"},{"location":"server-side-api/compojure-api-template/#adding-tests","title":"Adding tests","text":"<p>Using either of the <code>+clojure-test</code> or <code>+midge</code> will add the specific test library to the project created.</p> <pre><code>lein new compojure-api project-name +clojure-test\n</code></pre>"},{"location":"server-side-api/create-compojure-api-project/","title":"Create a compojure-api project","text":""},{"location":"server-side-api/create-compojure-api-project/#notecreate-a-project-with-tests","title":"NOTE::Create a project with tests","text":"<pre><code>lein new compojure-api my-api +clojure-test\n</code></pre>"},{"location":"server-side-api/create-compojure-api-project/#deconstruct-the-project","title":"Deconstruct the project","text":"<p>The project this template creates is relatively simple in terms of dependencies in the <code>project.clj</code> file</p> <pre><code>  (defproject my-api \"0.1.0-SNAPSHOT\"\n:description \"Experimenting with the compojure-api\"\n:dependencies [[org.clojure/clojure \"1.8.0\"]\n[metosin/compojure-api \"1.1.11\"]]\n:ring {:handler my-api.handler/app}\n:uberjar-name \"server.jar\"\n:profiles {:dev {:dependencies [[javax.servlet/javax.servlet-api \"3.1.0\"]\n[cheshire \"5.5.0\"]\n[ring/ring-mock \"0.3.0\"]]\n:plugins [[lein-ring \"0.12.0\"]]}})\n</code></pre> <p>Interesting things to note are its using the <code>lein-ring</code> plugin, so we should run the application with <code>lein ring server</code>.</p> <p>When we want to deploy the application then we should use the <code>lein ring uberjar</code> command to create an uberjar (a java archive file that includes our Clojure application and the <code>clojure.core</code> library, so we can just run it as a java library).</p>"},{"location":"server-side-api/create-compojure-api-project/#dev-profile","title":"<code>:dev</code> profile","text":"<p>In the <code>:dev</code> profile, dependencies include <code>ring/ring-mock</code> library to help us test our server-side web application.</p> <p>There is also the <code>cheshire</code> library to help us work with JSON data in an efficient way.</p>"},{"location":"server-side-api/json-files/","title":"Working with JSON files","text":"<p>slurp will read files into our Clojure code.</p> <pre><code>(slurp \"spicy-vegan-pepperoni.json\")\n</code></pre> <p>We can use cheshire library to convert the JSON to a Clojure data structure.</p> <pre><code>(cheshire/parse-string\n(slurp \"spicy-vegan-pepperoni.json\"))\n;; =&gt; {\"name\" \"Spicy Vegan Pepperoni\", \"size\" \"XL\", \"origin\" {\"country\" \"PO\", \"city\" \"Tampere\"}, \"description\" \"Healthy and delicious Vegan version of a double pepperoni pizza with some jalapenos to spice it up\"}\n</code></pre> <p>Lets pretty print the Clojure data structure to make it easier to read</p> <pre><code>(clojure.pprint/pprint\n(cheshire/parse-string\n(slurp \"spicy-vegan-pepperoni.json\")))\n;; =&gt; nil\n;; From the REPL output\n{\"name\"   \"Spicy Vegan Pepperoni\",\n \"size\"   \"XL\",\n \"origin\" {\"country\" \"PO\", \"city\" \"Tampere\"},\n \"description\"\n\"Healthy and delicious Vegan version of a double pepperoni pizza with some jalapenos to spice it up\"}\n</code></pre>"},{"location":"server-side-api/plumatic-schema/","title":"Plumatic schema - defining the shape of data","text":"<p>As an API is an external system then it is important to define the shape of data coming into and leaving the application.</p> <p>Plumatic schema is a simple way to define the shape of data in Clojure without having to define fixed static types.</p>"},{"location":"server-side-api/plumatic-schema/#dice-roll-result","title":"Dice roll result","text":"<p>In this example. our API is related to a game and we call our API to get the result of a dice roll</p> <pre><code>(s/defschema DiceRollResult\n{:result s/Int})\n</code></pre>"},{"location":"server-side-api/plumatic-schema/#customer","title":"Customer","text":"<p>Most business systems (and most systems in general) have some concept of a user or customer.  Here we define a schema for a valid customer.</p> <p>In this example, a valid customer lives in one of two cities, as defined using an schema enumeration (enum)</p> <pre><code>(s/defschema Customer {:id      s/Str,\n                       :name    s/Str\n:address {:street s/Str\n:city   (s/enum :maidstone :dover)}})\n</code></pre>"},{"location":"server-side-api/plumatic-schema/#pizza-order","title":"Pizza Order","text":"<p>We can make the data be as specific or as general as we need.  Enumerations allow us to limit the set of valid options.  If there were a lot of options then it may be useful to define them as a data structure in their own namespace.</p> <pre><code>(s/defschema Pizza\n{:name           s/Str\n:size           (s/enum :L :M :S)\n:origin         {:country (s/enum :FI :PO)\n:city    s/Str}\n(s/optional-key\n:description) s/Str})\n(s/defschema Customer {:id      s/Str,\n                       :name    s/Str\n:address {:street s/Str\n:city   (s/enum :maidstone :dover)}})\n</code></pre>"},{"location":"server-side-api/plumatic-schema/#legitimate-ferry-company","title":"Legitimate Ferry Company","text":"<p>We can use the data we define to ensure that something is valid.  For example, if a Ferry company uses this API to register themselves as a business, we can ensure we capture the number of ferries they have.</p> <p>In the logic of our API we can use the number of ferries value to check if we should register this company.  If it has no ferries, then we shouldn't register the company.</p> <pre><code>(s/defschema FerryCompany\n{:name              s/Str\n:number-of-ferries Long\n:country           (s/enum :UK :France :Netherlands)\n(s/optional-key\n:description)    s/Str})\n</code></pre>"},{"location":"server-side-api/ring-mock/","title":"ring-mock","text":"<p><code>ring-mock</code> is a testing library for server-side applications</p> <p>Ring-Mock creates Ring request maps to assist with defining tests in Clojure.</p>"},{"location":"server-side-api/ring-mock/#installation","title":"Installation","text":"<p>Add the following development dependency to your <code>project.clj</code> file:</p> <pre><code>[ring/ring-mock \"0.3.2\"]\n</code></pre>"},{"location":"server-side-api/ring-mock/#examples","title":"Examples","text":"<pre><code>(ns your-app.core-test\n(:require [clojure.test :refer :all]\n[your-app.core :refer :all]\n[ring.mock.request :as mock]))\n(deftest your-handler-test\n(is (= (your-handler (mock/request :get \"/doc/10\"))\n{:status  200\n:headers {\"content-type\" \"text/plain\"}\n:body    \"Your expected result\"})))\n(deftest your-json-handler-test\n(is (= (your-handler (-&gt; (mock/request :post \"/api/endpoint\")\n(mock/json-body {:foo \"bar\"})))\n{:status  201\n:headers {\"content-type\" \"application/json\"}\n:body    {:key \"your expected result\"}})))\n</code></pre>"},{"location":"server-side-api/ring-swagger/","title":"ring-swagger","text":"<p><code>ring-swagger</code> is a Swagger 2.0 implementation for Clojure/Ring using Plumatic Schema (support for clojure.spec via spec-tools.</p> <ul> <li>Transforms deeply nested Schemas into Swagger JSON Schema definitions</li> <li>Extended &amp; symmetric JSON &amp; String serialization &amp; coercion</li> <li>Middleware for handling Schemas Validation Errors &amp; Publishing swagger-data</li> <li>Local api validator</li> <li>Swagger artifact generation</li> <li>swagger.json via ring.swagger.swagger2/swagger-json</li> <li>Swagger UI bindings. (get the UI separately as jar or from NPM)</li> </ul>"},{"location":"server-side-api/ring-swagger/#documentation","title":"Documentation","text":"<ul> <li><code>ring-swagger</code> API documentation</li> </ul>"},{"location":"server-side-api/swagger/","title":"Swagger - self describing APIs","text":""},{"location":"server-side-api/terminology/","title":"Terminology","text":""},{"location":"server-side-api/terminology/#application-programming-interface-api","title":"Application Programming Interface (API)","text":"<p>An API defines how to use another piece of software.  The API shows you the public functions and data you can use with your own software, allowing you to do more with less code.</p> <p>https://en.wikipedia.org/wiki/Application_programming_interface</p>"},{"location":"server-side-api/terminology/#uniform-resource-identifier-uri","title":"Uniform Resource Identifier (URI)","text":"<p>A Uniform Resource Identifier (URI) is a string of characters that unambiguously identifies a particular resource. To guarantee uniformity, all URIs follow a predefined set of syntax rules,[1] but also maintain extensibility through a separately defined hierarchical naming scheme (e.g. \"http://\").</p> <p>https://en.wikipedia.org/wiki/Uniform_Resource_Identifier</p>"},{"location":"server-side-api/terminology/#uniform-resource-locator-url","title":"Uniform Resource Locator (URL)","text":"<p>A web page and the images and videos it contains all have their own URL, a specific address where they can be found on the Internet.</p> <p>A URL is a specific form of URI for web pages and the content that they contain.</p> <p>https://en.wikipedia.org/wiki/URL</p>"},{"location":"server-side-api/testing-api/","title":"Testing our API","text":"<p>We used the <code>clojure-test</code> option when we created the project, so we will use this built in library.</p>"},{"location":"server-side-api/testing-api/#writing-tests","title":"Writing tests","text":"<p>Writing tests is just the same as other Clojure applications.</p> <pre><code>(deftest a-test\n(testing \"Test GET request to /hello?name={a-name} returns expected response\"\n(let [response (app (-&gt; (mock/request :get  \"/api/plus?x=1&amp;y=2\")))\nbody     (parse-body (:body response))]\n(is (= (:status response) 200))\n(is (= (:result body) 3)))))\n</code></pre>"},{"location":"server-side-api/testing-api/#using-helper-functions","title":"Using helper functions","text":"<p>It is good practice to create helper functions to extract out common code into its onw function.  This saves on duplication, reduces maintenance and should improve the readability of your tests.</p> <p>Here is an example of a helper function that reads data in the form of JSON and creates a Clojure map for us to work with.</p> <pre><code>(defn parse-body [body]\n(cheshire/parse-string (slurp body) true))\n</code></pre>"},{"location":"server-side-api/testing-api/#hintcheshire-api","title":"HINT::Cheshire API","text":"<p>See the parse-string description in the Cheshire API documentation</p>"},{"location":"server-side-api/testing-api/#including-test-libraries-in-the-namespace","title":"Including test libraries in the namespace","text":"<p>Including the testing libraries is standard <code>:require</code> statements.</p> <pre><code>(ns my-api.core-test\n(:require [cheshire.core :as cheshire]\n[clojure.test :refer :all]\n[my-api.handler :refer :all]\n[ring.mock.request :as mock]))\n</code></pre>"},{"location":"server-side-api/testing-api/#ringmock-library","title":"<code>ring.mock</code> library","text":"<p>A library to help you mock parts of your server-side application.  This works just as well for APIs as web applications.</p>"},{"location":"server-side-api/testing-api/#hintwriting-files-in-clojure-with-spit","title":"HINT::Writing files in Clojure with spit","text":"<p><code>spit</code> is a simple function that will write files.</p>"},{"location":"server-side-api/end-to-end-testing/","title":"End to end API testing","text":"<p>There are several tools for testing your API.</p> Tools Description OpenAPI (Swagger) Provides live documentation of an API and ability to run API calls curl Command line tool for talking to the web (client side) Insomnia.rest HTTP and GraphQL toolbelt for debugging APIs (client side) Postman Collaborative platform for API development <p>Open API should be built into any API you build as it provides living documentation of your API as you develop, as well as a way for developers to test queries against your API.</p> <p>curl is the classic command line tool for testing anything on the web.  Its an excellent tool for one off tests or for writing a batch of tests in a script.</p> <p>Insomnia is a great tool to help you debug your API and generate code for API calls in over 30 different programming languages.</p> <p>Postman is aimed more at the corporate developer or someone dealing with a large set of APIs.  It requires more setup although provides more features.</p>"},{"location":"server-side-api/end-to-end-testing/curl/","title":"curl","text":""},{"location":"server-side-api/end-to-end-testing/curl/#todowork-in-progress-sorry","title":"TODO::work in progress, sorry","text":"<p>Pull requests are welcome</p>"},{"location":"server-side-api/end-to-end-testing/httpie/","title":"HTTPie","text":""},{"location":"server-side-api/end-to-end-testing/postman/","title":"Postman","text":""},{"location":"server-side-api/end-to-end-testing/postman/#todowork-in-progress-sorry","title":"TODO::work in progress, sorry","text":"<p>Pull requests are welcome</p>"},{"location":"server-side-api/end-to-end-testing/swagger/","title":"Swagger","text":""},{"location":"server-side-api/end-to-end-testing/swagger/#todowork-in-progress-sorry","title":"TODO::work in progress, sorry","text":"<p>Pull requests are welcome</p>"},{"location":"server-side-api/projects/game-scoreboard/","title":"Create a new project with compojure-api template","text":"<p>You can quickly create the basics of a server-side webapp with the compojure-api template for Leiningen.</p> <pre><code>lein new compojure-api game-scoreboard +clojure-test\n</code></pre> <p>This command creates a new Clojure project in a directory called game-scoreboard.</p>"},{"location":"server-side-api/projects/game-scoreboard/#update-clojure-version","title":"Update Clojure version","text":"<p>Edit the <code>project.clj</code> file and update the <code>org.clojure/clojure</code> dependency to <code>1.10.0</code></p>"},{"location":"server-side-api/projects/game-scoreboard/defining-scoreboard/","title":"Defining Scores and a Scoreboard","text":"<p>We use the Plumatic schema to define what a score looks like, as well as what the overall scoreboard looks like.</p>"},{"location":"server-side-api/projects/game-scoreboard/defining-scoreboard/#scores","title":"Scores","text":"<p>A score is an whole number (Integer) that represents the score achieved for a particular game</p> <pre><code>(schema/defschema Score\n{:player-id   schema/Uuid\n:score       schema/Int\n(schema/optional-key\n:gravitar) schema/Str})\n</code></pre>"},{"location":"server-side-api/projects/game-scoreboard/defining-scoreboard/#leaderboard","title":"Leaderboard","text":"<p>The Leader board is a collection of scores for a game.  The scoreboard is ordered by highest value by default.</p>"},{"location":"server-side-api/projects/game-scoreboard/defining-scoreboard/#player","title":"Player","text":""},{"location":"server-side-api/projects/game-scoreboard/defining-scoreboard/#player-accounts","title":"Player accounts","text":""},{"location":"server-side-api/projects/game-scoreboard/defining-scores/","title":"Defining Scores","text":""},{"location":"server-side-api/projects/game-scoreboard/defining-scores/#todowork-in-progress-sorry","title":"TODO::work in progress, sorry","text":""},{"location":"server-side-api/projects/game-scoreboard-ui/","title":"Game Scoreboard UI","text":"<p>Create a Web user interface for the Scoreboard so we can test out the API and do something interesting with the results.</p> <ul> <li>Create a project using figwheel-main</li> </ul>"},{"location":"server-side-api/projects/game-scoreboard-ui/create-project/","title":"Create new project using figwheel-main","text":"<p>Create a new project using figwheel-main, the newest version of figwheel.</p> <p>Include the <code>reagent</code> library to make the project a single page app in the style of react.js.</p> <pre><code>lein new figwheel-main game-scoreboard-ui -- --reagent\n</code></pre> <p></p> <p>Change into the 'game-scoreboard-ui' directory and run 'lein fig:build'</p> <pre><code>cd game-scoreboard-ui\nlein fig:build\n</code></pre> <p>Your default browser will open at localhost:9500</p> <p></p>"},{"location":"service-repl-workflow/","title":"Clojure Service REPL workflow","text":"<p>General Clojure REPL workflow - Practicalli Guide</p> <p>Services are composed of components such as HTTP server, database connection, log publisher, message queue, etc.  long running processes to manage as well.</p> <p>Clojure web services typically included a long running process such as an</p> <p>Integrant REPL extends the REPL driven development workflow to Clojure web applications and services, following the ideas discussed in the Clojure Reloaded workflow.</p> <p>Integrant REPL is a library to manage services using a data structure that defines the configuration of each service and dependencies between services in the system or external to the system.</p> <p>By defining relationships between services, such as an HTTP server and a Persistent store, a simple Inversion of control or Dependency injection approach can be achieved by passing the relevant parts of the configuration to each service.  As this is information is managed at the top level of a Clojure system, it avoids unnecessary coupling between system services.</p>"},{"location":"service-repl-workflow/#reloaded-repl-workflow","title":"Reloaded REPL workflow","text":"<p>Reloaded REPL workflow provides a simple way to reload changes into the system as it is being developed.</p> <p>A Reloaded REPL workflow manages the start and stop of these services, as well as the system configuration.  It is also possible to view the live system configuration and interact with the configuration.</p> <p></p>"},{"location":"service-repl-workflow/#integrant-and-integrant-repl","title":"Integrant and Integrant REPL","text":"<p>Integrant is used for managing the life-cycle of services when running the application, either locally or deployed in an environment (e.g. test, stage, live).</p> <p>Integrant REPL is used to manage services actively being developed and provides access to the configuration to start services (<code>integrant.repl.state/config</code>) and the configuration of the running system state (<code>integrant.repl.state/system</code>)</p>"},{"location":"service-repl-workflow/#aero-defining-environment-profiles","title":"Aero - defining environment profiles","text":"<p>Aero provides a way to define multiple environment profiles, so the same <code>resources/config.edn</code> file can support <code>develop</code>, <code>test</code>, <code>stage</code> and <code>live</code> environments.</p> <p>A specific profile value is given to <code>aero/read-config</code> which parses the Integrant configuration, returning an updated Integrant configuration containing that profiles specific values for each key.</p> <p>As each part of the system can be defined using profiles, the same <code>resources/config.edn</code> configuration can be used for both Integrant and Integrant REPL</p>"},{"location":"service-repl-workflow/#references","title":"References","text":"<ul> <li>Enter Integrant: a micro-framework for data-driven architecture with James Reeves - SkillsMatter</li> </ul>"},{"location":"service-repl-workflow/#alternative-tools","title":"Alternative tools","text":"<ul> <li>Mount</li> <li>Component</li> <li>Component.repl</li> <li>JUXT/clip</li> </ul>"},{"location":"service-repl-workflow/aero-environment-profiles/","title":"Aero System configuration","text":"<p>Aero enables a declarative definition of system components using Clojure hash-maps.</p> <p>Expressing a configuration purely as data helps</p> <p>Each component is a top-level key associated with hash-map containeing the component configuration, optionally using a profile to support multiple environments in which the components will run (e.g. development, testing, staging, production)</p>"},{"location":"service-repl-workflow/aero-environment-profiles/#configuration-as-data","title":"Configuration as data","text":"<p>Configuration should be explicit  obvious, but not clever. It should be easy to understand what the config is, and where it is declared.</p> <pre><code>(require '[aero.core :as aero])\n(aero/read-config \"config.edn\")\n</code></pre>"},{"location":"service-repl-workflow/aero-environment-profiles/#aero-tag-literals","title":"Aero Tag Literals","text":"<p>Aero uses tag literals as placeholders for specific values and custom tag litterals can be added</p> <ul> <li><code>#profile</code> - replace with the value from the given profile name</li> <li><code>#hostname</code> - replace with the value from the given computer hostname</li> <li><code>#or</code>  - a vector of possible values, returning the first \"truthy\" value</li> <li><code>#long</code> - cast a String value to a Clojure Long type (e.g. for PORT values)</li> <li><code>#ref</code> - refer to another part of the system configuration rather than duplicate it</li> <li><code>#ig/ref</code> - integrant version of #ref to reference another part of the system</li> </ul>"},{"location":"service-repl-workflow/aero-environment-profiles/#component-relationships","title":"Component Relationships","text":"<p><code>#ig/ref</code> defines a reference (relationship) to another component</p> <p>In the following example,</p> <ul> <li>relational-store defines a database connection</li> <li>an request router includes a reference to the database connection, so handlers can be passed connection details</li> <li>http-server includes a reference to the router that will assign all requests to the relevant handler functions</li> </ul> <pre><code>{:practicalli.scoreboard.service/relational-store\n {:connection {:url \"http://localhost/\" :port 57207 :database \"scoreboard\"}}\n\n :practicalli.scoreboard.service/router\n {:persistence #ig/ref :practicalli.scoreboard.service/relational-store}}\n\n :practicalli.scoreboard.service/http-server\n {:handler #ig/ref :practicalli.scoreboard.service/router\n  :join? false}\n</code></pre>"},{"location":"service-repl-workflow/aero-environment-profiles/#profiles","title":"profiles","text":"<p>The same configuration can be used that starts the system using profiles, or a separate develop profile can be created.</p> <p><code>#profile</code> is a tag literal used to express values for different deployment configurations.</p> <p>When a specific profile is used to parse the configuration only the matching profile values are returned each key.  So a profile is a type of filter on each part of the system configuration.</p> <p>As each part of the system can be defined using profiles, the same <code>resources/config.edn</code> configuration can be used for both Integrant and Integrant REPL</p> <pre><code>{:practicalli.scoreboard.service/http-server\n{:handler #ig/ref :practicalli.scoreboard.service/router\n:port #profile {:develop #long #or [#env APP_SERVER_PORT 8888]\n:test    #long #or [#env APP_SERVER_PORT 8080]\n:stage   #long #or [#env APP_SERVER_PORT 8080]\n:live    #long #or [#env APP_SERVER_PORT 8000]}\n:join? false}\n:practicalli.scoreboard.service/router\n{:persistence #ig/ref :practicalli.scoreboard.service/relational-store}\n:practicalli.scoreboard.service/relational-store\n{:connection #profile {:develop  {:url \"http://localhost/\" :port 57207 :database \"scoreboard-develop\"}\n:test     {:url \"http://localhost/\" :port 57207 :database \"scoreboard-test\"}\n:stage    {:url \"http://localhost/\" :port 57207 :database \"scoreboard-stage\"}\n:live     {:url \"http://localhost/\" :port 57207 :database \"scoreboard\"}}}}\n</code></pre>"},{"location":"service-repl-workflow/aero-environment-profiles/#gameboard-example","title":"Gameboard example","text":"<pre><code>;; --------------------------------------------------\n;; Application Component configuration - Integrant &amp; Integrant REPL\n;;\n;; - Event logging (mulog)\n;; - HTTP Server  (embedded jetty or http-kit)\n;; - Request routing (reitit)\n;; - Persistence (relational) connection\n;;\n;; #profile used by aero to select the configuration to use for a given profile (dev, test, prod)\n;; #long defines Long Integer type (required for Java HTTP server port)\n;; #env reads the environment variable of the given name\n;; #or uses first non nil value in sequence\n;;\n;; Environment variables should be defined locally and in deployment provisioner\n;; --------------------------------------------------\n{;; --------------------------------------------------\n;; Event logging service - mulog\n;; https://github.com/BrunoBonacci/mulog#publishers\n;; https://github.com/openzipkin/zipkin\n:practicalli.gameboard.service/log-publish\n{;; Type of publisher to use for mulog events\n;; Publish json format logs, captured by fluentd and exposed via OpenDirectory\n:mulog #profile {:dev  {:type :console-json :pretty? true}\n;; Multiple publishers using Open Zipkin service (started via docker-compose)\n:docker  {:type :multi\n:publishers\n[{:type :console-json :pretty? false}\n{:type :zipkin :url \"http://localhost:9411/\"}]}\n:prod {:type :console-json :pretty? false}}}\n;; --------------------------------------------------\n;; HTTP Server - embedded service\n:practicalli.gameboard.service/http-server\n{;; Router function passed into the HTTP server form managing requests/responses\n:handler #ig/ref :practicalli.gameboard.service/router\n;; Port number (Java Long type) - environment variable or default number\n:port  #long #or [#env HTTP_SERVER_PORT 8080]\n;; Join REPL to HTTP server thread\n:join? false}\n;; --------------------------------------------------\n;; persistence - connection to Billie shared relational storage\n;; TODO: add database connection pool ?\n:practicalli.gameboard.service/relational-store\n{:host #or [#env DATABASE_HOST \"localhost\"]\n:port #or [#env DATABASE_PORT 3306]\n:username #or [#env DATABASE_USERNAME \"gameboard\"]\n:password #or [#env DATABASE_PASSWORD \"trustnoone\"]}\n;; --------------------------------------------------\n;; Data provider services\n;; - connection to services that provide eSports data\n:practicalli.gameboard.service/data-provider\n{;; external data providers via Risky\n:llamasoft-api-url  #or [#env LAMASOFT_API_URL \"http://localhost\"]\n:polybus-report-uri \"/report/polybus\"\n:moose-life-report-uri \"/api/v1/report/moose-life\"\n:minotaur-arcade-report-uri \"/api/v2/minotar-arcade\"\n:gridrunner-revolution-report-uri \"/api/v1.1/gridrunner\"\n:space-giraffe-report-uri \"/api/v1/games/space-giraffe\"}\n;; --------------------------------------------------\n;; routing\n;; Configure web routing application with application environment\n;; define top-level keys to access via the environment hash-map\n;; - :persistence - database connection information\n;; - :services - url, endpoint, tokens for services used by the Fraud API (e.g. risky)\n:practicalli.gameboard.service/router\n{:persistence #ig/ref :practicalli.gameboard.service/relational-store\n:data-provider #ig/ref :practicalli.gameboard.service/data-provider}}\n</code></pre>"},{"location":"service-repl-workflow/integrant-repl/","title":"Integrant REPL","text":"<p>Start and restart services quickly and easily from within the REPL with Integrant REPL.</p> <p>Integrant REPL is for developing a system using a reloaded REPL workflow and is a separate Library and intent to that of Integrant, which is aimed at the lifecycle of running a system.</p> <p>Reloaded REPL provides a simple way to reload changes into the system as it is being developed. Simple <code>(go)</code>, <code>(reset)</code> and <code>(stop)</code> commands are used with the REPL to control the system.</p> <p>To assist with debugging, the parsed configuration, <code>(config)</code>, and system configuration, <code>(system)</code>, data can be viewed via the REPl state to understand how the configuration is being resolved.  This is especially useful when using aero and environment variables.</p> Integrant REPL and Integrant <p>Integrant and Integrant REPL can share the same system configuration file, although they are otherwise separate ways of working with a system.</p> <p>Integrant is used to start a system in a consistent order and gracefully shutdown the system on a termination message, e.g. <code>SIGTERM</code>.</p> <p>Integrant REPL is additionally used to restart the services during development, loading all code changes into the REPL (especially useful after ranaming functions and namespaces)</p>"},{"location":"service-repl-workflow/integrant-repl/#integrant-configuration","title":"Integrant configuration","text":"<p>Define the configuration for each part of the system, such as http server (jetty, httpkit), router application (reitit, compojure, ring) and persistence storage (postgres, crux)</p> <p>Create a <code>develop/resources/config.edn</code> file containing the Integrant REPL configuration (or use aero with <code>resources/config.edn</code> file and share the configuration with Integrant)</p> <pre><code>{:practicalli.scoreboard.service/http-server\n{:handler #ig/ref :practicalli.scoreboard.service/router\n:port  8888\n:join? false}\n:practicalli.scoreboard.service/router\n{:persistence #ig/ref :practicalli.scoreboard.service/relational-store}\n:practicalli.scoreboard.service/relational-store\n{:connection  {:url \"http://localhost/\" :port 57207 :database \"scoreboard\"}}}\n</code></pre> <p>Clojure encourages fully qualified keywords, i.e. domain/key, so that keys are unique throughout the system.</p> <p>The domain used for integrant is the Clojure namespace that contains the <code>defmethod init-key</code> for the key.  The Integrant <code>load-namespaces</code> function will automatically load all namespaces that match key names</p>"},{"location":"service-repl-workflow/integrant-repl/#user-namespace","title":"User namespace","text":"<p>Common practice is to place the Integrant REPl code in a <code>user</code> namespace, which is automatically loaded when the REPL process starts.</p> <p>The <code>user</code> namespace is defined separately from the source code, as it is code to manage the application rather than part of the application itself.  The user namespace is added to the <code>develop/user.clj</code> file and added to the classpath when developing.</p> <pre><code>(ns user\n(:require\n;; REPL workflow\n[integrant.repl       :as ig-repl]\n[integrant.repl.state :as ig-state]\n;; Environment parsing\n[aero.core :as aero]\n;; Utilities\n[clojure.pprint :as pprint]))\n</code></pre>"},{"location":"service-repl-workflow/integrant-repl/#managing-the-classpath","title":"Managing the classpath","text":"<p>Practicalli Clojure CLI Config aliases defines aliases that include the <code>dev</code> directory that contains the <code>user</code> namespace on the class path</p> REPL ReloadedDev ToolsPath <p><code>:dev/reloaded</code> alias starts a rich terminal REPL prompt, with the <code>dev</code> path and several tools to enhance the REPL workflow <pre><code>clojure -M:repl/reloaded\n</code></pre></p> <p><code>:dev/reloaded</code> alias adds the <code>dev</code> path and several tools to enhance the REPL workflow <pre><code>clojure -M:dev/reloaded:repl/rebl\n</code></pre></p> <p><code>:env/dev</code> alias adds the <code>dev</code> path on REPL start up, include the <code>dev/user.clj</code> file <pre><code>clojure -M:env/dev:repl/rebl\n</code></pre></p>"},{"location":"service-repl-workflow/integrant-repl/#environment-configuration","title":"Environment Configuration","text":"<p>Using aero with the Integrant configuration file includes tag literals that need to be resolved.</p> <pre><code>;;;; Aero environment management\n;; extra reader tag for Integrant references\n(defmethod aero/reader 'ig/ref\n[_ tag value]\n(ig/ref value))\n(defn aero-config\n\"Profile specific configuration for all services.\n  Profiles supported: :develop :stage :live\"\n[profile]\n(aero/read-config (io/resource \"config.edn\") {:profile profile}))\n(defn aero-prep\n\"Parse the system config and update values for the given profile (:develop, :stag :live)\n  Top-level keys in the config.edn use a qualified name of the Clojure namespace the ig/init-key defmethod is defined in\n  ig/load-namespaces will automatically load each namespace referenced by a top-level key in the Integrant configuration\n  Return: configuration hash-map for the specified profile (:develop :stage :live)\"\n[profile]\n(let [config (aero-config profile)]\n(ig/load-namespaces config)\nconfig))\n</code></pre>"},{"location":"service-repl-workflow/integrant-repl/#parse-configuration","title":"Parse Configuration","text":"<pre><code>(defn integrant-prep!\n\"Parse system configuration with aero-reader and apply the given profile values\n  Return: Integrant configuration to be used to start the system\n  integrant.repl/set-prep! takes an anonymous function that returns an integrant configuration\n  Arguments: profile - a keyword determining the environment - :develop :test :stage :live\"\n[profile]\n(ig-repl/set-prep!\n#(aero-prep profile)))\n</code></pre>"},{"location":"service-repl-workflow/integrant-repl/#repl-convenience-functions","title":"REPL convenience functions","text":"<pre><code>(defn go\n\"Prepare configuration and start the system services with Integrant-repl\"\n([] (go :develop))\n([profile] (integrant-prep! profile) (ig-repl/go)))\n(defn reset\n\"Read updates from the configuration and restart the system services with Integrant-repl\"\n([] (reset :develop))\n([profile] (integrant-prep! profile) (ig-repl/reset)))\n(defn reset-all\n\"Read updates from the configuration and restart the system services with Integrant-repl\"\n([] (reset-all :develop))\n([profile] (integrant-prep! profile) (ig-repl/reset-all)))\n(defn stop\n\"Shutdown all services\"\n[] (ig-repl/halt))\n(defn system\n\"The running system configuration\"\n[] ig-state/system)\n(defn config\n\"The current system configuration used by Integrant\"\n[] ig-state/config)\n</code></pre>"},{"location":"service-repl-workflow/integrant-repl/#repl-commands","title":"REPL Commands","text":"<pre><code>(comment\n;; Prepare and start the system using the :develop profile or specify the environment\n(go)\n(go :test)\n;; Reload changed and new source code files and restart the system\n(reset)\n(reset :develop)\n;; Reload all source code files on the Classpath and restart the system\n(reset-all)\n(reset-all :develop)\n;; Return the current Integrant configuration (already parsed by environment)\n(config)\n;; Show the running system configuration, returns nil when system not running\n(system)\n;; Shutdown the system using the app-server object reference in the Integrant state\n(stop)\n;; Pretty print the system state in the REPL\n(pprint/pprint ig-state/system)\n#_()) ;; End of rich comment block\n</code></pre> requiring-resolve for Just In Time requires <p>Integrant in practice provides an example of using <code>requiring-resolve</code> to avoid including all requires in the <code>ns</code> form, potentially reducing REPL startup time by not adding library</p> <p>When calling an Integrant function, <code>requiring-resolve</code> returns the name of the symbol if already available in the REPL, or requires the functions namespace if the function is not available.</p> <p>The library containing the namespace must be part of the class path when the REPL starts (or library has been hotloaded into the REPL) <pre><code>(ns user\n\"Reduce REPL startup time by not including requires\")\n(defmacro jit\n\"Resolve a symbol name and require its namespace if not currently available in the REPL\"\n[qualified-symbol]\n`(requiring-resolve '~qualified-symbol))\n(defn set-prep! []\n((jit integrant.repl/set-prep!) #((jit feralberry.system/prep) :dev)))\n(defn go []\n(set-prep!)\n((jit integrant.repl/go)))\n(defn reset []\n(set-prep!)\n((jit integrant.repl/reset)))\n(defn system []\n@(jit integrant.repl.state/system))\n(defn config []\n@(jit integrant.repl.state/config))\n</code></pre></p>"}]}